<!DOCTYPE HTML>
<html lang="id" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Control Flow - Rust Note</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust dalam Bahasa Indonesia">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../rust_id.html">Rust ID</a></li><li class="chapter-item expanded affix "><a href="../0_pengenalan.html">Pengenalan</a></li><li class="chapter-item expanded "><a href="../basic/0_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic/1_instalasi.html"><strong aria-hidden="true">1.1.</strong> Instalasi</a></li><li class="chapter-item expanded "><a href="../basic/2_toolchain.html"><strong aria-hidden="true">1.2.</strong> Toolchain</a></li><li class="chapter-item expanded "><a href="../basic/3_hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="../basic/4_struktur_codebase.html"><strong aria-hidden="true">1.4.</strong> Struktur Codebase</a></li><li class="chapter-item expanded "><a href="../basic/5_variables_function_closure.html"><strong aria-hidden="true">1.5.</strong> Variables, Functions, and Closures</a></li><li class="chapter-item expanded "><a href="../basic/6_primitive_types.html"><strong aria-hidden="true">1.6.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basic/7_string_types.html"><strong aria-hidden="true">1.7.</strong> String Types</a></li><li class="chapter-item expanded "><a href="../basic/8_compound_types.html"><strong aria-hidden="true">1.8.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="../basic/9_algebraic_types.html"><strong aria-hidden="true">1.9.</strong> Algebraic Types</a></li><li class="chapter-item expanded "><a href="../basic/10_collection_types.html"><strong aria-hidden="true">1.10.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="../basic/11_control_flow.html" class="active"><strong aria-hidden="true">1.11.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basic/12_ownership_and_borrowing.html"><strong aria-hidden="true">1.12.</strong> Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="../basic/13_associated_items.html"><strong aria-hidden="true">1.13.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="../basic/14_trait.html"><strong aria-hidden="true">1.14.</strong> Trait</a></li><li class="chapter-item expanded "><a href="../basic/15_generic.html"><strong aria-hidden="true">1.15.</strong> Generic</a></li><li class="chapter-item expanded "><a href="../basic/16_generic_bound_with_trait.html"><strong aria-hidden="true">1.16.</strong> Generic Bound with Trait</a></li><li class="chapter-item expanded "><a href="../basic/17_lifetime.html"><strong aria-hidden="true">1.17.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="../basic/18_error_handling.html"><strong aria-hidden="true">1.18.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../basic/19_unit_test.html"><strong aria-hidden="true">1.19.</strong> Unit Test</a></li><li class="chapter-item expanded "><a href="../basic/20_cargo_dan_konfigurasi.html"><strong aria-hidden="true">1.20.</strong> Cargo dan Konfigurasi</a></li></ol></li><li class="chapter-item expanded "><a href="../intermediate/0_intermediate.html"><strong aria-hidden="true">2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/1_functional_programming.html"><strong aria-hidden="true">2.1.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../intermediate/2_fp_rust.html"><strong aria-hidden="true">2.2.</strong> Functional Programming pada Rust(soon)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Note</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Kita akan membahas beberapa control flow yang ada pada Rust seperti <code>if</code> <code>else</code>, loops dan match.</p>
<h2 id="ifelse"><a class="header" href="#ifelse">If/Else</a></h2>
<p>Percabangan pada kode.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// single if
let a = 1;
if a == 1 {
    println!(&quot;true&quot;);
}

// if and else
if a == 2 {
    println!(&quot;True&quot;);
} else {
    println!(&quot;False&quot;);
}

// if, else if, and else
let a = 3;
if a == 2 {
    println!(&quot;True&quot;);
} else if a == 3 {
    println!(&quot;True again&quot;);
} else {
    println!(&quot;False&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Karena if/else adalah expression maka kita bisa return value ke suatu variable lewat if/else.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 5;
let f = if a % 2 == 0 {
    String::from(&quot;a: {a} is even&quot;)
} else {
    String::from(&quot;a: {a} is odd&quot;)
};
println!(&quot;--&gt; {f:?}&quot;); // &quot;a: 5 is odd&quot;
<span class="boring">}</span></code></pre></pre>
<h2 id="loop"><a class="header" href="#loop">Loop</a></h2>
<p>Infinite loop.
Exit loop using <code>break</code>.
Continue to the next loop before finishing current loop using <code>continue</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut c = 0;
loop {
    std::thread::sleep(std::time::Duration::from_millis(500));
    if c == 10 {
        println!(&quot;Done&quot;);
        break;
    }
    if c % 2 == 0 {
        println!(&quot;c: {c} even number&quot;);
        c += 1;
        continue;
    } else if c % 2 != 0 {
        println!(&quot;c: {c} odd number&quot;);
        c += 1;
        continue;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Kita bisa menggunakan <code>break</code> untuk menghentikan loop dan mengembalikan value ke variable dengan meletakkan expression setelah <code>break</code>;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut g = 0;
let ret = loop {
    g += 1;
    if g == 10 {
        break g * 50; // 500
    }
};
println!(&quot;---&gt; ret: {ret}&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="loop-with-labels"><a class="header" href="#loop-with-labels">Loop with labels</a></h2>
<p>Rust memiliki semacam konsep <code>goto</code> yang bisa digunakan untuk <code>break</code> atau <code>continue</code> loop kesuatu tempat yang telah diberi label menggunakan lifetime <code>'label</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut d = 0;
'outer: loop {
    d += 1;
    'inner: loop {
        std::thread::sleep(std::time::Duration::from_millis(500));
        if d == 10 {
            break 'outer;
        }
        if d % 2 == 0 {
            println!(&quot;d: {d} even number&quot;);
            continue 'outer;
        } else {
            println!(&quot;d: {d} odd number&quot;);
            d += 1;
            continue; // no label means continue current label ('inner)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<p>Loop berjalan selama kondisi terpenuhi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 0;
while a &lt; 10 {
    println!(&quot;while loop: {a}&quot;);
    a += 1;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="for-loop"><a class="header" href="#for-loop">for loop</a></h2>
<p>Melakukan iterasi terhadap tipe data yang mengimplementasi trait <code>Iterator</code>. Biasanya data tersebut berupa data compunds atau collections seperti array, slices, vector, map dan lainnya. Semua tipe-tipe data tersebut sudah implement trait <code>Iterator</code> di dalam Rust secara built-in.
Rust memiliki <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expression</a> sebagai ekspresi ketika melakukan looping data. 
Berikut 2 contoh:</p>
<ul>
<li>Loop excluding last index:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// akan melakukan print dari 0 sampai 9
for i in 0..10 {
  println!(&quot;{i}&quot;);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>Loop including last index:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// akan melakukan print dari 0 sampai 10
for i in 0..=10 {
  println!(&quot;{i}&quot;);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Ekspresi tersebut sudah mengimplementasikan Iterator Trait menggunakan tipe range dari <a href="https://doc.rust-lang.org/stable/std/ops/#structs">ops</a>.</p>
<p>Selain menggunakan expression di atas, kita juga bisa menggunakan tipe data lain yang juga sudah implements Trait Iterator. Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// iterate over slice
let data = &amp;[1,2,3,4,5];
for x in data {
    println!(&quot;data: {x}&quot;);
}

// iterate over vector
let data = vec![1,2,3,4,5];
for x in data {
    println!(&quot;data: {x}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Terdapat 3 methods yang menjadi idiom dan di-implement hampir semua tipe data di dalam Rust untuk menghasilkan data <code>Iterator</code>, yaitu:</p>
<ul>
<li><code>into_iter()</code>: Take and own each items in the data. Default jika tidak dideclare pada saat looping.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // into_iter()
  let data1 = [1, 2, 3, 4, 5];
  println!(&quot;into_iter():&quot;);
  /**
  * Since data type is array and elements are primitive types(i32),
  * Using into_iter() on it will only copy it since no moving required.
  * Hence you can still call data after these 2 iterator since &quot;move&quot; mechanism for copy data(stack allocated) is only &quot;copy&quot;.
  */
  // `into_iter()` will be applied by default by compiler if not specified
  for x in data1 {
      println!(&quot;{x}&quot;);
  }
  // kode di atas sama dengan
  for x in data1.into_iter() {
      println!(&quot;{x}&quot;);
  }

  // getting index and value
  for (i, x) in data1.into_iter().enumerate() {
      println!(&quot;{i}:{x}&quot;);
  }
  println!(&quot;data: {data1:?}&quot;);

  /**
  * if you use into_iter() to data with borrowed type(reference), then into_iter() cannot own the elements since its parent is referenced/borrowed.
  * Hence in each iterator you only see the element as &amp;i32.
  */
  let data1: &amp;[i32] = &amp;[1, 2, 3, 4, 5];
  for x in data1.into_iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;{data1:?}&quot;);

  let data1 = &amp;[1, 2, 3, 4, 5];
  for x in data1.into_iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;{data1:?}&quot;);

  /**
  * data1 is vector type which is owned type. So into_iter() will make it moved.
  */
  let data1 = vec![1, 2, 3, 4, 5];
  for x in data1 {
      // implicitly and defaultly implement into_iter()
      println!(&quot;{}&quot;, x);
  }
  // println!(&quot;data: {data1:?}&quot;); //// won't work because data already moved by into_iter()
  let data1_1 = vec![1, 2, 3, 4, 5];
  for x in data1_1.into_iter().enumerate() {
      println!(&quot;{} {}&quot;, x.0, x.1);
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li><code>iter()</code>: Borrow and make reference to each items immutably in the data.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // iter()
  let data2 = [1, 2, 3, 4, 5];
  println!(&quot;iter():&quot;);
  /**
   * Data type is array and calling iter() method in interation making it borrow the items inside array `&amp;i32`.
   * No copy happen since it's referencing data from array.
   */
  for x in data2.iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;data: {data2:?}&quot;);

  // getting index and value
  for x in data2.iter().enumerate() {
      println!(&quot;{} {}&quot;, x.0, x.1);
  }

  /**
   * vector is owned type but iter() only borrow the items inside so can be used after iteration.
   */
  let data2 = vec![1, 2, 3, 4, 5];
  for x in data2.iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;data: {data2:?}&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li><code>iter_mut()</code>: Borrow and make reference to each items mutably in the data.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // iter_mut()
  let mut data3 = [1, 2, 3, 4, 5];
  /**
   * iter_mut() will borrow each items as mutable reference if the source data is mutable.
   */
  for x in data3.iter_mut() {
      *x = *x * 2;
  }
  println!(&quot;data: {data3:?}&quot;);

  let mut data3 = vec![1, 2, 3, 4, 5];
  /**
   * When you iter_mut and enumerate the data, you can only mutate the data's value, not index.
   * Also it won't take any ownership since it's borrowed/referenced.
   */
  for (i, x) in data3.iter_mut().enumerate() {
      *x = *x * 5;
      println!(&quot;{i} {x}&quot;);
  }
  println!(&quot;data: {data3:#?}&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="match"><a class="header" href="#match">match</a></h2>
<p>Match merupakan feature pada rust untuk melakukan pattern matching terhadap value dan/atau tipe data, khususnya sum type(enum). 
Bersifat <strong>exhaustive</strong> karena semua kemungkinan value harus dideklarasi, atau bisa diignore menggunakan keyword wildcard <code>_</code>.
Setiap value yang mungkin matched disebut sebagai <em>arm</em>.
Arm wildcard <code>_</code> <strong>HARUS</strong> ditaruh paling bawah karena sifat exhaustive dan menemukan kemungkinan pertama pada match akan menghilangkan purpose dari pattern matching itu sendiri. Match akan melakukan pengecekkan dari atas kebawah, sehingga wildcard butuh ditaruh paling bawah.</p>
<ul>
<li>Match against single value:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 19;
println!(&quot;Tell me about {}&quot;, number);
/**
 * If we want to match against i32, 
 * there'll be 2147483647 possible arms that we have to specify inside match.
 * This is impossible to write by hand,
 * most of the time you only need certain values to be checked against,
 * hence you can use `_` to handle the rest of the possible arms.
 */
match number {
    // Match a single value
    1 =&gt; println!(&quot;One!&quot;),
    // Match several values
    2 | 3 | 5 | 7 | 11 | 13 =&gt; println!(&quot;This is a prime&quot;),
    // Match an inclusive range
    13..=19 =&gt; println!(&quot;A teen&quot;),
    // Handle the rest of cases
    _ =&gt; println!(&quot;SUDAH TUA!!!!&quot;),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Match against tuple:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple = (1, 2, 3);
match tuple {
    (2, y, z) =&gt; println!(&quot;1st arm&quot;), // invalidated because first tuple element must be 1 in order to match.
    (x, 5, z) =&gt; println!(&quot;2nd arm&quot;), // invalidated because second element must be 2 in order to match.
    (x, y, 3) =&gt; println!(&quot;3rd arm&quot;), // validated because 3rd matched, 1st and 2nd arm only fetched as variable(can be anything from the tuple itself).
    _ =&gt; println!(&quot;404&quot;),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Match against array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// from https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_slice.html
  // Try changing the values in the array, or make it a slice!
  let array = [1, -2, 6];

  match array {
      // Binds the second and the third elements to the respective variables
      [0, second, third] =&gt; println!(&quot;array[0] = 0, array[1] = {}, array[2] = {}&quot;, second, third),

      // Single values can be ignored with _
      [1, _, third] =&gt; println!(
          &quot;array[0] = 1, array[2] = {} and array[1] was ignored&quot;,
          third
      ),

      // You can also bind some and ignore the rest
      [-1, second, ..] =&gt; println!(
          &quot;array[0] = -1, array[1] = {} and all the other ones were ignored&quot;,
          second
      ),
      // The code below would not compile
      // [-1, second] =&gt; ...

      // Or store them in another array/slice (the type depends on
      // that of the value that is being matched against)
      [3, second, tail @ ..] =&gt; println!(
          &quot;array[0] = 3, array[1] = {} and the other elements were {:?}&quot;,
          second, tail
      ),

      // Combining these patterns, we can, for example, bind the first and
      // last values, and store the rest of them in a single array
      [first, middle @ .., last] =&gt; println!(
          &quot;array[0] = {}, middle = {:?}, array[2] = {}&quot;,
          first, middle, last
      ),
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Match against enum</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `allow` required to silence warnings because only
  // one variant is used.
  #[allow(dead_code)]
  enum Color {
      // These 3 are specified solely by their name.
      Red,
      Blue,
      Green,
      // These likewise tie `u32` tuples to different names: color models.
      RGB(u32, u32, u32),
      HSV(u32, u32, u32),
      HSL(u32, u32, u32),
      CMY(u32, u32, u32),
      CMYK(u32, u32, u32, u32),
  }

  let color = Color::RGB(122, 17, 40);
  // TODO ^ Try different variants for `color`

  println!(&quot;What color is it?&quot;);
  // An `enum` can be destructured using a `match`.
  match color {
      Color::Red =&gt; println!(&quot;The color is Red!&quot;),
      Color::Blue =&gt; println!(&quot;The color is Blue!&quot;),
      Color::Green =&gt; println!(&quot;The color is Green!&quot;),
      Color::RGB(r, g, b) =&gt; println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
      Color::HSV(h, s, v) =&gt; println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
      Color::HSL(h, s, l) =&gt; println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
      Color::CMY(c, m, y) =&gt; println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
      Color::CMYK(c, m, y, k) =&gt; println!(
          &quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
          c, m, y, k
      ),
      // Don't need another arm because all variants have been examined
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Match against reference and pointer</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assign a reference of type `i32`. The `&amp;` signifies there
  // is a reference being assigned.
  let reference = &amp;4;

  match reference {
      val =&gt; println!(&quot;value: {val:?}&quot;),
  }
  match reference {
      &amp;4 =&gt; println!(&quot;reference of four&quot;),
      _ =&gt; println!(&quot;other&quot;),
  }
  match reference {
      4 =&gt; println!(&quot;value of four&quot;),
      _ =&gt; println!(&quot;other&quot;),
  }
  match reference {
      // If `reference` is pattern matched against `&amp;val`, it results
      // in a comparison like:
      // `&amp;i32`
      // `&amp;val`
      // ^ We see that if the matching `&amp;`s are dropped, then the `i32`
      // should be assigned to `val`.
      &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
  }

  // To avoid the `&amp;`, you dereference before matching.
  match *reference {
      val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
  }

  // What if you don't start with a reference? `reference` was a `&amp;`
  // because the right side was already a reference. This is not
  // a reference because the right side is not one.
  let _not_a_reference = 3;

  // Rust provides `ref` for exactly this purpose. It modifies the
  // assignment so that a reference is created for the element; this
  // reference is assigned.
  let ref _is_a_reference = 3;

  // Accordingly, by defining 2 values without references, references
  // can be retrieved via `ref` and `ref mut`.
  let value = 5;
  let mut mut_value = 6;

  // Use `ref` keyword to create a reference.
  match value {
      ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
  }

  // Use `ref mut` similarly.
  match mut_value {
      ref mut m =&gt; {
          // Got a reference. Gotta dereference it before we can
          // add anything to it.
          *m += 10;
          println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
      }
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Match against struct</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
      x: (u32, u32),
      y: u32,
  }

  // Try changing the values in the struct to see what happens
  let foo = Foo { x: (1, 2), y: 3 };

  match foo {
      Foo { x: (1, b), y } =&gt; println!(&quot;First of x is 1, b = {},  y = {} &quot;, b, y),

      // you can destructure structs and rename the variables,
      // the order is not important
      Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),

      // and you can also ignore some variables:
      Foo { y, .. } =&gt; println!(&quot;y = {}, we don't care about x&quot;, y),
      // this will give an error: pattern does not mention field `x`
      //Foo { y } =&gt; println!(&quot;y = {}&quot;, y),
  }
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="match-with-guards"><a class="header" href="#match-with-guards">match with guards</a></h2>
<p>Ketika kita ingin menambahkan kondisi terhadap matching arms.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// from: https://doc.rust-lang.org/rust-by-example/flow_control/match/guard.html
    enum Temperature {
        Celsius(i32),
        Fahrenheit(i32),
    }

    let temperature = Temperature::Celsius(35);

    match temperature {
        // guard harus ditaruh lebih awal dibanding tanpa guard karena lebih spesifik.
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        // The `if condition` part ^ is a guard
        Temperature::Celsius(t) =&gt; println!(&quot;{}C is below 30 Celsius&quot;, t),

        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
    }

    match temperature {
        // guard harus ditaruh lebih awal dibanding tanpa guard karena lebih spesifik.
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        // The `if condition` part ^ is a guard
        Temperature::Celsius(20) =&gt; println!(&quot;C is below 30 Celsius&quot;),

        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
        _ =&gt; println!(&quot;404&quot;), // wildcard dibutuhkan karena arm ke-dua memiliki value langsung yang menghilangkan sifat exhautiveness dari arms.
    }

    let number: i8 = 4;
    match number {
        i if i == 0 =&gt; println!(&quot;Zero&quot;),
        i if i &gt; 0 =&gt; println!(&quot;Greater than zero&quot;),
        i if i &lt; 0 =&gt; println!(&quot;Lesser than zero&quot;),
        _ =&gt; println!(&quot;404&quot;), // wildcard tetap harus ada karena guards tidak memvalidasi sifat exhaustive dari arms.
    }

    let number: i8 = 4;
    match number {
        i if i == 0 =&gt; println!(&quot;Zero&quot;),
        i if i &gt; 0 =&gt; println!(&quot;Greater than zero&quot;),
        i if i &lt; 0 =&gt; println!(&quot;Lesser than zero&quot;),
        i =&gt; println!(&quot;{i}&quot;), 
        // wildcard tidak dibutuhkan karena exhaustiveness sudah di-achieve oleh arm `i =&gt; println!(&quot;{i}&quot;)` karena sudah nge-cover apa saja.
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="match-with-binding"><a class="header" href="#match-with-binding">match with binding</a></h2>
<p>Melakukan match dengan melakukan <em>binding</em> suatu variable ke kemungkinan-kemungkinan values yang tersedia.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// from: https://doc.rust-lang.org/rust-by-example/flow_control/match/binding.html
// A function `age` which returns a `u32`.
    fn age() -&gt; u32 {
        15
    }

    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I haven't celebrated my first birthday yet&quot;),
        // Could `match` 1 ..= 12 directly but then what age
        // would the child be? Instead, bind to `n` for the
        // sequence of 1 ..= 12. Now the age can be reported.
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // Nothing bound. Return the result.
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }


    fn some_number() -&gt; Option&lt;u32&gt; {
        Some(42)
    }
    
    match some_number() {
        // Got `Some` variant, match if its value, bound to `n`,
        // is equal to 42.
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),
        // Match any other number.
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),
        // Match anything else (`None` variant).
        _            =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<p>Digunakan ketika:</p>
<ul>
<li>Mengecek 1 kemungkinan value dari sebuah variable dengan meng-assign value ke dalam variable baru untuk digunakan selanjutnya</li>
<li>Me-destructure 1 variable  untuk hanya 1 type/value, tanpa harus melalui pattern matching.
Contoh:
Ketika ingin memeriksa sebuah enum, jika menggunakan match:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(5);
match s {
    Some(n) =&gt; println!(&quot;{n:?}&quot;),
    _ =&gt; panic!(&quot;panic&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Kita harus mematuhi sifat exhaustiveness dari pattern matching, padahal kita hanya butuh 1 kemungkinan value. </p>
<p>Alternative lain yang lebih simple adalah menggunakan <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(5);
if let Some(n) = s {
    println!(&quot;{n}&quot;);
}
if let Some(3) = s {
    println!(&quot;matched!&quot;);
} else {
    println!(&quot;not matched!&quot;);
}

if let n = s {
    println!(&quot;{:#?}&quot;, n);
}

struct A {
    pub a: i32,
    pub b: String,
}

let astruct = A {
        a: 123,
        b: String::from(&quot;anu&quot;),
    };
let bb = String::from(&quot;anu&quot;);
if let A {
    a: 123, 
    b: bb,
} = astruct {
    println!(&quot;matched$$&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="while-let"><a class="header" href="#while-let">while let</a></h2>
<p>Sama seperti <code>if let</code>, hanya saja menggunakan loop <code>while</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = Some(5);
while let Some(n) = a {
    a = Some(n+1);
    if n &gt; 10 {
        a = None;
    }
    println!(&quot;$&quot;);
    std::thread::sleep(std::time::Duration::from_millis(loop_duration));
}
println!(&quot;DONE while let&quot;);
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basic/10_collection_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basic/12_ownership_and_borrowing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basic/10_collection_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basic/12_ownership_and_borrowing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
