<!DOCTYPE HTML>
<html lang="id" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ownership and Borrowing - Rust Note</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust dalam Bahasa Indonesia">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../rust_id.html">Rust ID</a></li><li class="chapter-item expanded affix "><a href="../0_pengenalan.html">Pengenalan</a></li><li class="chapter-item expanded "><a href="../basic/0_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic/1_instalasi.html"><strong aria-hidden="true">1.1.</strong> Instalasi</a></li><li class="chapter-item expanded "><a href="../basic/2_toolchain.html"><strong aria-hidden="true">1.2.</strong> Toolchain</a></li><li class="chapter-item expanded "><a href="../basic/3_hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="../basic/4_struktur_codebase.html"><strong aria-hidden="true">1.4.</strong> Struktur Codebase</a></li><li class="chapter-item expanded "><a href="../basic/5_komponen_codebase.html"><strong aria-hidden="true">1.5.</strong> Komponen Codebase</a></li><li class="chapter-item expanded "><a href="../basic/6_primitive_types.html"><strong aria-hidden="true">1.6.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basic/7_string_types.html"><strong aria-hidden="true">1.7.</strong> String Types</a></li><li class="chapter-item expanded "><a href="../basic/8_compound_types.html"><strong aria-hidden="true">1.8.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="../basic/9_algebraic_types.html"><strong aria-hidden="true">1.9.</strong> Algebraic Types</a></li><li class="chapter-item expanded "><a href="../basic/10_collection_types.html"><strong aria-hidden="true">1.10.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="../basic/11_control_flow.html"><strong aria-hidden="true">1.11.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basic/12_ownership_and_borrowing.html" class="active"><strong aria-hidden="true">1.12.</strong> Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="../basic/13_associated_items.html"><strong aria-hidden="true">1.13.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="../basic/14_trait.html"><strong aria-hidden="true">1.14.</strong> Trait</a></li><li class="chapter-item expanded "><a href="../basic/15_generic.html"><strong aria-hidden="true">1.15.</strong> Generic</a></li><li class="chapter-item expanded "><a href="../basic/16_generic_bound_with_trait.html"><strong aria-hidden="true">1.16.</strong> Generic Bound with Trait</a></li><li class="chapter-item expanded "><a href="../basic/17_lifetime.html"><strong aria-hidden="true">1.17.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="../basic/18_error_handling.html"><strong aria-hidden="true">1.18.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../basic/19_unit_test.html"><strong aria-hidden="true">1.19.</strong> Unit Test</a></li><li class="chapter-item expanded "><a href="../basic/20_cargo_dan_konfigurasi.html"><strong aria-hidden="true">1.20.</strong> Cargo dan Konfigurasi</a></li></ol></li><li class="chapter-item expanded "><a href="../intermediate/0_intermediate.html"><strong aria-hidden="true">2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/1_functional_programming.html"><strong aria-hidden="true">2.1.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../intermediate/2_fp_rust.html"><strong aria-hidden="true">2.2.</strong> Functional Programming pada Rust</a></li><li class="chapter-item expanded "><a href="../intermediate/3_iterator.html"><strong aria-hidden="true">2.3.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="../intermediate/4_zero-cost_abstraction.html"><strong aria-hidden="true">2.4.</strong> Zero-cost Abstraction</a></li><li class="chapter-item expanded "><a href="../intermediate/5_smart_pointers.html"><strong aria-hidden="true">2.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="../intermediate/6_OOP.html"><strong aria-hidden="true">2.6.</strong> OOP</a></li><li class="chapter-item expanded "><a href="../intermediate/7_subtyping.html"><strong aria-hidden="true">2.7.</strong> Subtyping</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Note</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ownership--borrowing"><a class="header" href="#ownership--borrowing">Ownership &amp; Borrowing</a></h1>
<p>Sebelum kita membahas tentang <em>Ownership</em> dan <em>Borrowing</em>, kita akan membahas terlebih dahulu tentang dua jenis memori yaitu <em>Stack</em> dan <em>Heap</em>:</p>
<ul>
<li><em>Stack</em>: adalah memori bersifat LIFO(<em>Last In First Out</em>) merupakan memori yang digunakan tempat menyimpan function frame(function stack frame) yang merupakan semua intruksi-intruksi pada suatu fungsi. Selain itu juga menyimpan tipe data primitif dan pointer address. Data yang dialokasi pada <em>stack</em> dapat diketahui size-nya pada saat compile time dan fixed in size selama program berjalan. Access cepat dan semua memori di-release ketika selesai digunakan(e.g function return/exit).</li>
<li><em>Heap</em>: adalah memori yang lebih kompleks dari stack. Memori ini digunakan untuk data yang tidak diketahui sizenya secara pasti pada saat compile time, dan bisa berubah-ubah size nya selama program berjalan. Memori ini butuh dynamic allocation pada saat runtime sehingga memiliki <em>overhead</em> dan butuh di-<em>deallocate</em> ketika sudah tidak digunakan. Di dalam Rust, proses de-<em>allocate</em> ini disebut dengan <em>Drop</em>.</li>
</ul>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Ownership merupakan hal unik pada Rust yang membuat rust mampu manage memory tanpa memiliki <em>Garbage Collector</em> serta tanpa manual memory management seperti <em>alloc/free</em>. Ownership memiliki 3 aturan:</p>
<ul>
<li><em>Each value in Rust has an owner.</em></li>
<li><em>There can only be one owner at a time.</em></li>
<li><em>When the owner goes out of scope, the value will be dropped.</em></li>
</ul>
<p>Owner merupakan suatu variable yang memiliki sebuah value. Owner ini memiliki scope. Jika owner keluar dari scopenya, maka akan di-drop(released from memory).
Selain <em>drop</em>, ownership bisa berpindah tangan atau disebut dengan <em>move</em>, yaitu ketika owner masuk scope baru, sehingga owner tersebut tidak bisa digunakan di scope yang sama lagi.</p>
<p>Tipe data yang sering memiliki ownership adalah yang biasanya butuh alokasi <em>heap memory</em>, tidak fixed in size dan tidak diketahu size nya pada saat compile time.</p>
<p>Tipe data yang memiliki ownership terhadap valuenya adalah tipe data selain primitif.</p>
<p>Di dalam Rust terdapat 2 jenis trait yang berkaitan dengan <em>scope</em> variable:</p>
<ul>
<li><em>Copy</em>: Semua tipe data primitif sudah meng-implementasikan <em>copy</em> secara implisit. Trait ini memungkinkan data di-pass atau keluar scope tanpa khawatir kehilangan ownership, Karena semua data tersebut memiliki struktur memori sederhana sehingga copy data terjadi dengan sangat cepat ketika keluar/berpindah scope.</li>
<li><em>Clone</em>: Tipe data selain primitif atau yang tidak meng-implementasi <em>copy</em> secara implisit, harus implement <em>clone</em> secara eksplisit. Jika data keluar/pindah scope, maka <em>ownership</em> akan di-drop/pindah. Tipe data yang <em>clonable</em> biasanya dialokasi ke dalam <em>heap memory</em>, sehingga harus melakukan <em>deep copy</em> terhadap struktur datanya.</li>
</ul>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>Scope adalah segment kode yang menandai batas ownership suatu data yang di-<em>owned</em>. Seperti dibahas di atas, terdapat dua mekanisme yang berkaitan dengan variable yang di-<em>owned</em> yaitu <em>drop</em> atau <em>move</em>. Dua jenis scope yang ada pada Rust yaitu <em>curly brackets</em>(drop) dan <em>functions/methods arguments</em>(move).</p>
<ul>
<li>Contoh drop:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let s = String::from(&quot;string value&quot;);
        // string s will be dropped here at the end of the scope
    } // this curly bracket mark the end of s owning the String value so be dropped.
}</code></pre></pre>
<p><em>Drop</em> merupakan sebuah trait yang hampir semua tipe <em>owned</em>/<em>heap allocated</em> sudah implement secara implisit. Compiler <em>rustc</em> akan meng-<em>embed</em> drop function untuk data terkait di setiap end of scope.</p>
<ul>
<li>Contoh move:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hooh&quot;);
    function(s);
    println!(&quot;{}&quot;, &amp;s);
    println!(&quot;{}&quot;, s);
}

fn function(s: String) {} </code></pre></pre>
<p>Pada contoh di atas, variable <code>s</code> sudah berpindah scope dari <code>main</code> ke scope fungsi <code>function</code> sehingga <code>s</code> tidak bisa lagi digunakan setelah <code>function(s)</code>.
<em>Move</em> hanya terjadi pada tipe data yang bersifat <em>clonable</em> atau implement trait <code>Clone</code>. Tipe-tipe data ini biasanya dialokasi pada heap, contoh seperti di atas adalah <code>String</code>. Cara memanfaatkan data <em>clonable</em> setelah move terjadi adalah dengan memanggil method dari trait <em>Clone</em> itu sendiri yaitu <code>clone</code>. Sehingga code di atas menjadi:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hooh&quot;);
    function(s.clone());
    println!(&quot;{}&quot;, &amp;s);
    println!(&quot;{}&quot;, s);
}

fn function(s: String) {} </code></pre></pre>
<p>Sehingga <code>s</code> masih bisa digunakan setelah <code>function</code>, karena value dari <code>s</code> di-clone(eksplisit copy) ke dalam parameter <code>function</code>.
Clone melakukan <em>deep copy</em> untuk menyalin semua data yang ada ke memory baru, sehingga ini memiliki cost yang jauh lebih besar ketimbang <em>copy</em> biasa. Hal ini karena kebanyakan <em>copy</em> terjadi pada stack memory atau data dengan tipe sederhana(primitif) sehingga copy dan alokasi baru dapat dengan sangat cepat dan mudah. Untuk Clone kebanyakan data merupakan <em>heap allocated</em> sehingga butuh clone semua bentuk struktur data yang arbitrary dan mencari segment memory baru untuk alokasi baru. 
Untuk menghindari <em>overhead</em> ini, ada cara lain untuk mem-passing variable, yaitu dengan cara <em>Borrowing</em>.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Borrow adalah ketika kita me-<em>reference</em> suatu data, disebut juga dengan <em>reference type</em>. Berbeda dengan <em>Owned</em> data, <em>borrowed</em> data tidak memindahkan ownership ketika memasukin scope baru. <em>Borrowed</em> data bisa berpindah2 scope bahkan ke dalam parameter fungsi lain sehingga data masih bisa digunakan di scope yang sama. 
Reference type berbeda dengan pointer type, dimana:</p>
<ul>
<li>Reference type: must not null, always valid state and value, can be operated like normal variable.</li>
<li>Pointer type: can be null, unsafe, can cause program crash if dereferencing null pointer, butuh dereferencing saat ingin menggunakan valuenya.
Di dalam rust, kode normal sehari2 kebanyakan menggunakan reference type, jarang kita membutuhkan pointer karena konsep safety pada rust menghindari null pointer exception. Ada pengecualian untuk hal seperti butuh fleksibilitas management memory sehingga butuh pointer dan ini hanya bisa dilakukan dalam context <em>unsafe</em> pada Rust.</li>
</ul>
<p>Semua tipe di dalam Rust bisa di-<em>borrowed</em> dengan cara menambah <em>ampersand</em>(&amp;) di awal tipe seperti <code>&amp;i32</code>. Ketika suatu tipe data di-<em>borrowed</em> tidak terjadi copy terhadap memory, akan tetapi <em>borrower</em> mereferensikan memory lokasi si data.</p>
<p>Borrow memiliki beberapa rules diantaranya:</p>
<ul>
<li>There can be <strong>more</strong> than one immutable borrow</li>
<li>There can be <strong>only</strong> one mutable borrow</li>
<li>Reference must always be valid</li>
</ul>
<p>Contoh immutable borrowing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn borrow() {
    let anu = &quot;anu&quot;;
    {
        println!(&quot;{}&quot;, anu); // move scope
    }

    println!(&quot;{}&quot;, anu); // still valid here
    accept_borrow(anu);
    println!(&quot;{}&quot;, anu); // still valid here
}

fn accept_borrow(s: &amp;str) { // this function borrow s as reference of string(&amp;str)
    println!(&quot;{}&quot;, s);
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh mutable borrowing:
Failed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mutable_borrow() {
    let mut a = 123;

    let b = &amp;mut a; // first mutable borrow
    let c = &amp;mut a; // second mutable borrow

    {
        let d = &amp;mut a; // third mutable borrow
    }

    println!(&quot;{}&quot;, b);
    println!(&quot;{}&quot;, c);
}
<span class="boring">}</span></code></pre></pre>
<p>Pencegahan multiple mutable reference ini bertujuan untuk menghindari kemungkinan <em>data race</em>. Data race adalah ketika suatu data di lokasi memori yang sama diakses oleh lebih dari 1 reference/pointer baik dalam 1 thread yang sama atau dalam thread yang berbeda. Dalam thread berbeda sangat jelas kemungkinan data race karena kita masing-masing thread tersebut bisa berjalan secara <em>concurrent</em> yang menyebabkan <em>undefined behaviour</em> pada data yang diaccess dengan minimal salah 1 nya adalah proses <em>write</em>/<em>modify</em> data. Selain itu pengaksessan mutable dalam 1 thread juga bisa bermasalah karena masing2 reference bisa memiliki waktu proses yang berbeda terhadap data yang diakses, sehingga tidak ada sinkronisasi data yang pasti sehingga menyebabkan <em>undefined behaviour</em>.</p>
<p><em>Immutable borrowing</em> digunakan ketika data yang di-passing tidak membutuhkan ownership dan berpindah ke berbagai thread.
<em>mutable borrowing</em> harus digunakan dengan mekanisme <em>mutex</em> untuk menjaga konsistensi data agar tidak terjadi <em>undefined behaviour</em>.</p>
<p>Borrowing dapat dengan mudah dilakukan ketika mem-<em>passing</em> data antar stack-frame fungsi2 yang <em>nested</em> ke dalam. Akan tetapi ketika ingin me-<em>return</em> data reference, hal ini tidak bisa dilakukan, apalagi pemilik asli data yang di-<em>borrowed</em> berada dalam stack-frame tersebut sehingga ketika data reference di-return, akan terjadi <em>use-after-free</em> atau semacam <em>dangling pointer</em> karena stack-frame sumber data reference tersebut sudah di-release dari stack memory. Bahasa-bahasa lain seperti Go menerapkan konsep <em>escape analysis</em> untuk menentukan lokasi data-data reference/pointer ketika keluar dari scope fungsi(stackframe). Dalam Go, ketika keluar dari stack-frame sedangkan data yang di-<em>pointed</em>/di-<em>referenced</em> ada di dalam stack frame tersebut, maka data tersebut dilarikan(<em>escape</em>) ke <em>heap memory</em> dan akan di-release oleh GC. Rust memiliki pendekatan lain untuk hal ini, yaitu dengan menggunakan <em>lifetime</em> yang akan kita bahas pada pembahasan selanjutnya.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basic/11_control_flow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basic/13_associated_items.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basic/11_control_flow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basic/13_associated_items.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
