<!DOCTYPE HTML>
<html lang="id" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error Handling - Rust Note</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust dalam Bahasa Indonesia">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../rust_id.html">Rust ID</a></li><li class="chapter-item expanded affix "><a href="../0_pengenalan.html">Pengenalan</a></li><li class="chapter-item expanded "><a href="../basic/0_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic/1_instalasi.html"><strong aria-hidden="true">1.1.</strong> Instalasi</a></li><li class="chapter-item expanded "><a href="../basic/2_toolchain.html"><strong aria-hidden="true">1.2.</strong> Toolchain</a></li><li class="chapter-item expanded "><a href="../basic/3_hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="../basic/4_struktur_codebase.html"><strong aria-hidden="true">1.4.</strong> Struktur Codebase</a></li><li class="chapter-item expanded "><a href="../basic/5_komponen_codebase.html"><strong aria-hidden="true">1.5.</strong> Komponen Codebase</a></li><li class="chapter-item expanded "><a href="../basic/6_primitive_types.html"><strong aria-hidden="true">1.6.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basic/7_string_types.html"><strong aria-hidden="true">1.7.</strong> String Types</a></li><li class="chapter-item expanded "><a href="../basic/8_compound_types.html"><strong aria-hidden="true">1.8.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="../basic/9_algebraic_types.html"><strong aria-hidden="true">1.9.</strong> Algebraic Types</a></li><li class="chapter-item expanded "><a href="../basic/10_collection_types.html"><strong aria-hidden="true">1.10.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="../basic/11_control_flow.html"><strong aria-hidden="true">1.11.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basic/12_ownership_and_borrowing.html"><strong aria-hidden="true">1.12.</strong> Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="../basic/13_associated_items.html"><strong aria-hidden="true">1.13.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="../basic/14_trait.html"><strong aria-hidden="true">1.14.</strong> Trait</a></li><li class="chapter-item expanded "><a href="../basic/15_generic.html"><strong aria-hidden="true">1.15.</strong> Generic</a></li><li class="chapter-item expanded "><a href="../basic/16_generic_bound_with_trait.html"><strong aria-hidden="true">1.16.</strong> Generic Bound with Trait</a></li><li class="chapter-item expanded "><a href="../basic/17_lifetime.html"><strong aria-hidden="true">1.17.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="../basic/18_error_handling.html" class="active"><strong aria-hidden="true">1.18.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../basic/19_unit_test.html"><strong aria-hidden="true">1.19.</strong> Unit Test</a></li><li class="chapter-item expanded "><a href="../basic/20_cargo_dan_konfigurasi.html"><strong aria-hidden="true">1.20.</strong> Cargo dan Konfigurasi</a></li></ol></li><li class="chapter-item expanded "><a href="../intermediate/0_intermediate.html"><strong aria-hidden="true">2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/1_functional_programming.html"><strong aria-hidden="true">2.1.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../intermediate/2_fp_rust.html"><strong aria-hidden="true">2.2.</strong> Functional Programming pada Rust</a></li><li class="chapter-item expanded "><a href="../intermediate/3_iterator.html"><strong aria-hidden="true">2.3.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="../intermediate/4_zero-cost_abstraction.html"><strong aria-hidden="true">2.4.</strong> Zero-cost Abstraction</a></li><li class="chapter-item expanded "><a href="../intermediate/5_smart_pointers.html"><strong aria-hidden="true">2.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="../intermediate/6_OOP.html"><strong aria-hidden="true">2.6.</strong> OOP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Note</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Error terjadi di dalam <em>fallible operations</em>, yaitu operasi-operasi yang memungkinkan terjadi efek samping diluar dugaan dan terjadi pada saat runtime. Hal-hal ini biasanya seperti <em>IO operations</em>, index access beyond size, etc. Di dalam Rust terdapat dua jenis eror yaitu: <em>Recoverable Error</em> and <em>Unrecoverable Error</em>.</p>
<ul>
<li><em>Recoverable Error</em> merupakan error karena kesalahan logic atau efek samping dari operasi IO. Error jenis ini dihandle menggunakan tipe data <code>Result&lt;T,E&gt;</code> yang merupakan tipe dasar sebuah enum yang menghasilkan salah satu dari dua kemungkinan yaitu <code>T</code> untuk berhasil, dan <code>E</code> untuk error. Setiap fungsi/method yang memiliki return type <code>Result</code> memiliki efek samping/kemungkinan error, sehingga ada penanganan khusus untuk dua kemungkinan return value.</li>
<li><em>Unrecoverable Error</em> merupakan error karena kesalahan teknis ketika program berjalan, seperti mengakses array diluar size. Error jenis ini akan menghasilkan kondisi disebut panic yang menyebabkan program exit.</li>
</ul>
<h2 id="recoverable-error"><a class="header" href="#recoverable-error">Recoverable Error</a></h2>
<p>Merupakan error yang disebabkan oleh efek samping dari program yang biasanya terjadi karena operasi-operasi yang bersifat <em>fallible</em> seperti IO atau interaksi dengan users. Error ini tentunya tidak mungkin menyebabkan program <em>down</em> karena kita tidak bisa sepenuhnya mengendalikan efek samping itu. Tipe data dasar yang disediakan Rust untuk meng-<em>handle</em> error jenis ini adalah enum <code>Result&lt;T,E&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result {
    Ok(T),  // T adalah tipe data jika proses berhasil dan mengembalikan nilai dengan tipe T
    Err(E), // E adalah tipe data jika proses gagal dan mengembalikan error dengan tipe E
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result</code> Merupakan tipe varian yang memiliki dua kemungkinan yaitu berhasil(<code>Ok(T)</code>) atau error(<code>Err(e)</code>). Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fallible_function() -&gt; Result&lt;i32, String&gt; {
    // some process
    // Err(String::from(&quot;got error&quot;)) // jika gagal
    Ok(1) // jika berhasil
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-recoverable-error"><a class="header" href="#handling-recoverable-error">Handling Recoverable Error</a></h3>
<p>Ketika ingin memanggil fungsi/method yang memiliki kemungkinan error, tentunya kita ingin meng-handle error tersebut. Terdapat beberapa cara menghandle error di dalam Rust diantaranya:</p>
<h4 id="pattern-matching-menggunakan-match"><a class="header" href="#pattern-matching-menggunakan-match"><strong>Pattern matching Menggunakan <code>match</code></strong></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ret = fallible_function();
match ret {
    Ok(t) =&gt; println!(&quot;val: {}&quot;, t),
    Err(e) =&gt; panic!(&quot;{}&quot;, e),
}
<span class="boring">}</span></code></pre></pre>
<p>Pattern matching melakukan destrukturalisasi terhadap tipe data yang di-<em>match</em> sehingga kita bisa membaca value-value hasil destruktur dengan menulis signature tipe tersebut. Contoh di atas <code>fallible_function()</code> mengembalikan tipe <code>Result&lt;i32, String&gt;</code> sehingga berdasarkan definisi tipe enum Result menjadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Result&lt;i32, String&gt; = Ok(i32) | Err(String)
<span class="boring">}</span></code></pre></pre>
<p>Return value merupakan nilai antara i32 jika berhasil, atau String jika gagal/error.
Ketika ingin membaca value dari pattern matching, terdapat beberapa cara membaca:</p>
<ul>
<li><strong>Signature dengan variable</strong>
Ketika ingin membaca value dari <code>T</code> tanpa meng-enumerasi semua kemungkinan value tersebut, cukup dengan mendeklarasikan suatu variable arbitrary seperti:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match ret {
  // variable `t` bisa diganti menjadi apapun
  Ok(t) =&gt; println!(&quot;val: {}&quot;, t),
  // variable `e` bisa diganti menjadi apapun
  Err(e) =&gt; panic!(&quot;{}&quot;, e),
}
<span class="boring">}</span></code></pre></pre>
Tipe data dari variable tersebut sesuai dengan tipe data dari deklarasi <code>Result&lt;i32, String&gt;</code>.</li>
<li><strong>Signature dengan value</strong>
Ketika ingin memeriksa langsung kepada value yang diinginkan, bisa langsung menulis value yang diinginkan seperti:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match fallible_function() {
  // kita ingin memastikan bahwa kriteria berhasil hanya jika value dari T adalah 5
  Ok(5) =&gt; println!(&quot;berhasil&quot;),
  // kita menggunakan wildcard jika kita tidak 
  _ =&gt; panic!(&quot;panic&quot;),
}
<span class="boring">}</span></code></pre></pre>
Seperti yang sudah dibahas pada chapter algebraic types bahwa <code>match</code> bersifat <em>exhaustive</em> sehingga kita bisa menggunakan wildcard <code>_</code> untuk mengabaikan semua enumerasi value selain dari yang kita inginkan.</li>
</ul>
<h3 id="pattern-matching-menggunakan-macro-matches"><a class="header" href="#pattern-matching-menggunakan-macro-matches">Pattern Matching menggunakan macro <code>matches!</code></a></h3>
<p><code>matches!</code> merupakan macro yang melakukan pengecekkan match langsung terhadap ekspresi yang dimasukkan dengan pattern yang dicocokkan. Dengan ini tidak harus meng-enumerasi semua kemungkinan value, kita hanya ingin memeriksa value/pattern suatu variable/ekspresi. Macro ini mengembalikan boolean <code>true</code> jika sesuai.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = 123;
let ret = matches!(num, 4);
println!(&quot;{}&quot;, ret);

let option = Some(5);
let ret = matches!(option, Some(5));
println!(&quot;{}&quot;, ret);
<span class="boring">}</span></code></pre></pre>
<h4 id="associated-methods"><a class="header" href="#associated-methods">Associated Methods</a></h4>
<p>Tipe Result&lt;T,E&gt; memiliki beberapa methods untuk meng-<em>handle</em> tipe error recoverable diantaranya <code>unwrap</code>.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fallible_function&lt;'a&gt;() -&gt; Result&lt;i32, &amp;'a str&gt; {
    Err(&quot;error ninu ninu&quot;) // jika gagal
}

let resp = fallible_function();

/// unwrap akan mengembalikan nilai jika `Result` berhasil(Ok(T))
/// akan panic jika hasil tidak `Ok(T)`
/// *NOTE: hindari penggunaan `unwrap()` karena kita tidak pernah tau hasil dari fallible operation tersebut. Kecuali jika kita yakin 100% bahwa hasil Ok(T).
let ret = resp.unwrap();

/// unwrap_err akan mengembalikan error jika `Result` error(Err(E))
/// akan panic jika hasil tidak `Err(E)`
/// *NOTE: hindari penggunaan `unwrap_err()` karena kita tidak pernah tau hasil dari fallible operation tersebut. Kecuali jika kita yakin 100% bahwa hasil Err(E).
let ret = resp.unwrap_err();

/// unwrap_or mengembalikan nilai jika Ok(T), 
/// jika tidak, maka akan mengembalikan nilai alternatif `123` sesuai dengan tipe data T.
/// Gunakan jika kita memiliki alternatif value selain dari yang diharapkan.
let ret = resp.unwrap_or(123);

/// unwrap_or_default mengembalikan nilai jika Ok(T), 
/// jika tidak, akan mengembalikan default value sesuai dengan tipe data T(e.g. i32 -&gt; 0).
let ret = resp.unwrap_or_default();

/// unwrap_or_else akan mengembalikan nilai jika `Result` berhasil(Ok(T))
/// jika tidak, akan menjalankan suatu closure `FnOnce(E) -&gt; T` dimana `E` adalah value dengan tipe yang sama dengan error `E` dari `Result&lt;T,E&gt;` dan `T` adalah value dengan tipe yang sama dengan hasil `T` dari `Result&lt;T,E&gt;` yang merupakan alternatif dari return value ketika yang sebelumnya error.
/// Gunakan ini ketika kita memiliki alternatif lain dari T dalam Result&lt;T,E&gt; dengan menjalankan suatu fungsi.
let ret = resp.unwrap_or_else(|x| -&gt; i32 {
    println!(&quot;--:: {}&quot;, x);
    123
});
<span class="boring">}</span></code></pre></pre>
<p>Masih banyak associated methods lainnya yang harus dieksplor sendiri yang memiliki tujuan masing-masing.</p>
<h3 id="propagating-recoverable-error"><a class="header" href="#propagating-recoverable-error">Propagating Recoverable Error</a></h3>
<p>Ketika kita ingin mengembalikan error ke fungsi <code>caller</code> dan seterusnya atau membuat rantai return error, maka kita bisa menggunakan operator <code>?</code> atau disebut juga operator <code>try</code>. Hal ini dilakukan ketika kita ingin menyerahkan error handling kepada fungsi yang memanggil. Syarat untuk try operator adalah memiliki tipe yang sama antara <em>caller</em> dan <em>callee</em>. 
<em>Try</em> operator berlaku untuk untuk tipe <code>Result&lt;T,E&gt;</code> dan <code>Option&lt;T&gt;</code>. 
Pada pembahasan error handling ini, kita menggunakan try operator untuk tipe <code>Result&lt;T,E&gt;</code>. Try operator pada <code>Result&lt;T,E&gt;</code> akan meng-<em>unwrap</em> <code>T</code> jika Ok, atau <em>return</em> fungsi jika error dimana tipe <code>Err(E)</code> antara <em>caller</em> dan <em>callee</em> compatible.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function1() -&gt; Result&lt;String, String&gt; {
    let resp_funciton2 = function2()?; // if function2() return error, then this function will return the error from function2() into function1() error
    // do something with `resp`
    Ok(String::from(&quot;yay&quot;))
}

fn function2&lt;'a&gt;() -&gt; Result&lt;i32, &amp;'a str&gt; {
    Err(&quot;error in function 2&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas, tipe data error dari fungsi2/method2 yang mem-propagasi error harus memiliki tipe yang sama. Pada contoh di atas terlihat kalau tipe data tidak sama, akan tetapi contoh di atas berjalan dengan benar. Hal ini karena selain tipe yang sama, tipe berbeda bisa dengan syarat masing-masing tipe meng-implementasi trait conversion pada Rust yaitu <code>From&lt;T&gt;</code>. Dengan implementasi trait konversi ini, tipe error tetap bisa di propagasi tanpa error. Hal ini karena tipe <code>String</code> implement method <code>from</code> dari trait <code>From&lt;T&gt;</code> sehingga bisa membaca error dari function2() berupa <code>&amp;str</code>.</p>
<h2 id="unrecoverable-error"><a class="header" href="#unrecoverable-error">Unrecoverable Error</a></h2>
<p>Merupakan error yang tidak dapat ditolerir lagi karena bisa menyebabkan <em>undefined behaviour</em> pada program yang mana sebagian besar disebabkan oleh <em>logic error</em> dan juga beberapa side-effects. 
Pada saat panic terjadi, rust akan menghapus stack program atau yang disebut dengan <code>unwinding</code>.
Contoh dari error ini diantaranya: </p>
<h3 id="index-out-of-bound-access"><a class="header" href="#index-out-of-bound-access">index out of bound access</a></h3>
<p>Di antara hal yang lumrah pada bahasa pemograman manapun. Yang membedakan adalah bahasa dengan <em>safety measure</em> akan langsung memberikan error ketika ada access diluar bound array. Bahasa lain seperti C mungkin akan memberikan <em>undefined behaviour</em> dengan memberikan nilai tidak valid bagi program. Rust memiliki bound checking pada saat pengaksesan array sehingga mengembalikan error ketika akses melebihi ukuran array.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

v[99];
<span class="boring">}</span></code></pre></pre>
<h3 id="memanggil-macro-panic"><a class="header" href="#memanggil-macro-panic">memanggil macro <code>panic!()</code></a></h3>
<p>Macro <code>panic!()</code> adalah macro untuk menyebabkan panic secara intentional ketika situasi tidak memungkinkan untuk meng-<em>recover</em> error yang terjadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_fail() {
  panic!(&quot;im done&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memanggil-associated-methods-yang-tidak-sesuai-dengan-value-yang-diharapkaneg-expect-atau-unwrap"><a class="header" href="#memanggil-associated-methods-yang-tidak-sesuai-dengan-value-yang-diharapkaneg-expect-atau-unwrap">memanggil associated methods yang tidak sesuai dengan value yang diharapkan(e.g. <code>expect</code> atau <code>unwrap</code>)</a></h3>
<p>Kali ini kita akan membahas <code>expect</code> dimana kita ingin menambahkan pesan tambahan pada panic ketika terjadi error dari hasil <code>Result&lt;T,E&gt;</code> dan kita ingin panic. Method <code>expect</code> ini biasa digunakan untuk inisiasi program dengan berbagai pra-kondisi yang harus dipenuhi sebelum program berjalan seperti dependensi dan lainnya. Jika hal-hal itu tidak terpenuhi maka tentunya program tidak bisa berjalan dan harus exit dengan panic. <code>expect</code> digunakan ketika kita ingin menambahkan informasi tambahan terkait operasi yang kita lakukan yang tidak diketahui oleh compiler.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let db_conn = init_db().expect(&quot;FAILED CONNECTING TO DB&quot;); // will return value of `DB` from function, or panic error with additional information
}

fn init_db() -&gt; Result&lt;DB, String&gt; {
  // logic for initiating DB connection
}</code></pre></pre>
<h3 id="testing-assertions"><a class="header" href="#testing-assertions">testing assertions</a></h3>
<p>Default behaviour dari fungsi-fungsi macro untuk test assertions ketika tidak sesuai ekspektasi adalah panic.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_addition() {
    let result = 2 + 2;
    assert_eq!(result, 5); // will cause fail tests and panic
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika kita ingin melakukan recovery terhadap situasi panic, maka kita dapat menggunakan fungsi <code>std::panic::catch_unwind</code> yang menerima closure yang mungkin terjadi panic.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::panic::catch_unwind(|| {
    panic!(&quot;im panic&quot;);
});
assert!(result.is_err()); // result akan mengembalikan error karena kondisi unwind terjadi di dalam closure karena fungsi `panic!()` dipanggil.
<span class="boring">}</span></code></pre></pre>
<p>Pada development Rust, fungsi <code>catch_unwind</code> ini sangat jarang digunakan karena error yang disebabkan oleh panic memang error yang tidak bisa ditolerir yang bisa menyebabkan <em>undefined behaviour</em> pada program, ada side effects lainnya. Hal lain juga penyebab error panic ini jauh lebih kecil dibandingkan error yang disebabkan oleh IO atau side-effects lainnya, sehingga programmer sebaiknya mengantisipasi error ini pada saat development ditambah dengan testing.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../basic/17_lifetime.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../basic/19_unit_test.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../basic/17_lifetime.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../basic/19_unit_test.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
