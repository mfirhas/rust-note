<!DOCTYPE HTML>
<html lang="id" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OOP - Rust Note</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust dalam Bahasa Indonesia">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../rust_id.html">Rust ID</a></li><li class="chapter-item expanded affix "><a href="../0_pengenalan.html">Pengenalan</a></li><li class="chapter-item expanded "><a href="../basic/0_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basic/1_instalasi.html"><strong aria-hidden="true">1.1.</strong> Instalasi</a></li><li class="chapter-item expanded "><a href="../basic/2_toolchain.html"><strong aria-hidden="true">1.2.</strong> Toolchain</a></li><li class="chapter-item expanded "><a href="../basic/3_hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="../basic/4_struktur_codebase.html"><strong aria-hidden="true">1.4.</strong> Struktur Codebase</a></li><li class="chapter-item expanded "><a href="../basic/5_komponen_codebase.html"><strong aria-hidden="true">1.5.</strong> Komponen Codebase</a></li><li class="chapter-item expanded "><a href="../basic/6_primitive_types.html"><strong aria-hidden="true">1.6.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../basic/7_string_types.html"><strong aria-hidden="true">1.7.</strong> String Types</a></li><li class="chapter-item expanded "><a href="../basic/8_compound_types.html"><strong aria-hidden="true">1.8.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="../basic/9_algebraic_types.html"><strong aria-hidden="true">1.9.</strong> Algebraic Types</a></li><li class="chapter-item expanded "><a href="../basic/10_collection_types.html"><strong aria-hidden="true">1.10.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="../basic/11_control_flow.html"><strong aria-hidden="true">1.11.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../basic/12_ownership_and_borrowing.html"><strong aria-hidden="true">1.12.</strong> Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="../basic/13_associated_items.html"><strong aria-hidden="true">1.13.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="../basic/14_trait.html"><strong aria-hidden="true">1.14.</strong> Trait</a></li><li class="chapter-item expanded "><a href="../basic/15_generic.html"><strong aria-hidden="true">1.15.</strong> Generic</a></li><li class="chapter-item expanded "><a href="../basic/16_generic_bound_with_trait.html"><strong aria-hidden="true">1.16.</strong> Generic Bound with Trait</a></li><li class="chapter-item expanded "><a href="../basic/17_lifetime.html"><strong aria-hidden="true">1.17.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="../basic/18_error_handling.html"><strong aria-hidden="true">1.18.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="../basic/19_unit_test.html"><strong aria-hidden="true">1.19.</strong> Unit Test</a></li><li class="chapter-item expanded "><a href="../basic/20_cargo_dan_konfigurasi.html"><strong aria-hidden="true">1.20.</strong> Cargo dan Konfigurasi</a></li></ol></li><li class="chapter-item expanded "><a href="../intermediate/0_intermediate.html"><strong aria-hidden="true">2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intermediate/1_functional_programming.html"><strong aria-hidden="true">2.1.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../intermediate/2_fp_rust.html"><strong aria-hidden="true">2.2.</strong> Functional Programming pada Rust</a></li><li class="chapter-item expanded "><a href="../intermediate/3_iterator.html"><strong aria-hidden="true">2.3.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="../intermediate/4_zero-cost_abstraction.html"><strong aria-hidden="true">2.4.</strong> Zero-cost Abstraction</a></li><li class="chapter-item expanded "><a href="../intermediate/5_smart_pointers.html"><strong aria-hidden="true">2.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="../intermediate/6_OOP.html" class="active"><strong aria-hidden="true">2.6.</strong> OOP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Note</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="object-oriented-programming-in-rust"><a class="header" href="#object-oriented-programming-in-rust">Object Oriented Programming in Rust</a></h1>
<p>OOP memiliki banyak definisi seiring waktu. Bermula dari Simula yang mengenalkan konsep object, program disusun sedemikian rupa dari sekumpulan object-object yang dibangung dari class, attributes, dan virtual procedures(methods). Selanjutnya oleh Smalltalk menambahkan konsep message passing, dimana object akan menerima suatu <em>message</em> melalui method-method nya, dan menyesuaikan state berdasarkan itu. Java datang dengan konsep yang mirip-mirip dan dijadikan acuan dalam OOP yaitu memiliki:</p>
<ul>
<li>Encapsulation: Information hiding terhadap detail implementasi dengan hanya memberi akses API lewat public API.</li>
<li>Inheritance: Ekstensi object memberikan relasi &quot;is a&quot;.</li>
<li>Polymorphism: Deklarasi common behaviour antar multiple objects. Diimplementasikan dengan menggunakan Vtable, dynamically checked.</li>
</ul>
<h2 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h2>
<p>Secara gamblang, encapsulation merupakan cara meng-abstraksi API sehingga user tidak perlu melihat daleman API dan hanya berinteraksi melalui exposed interface. Di sebagian bahasa OOP hal ini dilakukan menggunakan access modifier seperti <em>public</em> dan <em>private</em>. Hal ini untuk mencapai <em>loosely coupling</em> pada design API sehingga implementor bisa fokus terhadap implementasi, dan client/user dari API bisa tetap menggunakan API yang sama tanpa peduli detail implementasi.</p>
<p>Pada Rust, ada beberapa cara untuk mencapai ini, diantaranya:</p>
<ul>
<li>Access modifier <code>pub</code>, semua komponen bersifat private, dengan <code>pub</code> membuatnya bisa di-akses oleh caller.</li>
<li>Menggunakan crate library <code>lib.rs</code> untuk mengekpose api-api yang bisa digunakan oleh client.</li>
<li>Menggunakan module untuk meng-segmentasi kode sedemikian rupa sehingga pengelompokkan API lebih terorganisir dan koheren.</li>
<li>Menggunakan inherent methods dengan beberapa public methods, dan private methods.</li>
<li>Menggunakan traits dengan shared custom types, methods, dan default types. Traits juga digunakan sebagai bound untuk type parameter API.</li>
<li>Menggunakan procedure macro untuk meng-abstraksi berbagai komputasi. Contoh yang sering kita lihat: <code>print!()</code>, <code>println!()</code>, <code>dbg!()</code>, <code>assert!()</code>, etc.</li>
</ul>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>Rust tidak memiliki inherintance layaknya kebanyakan bahasa OOP lainnya. Akan tetapi Rust menerapkan komposisi yaitu dengan meng-<em>embed</em> tipe data/struct/enum ke dalam fields. Inheritance sendiri memiliki masalah dalam dunia OOP karena cenderung menambah kompleksitas yang tidak diperlukan. Juga mempersulit <em>maintainance</em> dari suatu kode karena sedikit perubahan akan mengacaukan semua childs yang inherit suatu class, cenderung menjadi <em>spaghetti</em>. Selain itu juga bisa menimbulkan masalah yang disebut <em>diamond problem</em>. Inheritance bukan pilihan utama ketika membuat kode yang loosely coupled dan juga enkapsulasi lebih cenderung menggunakan interface(<em>composition</em>) ketimbang class inheritance. Rust memiliki relasi antar type yang disebut dengan <em>Subtyping</em>.</p>
<h2 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h2>
<p>Pada bahasa OOP umumnya polymorphism dilakukan menggunakan <em>interface</em>. Interface merupakan salah satu jenis inheritance yang bersifat <em>has-a</em> untuk mencapai composition.</p>
<p>Rust mengimplementasikan konsep polymorfisme melalui dua cara yaitu: <em>generic</em> dan <em>trait object</em>. Kita telah membahas generic pada pembahasan sebelumnya yaitu bersifat statis dan diperiksa pada saat compile-time. Akan tetapi pendekatan generics ini memiliki kekurangan yaitu hanya memiliki satu instance dalam satu waktu. Selain itu tipe data yang akan digunakan pada generic/type parameter harus diketahui size nya pada saat compile-time. Berangkat dari kekurangan inilah kita membutuhkan polymorfisme yang bersifat lebih dinamis dan semua tipe bisa di-inject pada saat runtime, sehingga tidak perlu di-specify semua pada saat run-time, cara ini disebut <em>trait object</em>.</p>
<p>Perbedaan generics dan trait object:</p>
<ul>
<li>Generic resolve at <em>compile-time</em>, while trait object resolve at <em>run-time</em>.</li>
<li>Hanya ada 1 instance tipe data pada tipe yang memiliki generic parameter, sedangkan trait object bisa memiliki menampung berbagai tipe selama tipe tersebut mengimplementasi deklarasi trait object tersebut.</li>
<li>Generic tidak memiliki runtime cost karena statically dispatched, sedangkan trait object memiliki runtime cost karena dynamically dispatched(seperti penggunaan vtable yang menampung semua pointer ke fungsi/methods yang digunakan).</li>
</ul>
<h1 id="oop-implementations-in-rust"><a class="header" href="#oop-implementations-in-rust">OOP Implementations in Rust</a></h1>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<p>States adalah data yang berubah-ubah sepanjang program berjalan. Data ini biasanya disebut attributes di dalam bahasa OO yang mana states transitions nya dikendalikan oleh method-method dari object tersebut. Rust secara default bersifat <em>immutable</em>, karena kecenderungan functional programming. Akan tetapi kita bisa membuat sifat statefulness dari Rust ini dengan menggunakan keyword <code>&amp;mut self</code> pada deklarasi method. States merupakan efek dari behaviour object terhadap data yang dikandung object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Object {
    field1: String,
    field2: i32,
    field3: u64,
}

impl Object {
    pub fn new(field1: String, field2: i32, field3: u64) -&gt; Self {
        Object {
            field1,
            field2,
            field3,
        }
    }

    pub fn method1(&amp;mut self) {
        self.field1.push_str(&quot;new str&quot;);
    }

    pub fn method2(&amp;mut self) {
        self.field2 += 1;
    }

    pub fn method3(&amp;mut self) {
        self.field3 += 340;
    }

    pub fn print(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="encapsulation-1"><a class="header" href="#encapsulation-1">Encapsulation</a></h2>
<p>Encapsulation bisa memanfaatkan access modifier <code>pub</code> untuk public access, dan memanfaatkan komponen-komponen yang accessible lewat path <code>::</code> dan method.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// encapsulation
#[derive(Debug)]
struct A {
    field1: String,
    field2: i32,
}

impl A {
    fn new() -&gt; Self {
        A {
            field1: String::from(&quot;this A&quot;),
            field2: 123,
        }
    }
    fn method_a(&amp;self, n: u64) {
        println!(&quot;A: {n}&quot;)
    }
}

// kita meng-enkapsulasi A ke dalam B, sehingga A tidak perlu di-ekpose ke user.
#[derive(Debug)]
pub struct B {
    a: A,
    field3: u64,
}

impl B {
    pub fn new() -&gt; Self {
        B {
            a: A::new(),
            field3: 234,
        }
    }
    pub fn method_b(&amp;self) {
        println!(&quot;printing B&quot;);
        self.a.method_a(self.field3);
    }

    // data A di-enkapsulasi ke dalam B, sehingga bisa di akses tanpa akses ke A.
    pub fn method_b_2(&amp;self) -&gt; (&amp;str, i32) {
        (self.a.field1.as_str(), self.a.field2)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="polymorphism-menggunakan-trait-objectdyn-trait"><a class="header" href="#polymorphism-menggunakan-trait-objectdyn-trait">Polymorphism menggunakan trait object(<code>dyn Trait</code>)</a></h2>
<p>Polymorphism pada bahasa OOP umumnya merupakan dynamic polymorphism yang menggunakan <code>interface</code> untuk memasukkan object yang share common behaviours.
Rust menggunakan keyword <code>dyn</code> pada trait, untuk menandakan bahwa trait tersebut bisa menampung banyak tipe.</p>
<p>Apa yang membedakan generics dan trait object?</p>
<ul>
<li>generics di-resolve pada saat compile time, trait object di-resolve pada saat run-time.</li>
<li>generics hanya bisa memiliki 1 jenis tipe data pada satu waktu(saat definisi tipe), sedangkan trait object bisa memiliki banyak jenis tipe data pada satu waktu(saat definisi tipe).</li>
<li>generics bersifat zero cost, sedangkan trait object memiliki cost run-time vtable checking.</li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

// hanya bisa deklarasi i32 pada saat definisi tipe Vec&lt;T&gt; -&gt; Vec&lt;i32&gt;
let v = vec![1,2,3,4]; 

// hanya bisa deklarasi String pada saat definisi tipe Vec&lt;T&gt; -&gt; Vec&lt;String&gt;
let v: Vec&lt;String&gt; = vec![&quot;test&quot;.to_string(), &quot;test2&quot;.to_string()]; 


/// contoh penggunaan trait object untuk menampung berbagai tipe data pada saat definisi tipe.
pub trait Field: Debug {}
#[derive(Debug)]
pub struct Custom;

impl Field for i32 {}
impl Field for String {}
impl Field for &amp;str {}
impl Field for Custom {}

let mut v: Vec&lt;Box&lt;dyn Field&gt;&gt; = Vec::new();
v.push(Box::new(123));
v.push(Box::new(&quot;anu&quot;));
v.push(Box::new(String::from(&quot;nmnm&quot;)));
v.push(Box::new(Custom));

println!(&quot;{v:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Kita bisa meng-elaborasi polymorphism di atas menjadi komposisi yang terdiri dari berbagai tipe object, object disini merupakan trait object.</p>
<p>Contoh: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

/// composition
///
///

// IDep merepresentasikan &quot;interface&quot; ke depedensi yang akan di-inject
pub trait IDep: Debug {}
pub trait Field: Debug {}
#[derive(Debug)]
pub struct Custom;

impl Field for i32 {}
impl Field for String {}
impl Field for &amp;str {}
impl Field for Custom {}

#[derive(Debug)]
pub struct Struct {
    field1: Box&lt;dyn IDep&gt;,
    field2: Vec&lt;Box&lt;dyn Field&gt;&gt;,
}

// Dep adalah object dependensi itu sendiri
#[derive(Debug)]
pub struct Dep;
impl IDep for Dep {}

impl Struct {
    pub fn new() -&gt; Self {
        let mut v: Vec&lt;Box&lt;dyn Field&gt;&gt; = Vec::new();
        v.push(Box::new(123));
        v.push(Box::new(&quot;anu&quot;));
        v.push(Box::new(String::from(&quot;nmnm&quot;)));
        v.push(Box::new(Custom));
        Self {
            field1: Box::new(Dep),
            field2: v,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust memiliki pendekatan OOP yang berbeda dengan kebanyakan bahasa OOP, dimana tidak ada inheritance, dan kebanyakan variable adalah value, bukan object seperti di bahasa OOP. Beberapa pattern juga akan sangat berbeda jika diterapkan OOP dengan Rust. Trait object juga bisa di-inject ke dalam smart pointer jenis lain, sesuai kebutuhan. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../intermediate/5_smart_pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../intermediate/5_smart_pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
