<!DOCTYPE HTML>
<html lang="id" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Note</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Rust dalam Bahasa Indonesia">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="rust_id.html">Rust ID</a></li><li class="chapter-item expanded affix "><a href="0_pengenalan.html">Pengenalan</a></li><li class="chapter-item expanded "><a href="basic/0_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/1_instalasi.html"><strong aria-hidden="true">1.1.</strong> Instalasi</a></li><li class="chapter-item expanded "><a href="basic/2_toolchain.html"><strong aria-hidden="true">1.2.</strong> Toolchain</a></li><li class="chapter-item expanded "><a href="basic/3_hello_world.html"><strong aria-hidden="true">1.3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="basic/4_struktur_codebase.html"><strong aria-hidden="true">1.4.</strong> Struktur Codebase</a></li><li class="chapter-item expanded "><a href="basic/5_komponen_codebase.html"><strong aria-hidden="true">1.5.</strong> Komponen Codebase</a></li><li class="chapter-item expanded "><a href="basic/6_primitive_types.html"><strong aria-hidden="true">1.6.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="basic/7_string_types.html"><strong aria-hidden="true">1.7.</strong> String Types</a></li><li class="chapter-item expanded "><a href="basic/8_compound_types.html"><strong aria-hidden="true">1.8.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="basic/9_algebraic_types.html"><strong aria-hidden="true">1.9.</strong> Algebraic Types</a></li><li class="chapter-item expanded "><a href="basic/10_collection_types.html"><strong aria-hidden="true">1.10.</strong> Collection Types</a></li><li class="chapter-item expanded "><a href="basic/11_control_flow.html"><strong aria-hidden="true">1.11.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="basic/12_ownership_and_borrowing.html"><strong aria-hidden="true">1.12.</strong> Ownership and Borrowing</a></li><li class="chapter-item expanded "><a href="basic/13_associated_items.html"><strong aria-hidden="true">1.13.</strong> Associated Items</a></li><li class="chapter-item expanded "><a href="basic/14_trait.html"><strong aria-hidden="true">1.14.</strong> Trait</a></li><li class="chapter-item expanded "><a href="basic/15_generic.html"><strong aria-hidden="true">1.15.</strong> Generic</a></li><li class="chapter-item expanded "><a href="basic/16_generics_trait_bounds.html"><strong aria-hidden="true">1.16.</strong> Generics Trait Bounds</a></li><li class="chapter-item expanded "><a href="basic/17_lifetime.html"><strong aria-hidden="true">1.17.</strong> Lifetime</a></li><li class="chapter-item expanded "><a href="basic/18_error_handling.html"><strong aria-hidden="true">1.18.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="basic/19_unit_test.html"><strong aria-hidden="true">1.19.</strong> Unit Test</a></li><li class="chapter-item expanded "><a href="basic/20_cargo_dan_konfigurasi.html"><strong aria-hidden="true">1.20.</strong> Cargo dan Konfigurasi</a></li></ol></li><li class="chapter-item expanded "><a href="intermediate/0_intermediate.html"><strong aria-hidden="true">2.</strong> Intermediate</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intermediate/1_functional_programming.html"><strong aria-hidden="true">2.1.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="intermediate/2_fp_rust.html"><strong aria-hidden="true">2.2.</strong> Functional Programming pada Rust</a></li><li class="chapter-item expanded "><a href="intermediate/3_iterator.html"><strong aria-hidden="true">2.3.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="intermediate/4_zero-cost_abstraction.html"><strong aria-hidden="true">2.4.</strong> Zero-cost Abstraction</a></li><li class="chapter-item expanded "><a href="intermediate/5_smart_pointers.html"><strong aria-hidden="true">2.5.</strong> Smart Pointers</a></li><li class="chapter-item expanded "><a href="intermediate/6_OOP.html"><strong aria-hidden="true">2.6.</strong> OOP</a></li><li class="chapter-item expanded "><a href="intermediate/7_subtyping.html"><strong aria-hidden="true">2.7.</strong> Subtyping</a></li><li class="chapter-item expanded "><a href="intermediate/8_standard_traits.html"><strong aria-hidden="true">2.8.</strong> Standard Traits</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Note</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-id"><a class="header" href="#rust-id">Rust ID</a></h1>
<p>Merupakan catatan OP selama mempelajari Bahasa Pemograman Rust yang di tulis dalam Bahasa Indonesia. Sumber pembelajaran diantaranya:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/">Rust Book</a></li>
<li><a href="https://doc.rust-lang.org/reference/">Rust Reference</a></li>
<li><a href="https://doc.rust-lang.org/nomicon/">Rust Nomicon</a></li>
<li><a href="https://cheats.rs/">Rust Cheatsheet</a></li>
<li><a href="https://doc.rust-lang.org/stable/cargo/reference/">Cargo Reference</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example">Cargo Examples</a></li>
<li>dan lainnya yang mungkin akan ditambahkan kedepannya...</li>
</ul>
<p>Rust Version: <strong>1.66.0 stable</strong>++</p>
<p>Repo: <a href="https://github.com/mfathirirhas/rust-note">rust-note</a></p>
<p><em>Silahkan membuka issue dan PR untuk berkontribusi atau ingin mengoreksi kesalahan, atau bisa juga dengan mengirim email ke <a href="mailto:mfathirirhas@gmail.com">mfathirirhas@gmail.com</a>. Thanks!</em></p>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pengenalan"><a class="header" href="#pengenalan">Pengenalan</a></h1>
<p>Rust adalah bahasa pemograman yang di-<em>release</em> ke publik tahun 2010 berawal dari projek riset Mozilla dan didesain oleh Graydon Hoare. Bahasa ini memiliki <em>static</em> dan <em>strong type</em>. Rust merupakan bahasa yang meng-<em>enforce</em> <em>type safety</em> dan <em>memory safety</em>. Kedua hal ini berhubungan erat satu sama lain yang akan meng-<em>handle</em> hal-hal yang biasa terjadi di bahasa lain, di antaranya:</p>
<ul>
<li><em>Dangling pointer</em>, adalah ketika suatu <em>pointer</em> tidak menunjuk ke value yang valid di memory. Biasanya ini terjadi ketika <em>free</em> memory tidak dilakukan di tempat atau waktu yang tepat.</li>
<li><em>Double-free</em>, melakukan <em>free</em> memory lebih dari 2 kali untuk lokasi memory yang sama. Ini biasa terjadi pada bahasa yang mana manajemen memori nya manual, seperti C/C++.</li>
<li><em>null pointer</em>, terjadi ketika mengakses pointer yang kosong.</li>
<li><em>data-race</em>, terjadi ketika data diakses oleh lebih dari satu <em>thread</em> secara konkuren. Hal ini bisa menjadikan data tidak konsisten khususnya ketika ada proses write dan read terhadap data tersebut.</li>
<li><em>memory-leaks</em>, terjadi ketika banyak resources yang sudah tidak diperlukan akan tetapi masih mendiami memory sehingga memakan resource yang diperlukan oleh proses lain.</li>
</ul>
<p>(<em>NOTE: dangling pointer masih mungkin terjadi untuk beberapa skenario seperti cyclic reference menggunakan smart pointer seperti Rc atau Arc, hal ini bisa diatasi dengan menggunakan weak reference</em>)</p>
<ul>
<li>dan lainnya.</li>
</ul>
<p>Rust merupakan bahasa <em>compiled</em> ke <em>binary</em> sehingga berjalan secara <em>native</em> di OS target. Compiler Rust bernama <code>rustc</code> yang secara simple terdiri dari <em>frontend</em> yang menghasilkan IR(<em>Intermediate Representation</em>) dan <em>backend</em> menggunakan LLVM yang menghasilkan hasil akhir berupa binary.</p>
<p>Rust memiliki konsep baru di dunia pemograman yaitu: <em>Ownership</em> dan <em>Borrowing</em>. 
<em>Ownership</em> adalah dimana setiap value di dalam rust memiliki 1 owner dalam 1 waktu dan tempat. <em>Ownership</em> berpindah ketika value tersebut keluar dari tempatnya/<em>scope</em>-nya. Scope disini bisa berbagai macam bentuk, mulai dari codeblock dengan <code>{}</code>, fungsi, lambda, dan assignments. <em>Borrowing</em> adalah ketika kita ingin meng-<em>passing</em> value tanpa memindahkan <em>ownership</em>, yaitu dengan memberikan <em>reference</em> kepada value yang kita <em>passing</em>. Kedua feature inilah yang banyak meng-<em>handle</em> <em>memory safety</em> yang sering terjadi di atas.</p>
<p>Hal unik lainnya adalah cara Rust manajemen memori. Rust tidak memiliki manual memori manajemen seperti C dan C++ serta tidak juga memiliki <em>Garbage Collector</em>. Rust mengatasi ini dengan memanfaatkan 2 konsep di atas untuk meng-<em>inject</em> pelepasan <em>resource</em> memori di dalam code pada saat compile time. Ketika resource yang di-<em>owned</em> keluar dari scope terjadi 2 kemungkinan: 1. Berpindah kepemilikan, atau 2. Di-<em>release</em> dari memori ketika tidak ada yang me-<em>reference</em> dirinya. Dengan begini penggunaan <em>resource</em> memori sangat efisien dan ringan tanpa <em>runtime overhead</em> seperti GC.</p>
<p>Kelebihan Rust:</p>
<ul>
<li>Type safety, Memory safety, dan Thread safety</li>
<li>Performansi menyerupai C dan C++</li>
<li>Memiliki automatic memory management tanpa GC</li>
<li>Friendly compiler error message</li>
<li>Cargo!</li>
<li>Safe Concurrency</li>
</ul>
<p>Kekurangan Rust:</p>
<ul>
<li>Learning curve yang tinggi.</li>
<li>Kompilasi yang cukup lama ketika ukuran projek semakin besar.</li>
</ul>
<hr />
<p><em>So, Why use Rust?</em></p>
<p><em>Rust leaves many technical things to its compiler to handle with its static analysis and error friendly messages.</em>
<em>Issues related to type, memory, and thread safety can be caught statically upfront, leaving us to only care about business logic at PR Review.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dasar"><a class="header" href="#dasar">Dasar</a></h1>
<p>Pembahasan dasar meliputi beberapa tipe data, <em>ownership</em>, <em>borrowing</em>, cargo, dan hal-hal dasar lainnya.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="instalasi"><a class="header" href="#instalasi">Instalasi</a></h2>
<p>Rust memiliki tools installer untuk menginstal semua <em>toolschain</em> untuk memudahkan development Rust yaitu <a href="https://rustup.rs/">rustup</a> dengan menjalankan perintah </p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Pilih default installation, dan tunggu sampai installasi selesai. Di unix-based OS biasanya diinstall ke dalam 2 direktori yaitu <code>$HOME/.rustup</code> dan <code>$HOME/.cargo</code>. Direktori pertama tempat menyimpan master data program rustup. Sedangkan direktori ke dua tempat menyimpan toolschain yang dimanage oleh rustup itu sendiri. Biasanya rustup akan secara otomatis meng-ekspor env yang ada di <code>$HOME/.cargo/env</code> ke dalam env variable, misal <code>$HOME/.zshenv</code> atau <code>$HOME/.zshrc</code>. Path env yang dituju adalah <code>$HOME/.cargo/bin</code>, tempat executable dari toolschain rust bersemayam. Kalau path nya belum ada, tinggal diarahkan ke <code>$HOME/.cargo/bin</code>. Tools yang diinstall diantaranya:</p>
<ul>
<li>cargo : builder serta package management untuk Rust</li>
<li>cargo-clippy dan clippy-driver: linting tools</li>
<li>cargo-fmt dan rustfmt : formatting tools</li>
<li>cargo-miri : middle level interpreter untuk Rust IR(Intermediate Representation)</li>
<li>rls : rust language server</li>
<li>rust-gdb : debugging tools menggunakan gdb</li>
<li>rust-lldb : debugging tools menggunakan lldb</li>
<li>rustc : compiler rust</li>
<li>rustup : rustup itu sendiri</li>
<li>rustdoc : doc tools</li>
</ul>
<p>Ketika semua tools di atas sudah terinstall dan path environment sudah di setup, maka silahkan cek version, misal:</p>
<ul>
<li><code>rustc --version</code> untuk versi bahasa rust yang digunakan.</li>
<li><code>cargo --version</code> untuk versi cargo yang digunakan.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toolchain"><a class="header" href="#toolchain">Toolchain</a></h1>
<p>Rust memiliki beberapa toolchain untuk berinteraksi dengan program rust yang digunakan untuk berbagai macam keperluan seperti kompilasi, build, formatting, linting, dan testing. Semua fungsionalitas ini ada di dalam program <code>cargo</code> yang telah kita install sebelumnya.</p>
<p>Untuk menjalankan program Rust, terdapat dua tool utama yang digunakan yaitu <code>rustc</code> yang merupakan compiler rust itu sendiri, dan <code>cargo</code> package management serta build tool untuk rust. Jika kita ingin mengkompilasi sebuah file saja, atau ingin memiliki opsi build untuk program rust yang ditulis, maka bisa menggunakan <code>rustc</code>. Tool kedua <code>cargo</code> lebih direkomendasikan untuk mem-<em>build</em> program yang sudah lebih dari 1 file serta memiliki depedensi satu sama lain termasuk dari 3rd party library. Cargo juga sudah mengabstraksikan banyak hal yang dibutuhkan untuk membangun artifak program dari banyak file dan depedensi dengan perintah yang lebih sederhana.</p>
<h2 id="rustc"><a class="header" href="#rustc">rustc</a></h2>
<p>Contoh penggunaan <code>rustc</code>:
Tulis contoh <code>Hello, World!</code> sederhana berikut dan compile dengan perintah <code>rustc &lt;nama-file&gt;</code>, maka akan menghasilkan binary output yang langsung dapat dieksekusi dengan menjalankan <code>./&lt;nama-binary&gt;</code>(asumsi menggunakan unix-based OS).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, World!&quot;);
}</code></pre></pre>
<h2 id="cargo"><a class="header" href="#cargo">cargo</a></h2>
<p>Cargo lebih digunakan untuk projek dengan codebase yang multi depedensi satu sama lain serta juga dengan library luar. Cargo juga menyediakan banyak perintah untuk manage codebase dengan lebih mudah termasuk meng-inisialisasi codebase.</p>
<h3 id="codebase-baru"><a class="header" href="#codebase-baru">Codebase baru</a></h3>
<p>Ketika ingin memulai projek rust, dimulai dengan perintah <code>cargo init</code> atau <code>cargo new</code>. Kedua perintah ini terlihat mirip, bedanya <code>init</code> akan menciptakan source pada current directory, sedangkan <code>new</code> menciptakan source baru pada path dengan nama yang ditentukan.
Contoh:
<code>cargo new $HOME/code/rust/test-cargo --bin --vcs none</code>
Perintah di atas akan membuat projek rust baru pada path yang ditentukan dengan nama projek. Flag <code>--bin</code> digunakan untuk memberi tau cargo kita akan membuat projek yang akan menghasilkan executable binary. Alternatif lain adalah <code>--lib</code> untuk projek non-executable yang digunakan sebagai library. Kita akan bahas hal-hal ini pada pembahasan selanjutnya tentang struktur projek pada rust. Untuk <code>--vcs none</code> menginisiasi projek tanpa git, karena secara default cargo new akan menginisiasi projek dengan git.</p>
<h3 id="build"><a class="header" href="#build">Build</a></h3>
<p>Untuk membangun program serta menghasilkan runnable artifak maka kita bisa menjalankan perintah:
<code>cargo build</code> pada direktori projek. Default <code>build</code> adalah mode <em>debug</em> atau mode ketika dalam proses development. Ketika kode yang kita buat sudah pantas untuk naik ke production, maka ditambahkan flag release menjadi <code>cargo build --release</code>. Flag tambahan ini melakukan optimisasi program pada compile time sehingga artifak yang dihasilkan berjalan dengan optimal dan maksimal di production.</p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p>Ketika development tentunya kita tidak ingin setiap menjalankan program harus build ulang dan menghasilkan artifak lagi untuk sekedar testing. Oleh sebab itu kita bisa melakukan mode run dengan command <code>cargo run</code> pada direktori projek. Perintah ini mem-<em>build</em> serta menjalankan program secara langsung.</p>
<h3 id="test"><a class="header" href="#test">Test</a></h3>
<p>Perintah <code>cargo test</code> digunakan untuk menjalankan semua bagian program yang ditandai sebagai <code>test</code>. Kita akan bahas ini pada pembahasan lebih lanjut.</p>
<h3 id="clippy"><a class="header" href="#clippy">Clippy</a></h3>
<p>Perintah <code>cargo clippy</code> digunakan untuk menjalankan linter terhadap codebase kita untuk melakukan pengecekkan terhadap hal-hal yang berkaitan dengan style, convention, code organization, dan lainnya. Ada banyak opsi linting pada rust yang bisa digunakan atau kita buat sendiri. Tersedia banyak tools linting pada <a href="https://rust-lang.github.io/rust-clippy/master/">clippy</a> dengan berbagai kategori.</p>
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<p>Perintah <code>cargo fmt</code> akan meng-format seluruh code di semua file-file dengan ekstensi <code>.rs</code> menyesuaikan dengan format standar pada rust yang tentunya untuk tampilah kode yang lebih nyaman dibaca.</p>
<p>Masih banyak hal lain yang tersedia pada <code>cargo</code> beserta flag-flagnya yang harus dieksplorasi sendiri menyesuaikan kebutuhan.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Kita akan membuat program pertama dengan menggunakan <code>cargo</code> untuk memudahkan me-<em>manage</em> dan scale projek. </p>
<p>Masukkan perintah berikut:</p>
<pre><code>cargo new &lt;path-to-your-new-project&gt; --bin --vcs none
</code></pre>
<p>Direktori projek akan terbentuk pada path yang ditentukan dengan struktur direktori dan file-file yang konvensional dalam development rust. 
Karena kita membuat projek baru untuk executable maka kita menggunakan flag <code>--bin</code> dan akan menghasilkan default program baru berupa <code>Hello, world!</code> di dalam file <code>src/main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, World!&quot;);
}</code></pre></pre>
<p>Jalankan perintah:</p>
<pre><code>cargo run
</code></pre>
<p>Maka akan muncul </p>
<pre><code>Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struktur-codebase"><a class="header" href="#struktur-codebase">Struktur Codebase</a></h1>
<p>Kita akan mempelajari bagaimana struktur code, file dan direktori pada projek rust. Disini kita tidak membahas mengenai kaitannya dengan business domain atau business logic apapun, serta juga tidak membahas arsitektur-arsitektur projek tertentu seperti SOLID, Clean Code, Clean Arch, dan lainnya. Kita hanya membahas pada konteks <em>build system</em> di dalam projek rust menggunakan <em>cargo</em>. </p>
<h2 id="struktur-direktori"><a class="header" href="#struktur-direktori">Struktur Direktori</a></h2>
<p>Konvensi direktori yang dihasilkan ketika inisiasi dan jalankan projek rust menggunakan cargo pertama kali adalah:</p>
<pre><code>&lt;project-dir&gt;
  |--src/
      |--main.rs/lib.rs # file utama untuk binary(main) atau library(lib)
  |--target/ # direktori berisi hasil cargo build
  |--Cargo.lock
  |--Cargo.toml # konfigurasi package dan depedensi
</code></pre>
<h2 id="jenis-program"><a class="header" href="#jenis-program">Jenis Program</a></h2>
<p>Setiap program di dalam Rust merupakan hasil kompilasi dari crate-crate yang terdapat di dalam direktori <em>src/</em>.
Terdapat 2 jenis crate di dalam rust yaitu: </p>
<ul>
<li><strong>binary</strong> : Crate yang menghasilkan executable program. File utama memiliki deklarasi fungsi <code>fn main()</code> sebagai entry point program di dalam file <code>main.rs</code>.</li>
<li><strong>library</strong> : Crate yang menghasilkan non-executable program berupa pendukung/pelengkap/plugin untuk codebase lainnya. Tidak memiliki fungsi main hanya deklarasi-deklarasi module-module di dalam file <code>lib.rs</code>.</li>
</ul>
<h2 id="komponen-codebase"><a class="header" href="#komponen-codebase">Komponen Codebase</a></h2>
<p>Di dalam codebase Rust terdapat beberapa jenis komponen-komponen yang keseluruhannya membentuk projek utuh yang ditulis dalam Rust.
Berikut komponen-komponen tersebut mulai dari yang terkecil:</p>
<ul>
<li>
<p><strong>Types</strong>: Tipe data yang merupakan komponen terakhir yang bisa diakses dalam struktur codebase. Ada beberapa jenis tipe data di dalam Rust yaitu:</p>
<div class="table-wrapper"><table><thead><tr><th>Types</th><th>Desc.</th><th>Naming Convention</th></tr></thead><tbody>
<tr><td><strong>const</strong></td><td>Values embedded at compile time</td><td>SCREAMING_SNAKE_CASE</td></tr>
<tr><td><strong>static</strong></td><td>Values allocated once at compile time</td><td>SCREAMING_SNAKE_CASE</td></tr>
<tr><td><strong>trait</strong></td><td>Declaration of shared types, constants, and functions/methods</td><td>PascalCase</td></tr>
<tr><td><strong>struct</strong></td><td>Product Type</td><td>PascalCase</td></tr>
<tr><td><strong>enum</strong></td><td>Sum Type</td><td>PascalCase</td></tr>
<tr><td><strong>fn</strong></td><td>Functions or Methods</td><td>snake_case</td></tr>
</tbody></table>
</div></li>
<li>
<p>Module(<strong>mod</strong>) : Module merupakan segment kode yang memiliki cakupan kecil dan besar hingga satu file. Komponen ini berguna untuk memisahkan segment program dan melakukan enkapsulasi struktur program. Untuk naming conventions menggunakan <em>snake_case</em>. Module memiliki 3 lokasi ketika program dibuild yaitu:</p>
<ul>
<li>Inline: deklarasi mod langsung dengan kode menggunakan kurung kurawal.</li>
<li>Di dalam file dengan nama yang sama dengan mod(jika mod 1 level dengan file utama crate(<code>main.rs</code>/<code>lib.rs</code>)), atau di dalam direktori dengan nama yang sama dengan nama mod(untuk submodule)</li>
<li>Di dalam direktori dengan nama yang sama dengan mod di dalam file <code>mod.rs</code>.</li>
</ul>
</li>
<li>
<p>Crate : Representasi dari keseluruhan komponen-komponen di atas ke dalam <em>binary</em> crate atau <em>library</em> crate yang terletak di dalam direktori <em>src/</em>. Untuk binary ditentukan dengan fungsi <code>main</code> di dalam salah satu file di dalam crate itu yang berfungsi sebagai entry point eksekusi program. Untuk naming convention file menggunakan <em>snake_case</em>.</p>
</li>
<li>
<p>Package : Package membungkus semua crate-crate yang telah kita buat di atas. Di level ini juga kita meletakkan file konfigurasi depedensi berupa <code>Cargo.toml</code> untuk mendeklarasikan crate-crate yang akan digunakan di dalam package tersebut. Package juga merupakan cara untuk men-distribusikan code kita untuk di reuse di tempat lain baik sebagai 3rd party atau internal project/service.</p>
</li>
<li>
<p>Workspace : Merupakan gabungan dari beberapa package-package dengan <code>Cargo.toml</code> yang berisi deklarasi package-package terkandung. Ketika kita menjalankan perintah cargo di dalam workspace, maka akan ditelusuri melalui package-package yang ada di dalam konfigurasi toml workspace.</p>
</li>
</ul>
<h2 id="visibiliti-komponen"><a class="header" href="#visibiliti-komponen">Visibiliti Komponen</a></h2>
<p>Setiap komponen di atas bersifat private dan hanya bisa diakses menggunakan keyword <strong>pub</strong> di depan setiap deklarasi komponen. 
Contoh:</p>
<pre><code>pub mod module {
    pub const CONSTANT: &amp;str = &quot;this is constant&quot;;
}
</code></pre>
<p>Maka <code>CONSTANT</code> dapat diakses lewat <code>...::module::CONSTANT;</code>.</p>
<h2 id="komposisi-komponen"><a class="header" href="#komposisi-komponen">Komposisi Komponen</a></h2>
<p>Berikut peraturan-peraturan tentang komposisi komponen-komponen di dalam codebase:</p>
<ul>
<li>1 workspace berisi minimal 1 package</li>
<li>1 package hanya dapat berisi:
<ul>
<li>1 binary crate, atau</li>
<li>1 library crate, atau</li>
<li>1 binary crate dan 1 library crate, atau</li>
<li>N binary crates dan 1 library crate</li>
<li>N sub-packages</li>
</ul>
</li>
<li>1 crate merupakan 1 dari 2 jenis program di dalam Rust yaitu <em>binary</em>(executable) dan <em>library</em>(non-executable)</li>
<li>1 module bisa berisi module lain atau berbagai macam komponen lebih kecil lainnya.</li>
</ul>
<p>Contoh dari komposisi di atas bisa dilihat di <a href="https://github.com/mfathirirhas/rust-namespace">rust-namespace</a></p>
<h2 id="contoh-struktur-codebase"><a class="header" href="#contoh-struktur-codebase">Contoh Struktur Codebase</a></h2>
<h3 id="1-binary-crate"><a class="header" href="#1-binary-crate">1 Binary Crate</a></h3>
<pre><code>sample_1_binary/
|--src/
    |--file1/                   # direktori submodule yang diakses dari file1.rs
        |--sub_file_1/          # direktori submodule yang diakses dari sub_file_1.rs
            |--sub_sub_file_1/  # nama submodule yang diakses dari sub_file_1.rs
                |--mod.rs       # kode submodule sub_sub_file_1 yang diakses dari sub_file_1.rs
        |--sub_file_1_2.rs      # module sub_file_1_2.rs diakses dari file1.rs
        |--sub_file_1.rs        # module sub_file_1.rs diakses dari file1.rs
    |--file2/                   # direktori module file2 yang diakses dari main.rs
        |--mod.rs               # module file2 yang diakses dari main.rs
        |--sub_mod.rs           # submodule sub_mod yang diakses dari file2/mod.rs
    |--file1.rs                 # module `file1` diakses di main.rs
    |--main.rs                  # tempat entrypoint program fn main()
|--target/
|--Cargo.lock
|--Cargo.toml
</code></pre>
<h3 id="1-library-crate"><a class="header" href="#1-library-crate">1 Library Crate</a></h3>
<pre><code>sample_1_binary/
|--src/
    |--file1/                   # direktori submodule yang diakses dari file1.rs
        |--sub_file_1/          # direktori submodule yang diakses dari sub_file_1.rs
            |--sub_sub_file_1/  # nama submodule yang diakses dari sub_file_1.rs
                |--mod.rs       # kode submodule sub_sub_file_1 yang diakses dari sub_file_1.rs
        |--sub_file_1_2.rs      # module sub_file_1_2.rs diakses dari file1.rs
        |--sub_file_1.rs        # module sub_file_1.rs diakses dari file1.rs
    |--file2/                   # direktori module file2 yang diakses dari main.rs
        |--mod.rs               # module file2 yang diakses dari main.rs
        |--sub_mod.rs           # submodule sub_mod yang diakses dari file2/mod.rs
    |--file1.rs                 # module `file1` diakses di main.rs
    |--lib.rs                   # tempat mendeklarasi dan meng-eksport semua module2
|--target/
|--Cargo.lock
|--Cargo.toml
</code></pre>
<p>Sama dengan direktori 1 Binary di atas, bedanya file utama <code>lib.rs</code> cuma berisi dekalrasi-deklarasi module dan tanpa fungsi main di dalamnya.</p>
<h3 id="1-binary--1-library-crate"><a class="header" href="#1-binary--1-library-crate">1 Binary &amp; 1 Library Crate</a></h3>
<pre><code>sample_1_binary_1_library/
|--src/
    |--binary/
        |--main.rs
    |--library/
        |--funcs.rs
        |--lib.rs
|--target/
|--Cargo.lock
|--Cargo.toml
</code></pre>
<p>Pada direktori di atas, terdapat 2 crate dengan file utama masing-masing, binary crate(main.rs) dan library crate(lib.rs). Library crate tidak berisi executable program, hanya sekumpulan kode yang mendukung development yang terjadi di binary dan dipanggil ke dalam binary crate.</p>
<h3 id="n-binary--1-library-crate"><a class="header" href="#n-binary--1-library-crate">N Binary &amp; 1 Library Crate</a></h3>
<pre><code>sample_n_binary_1_library/
|--src/
    |--bin/
        |--main_4.rs
        |--main_5.rs
    |--lib/
        |--lib.rs
    |--main_3/
        |--main_3.rs
    |--main_1.rs
    |--main_2.rs
|--target/
|--Cargo.lock
|--Cargo.toml
</code></pre>
<p>Terdapat 5 binary crate dengan nama file utama <em>main_1.rs</em>, <em>main_2.rs</em>, <em>main_3.rs</em>, <em>main_4.rs</em>, <em>main_5.rs</em>, dan 1 library crate dengan nama <em>lib.rs</em> di dalam direktori <em>lib/</em>.</p>
<h3 id="n-sub-packages"><a class="header" href="#n-sub-packages">N Sub-packages</a></h3>
<pre><code>sample_n_sub-packages/
|--src/
    |--src/
    |--package-1/
    |--package-2/
    |--...
|--target/
|--Cargo.lock
|--Cargo.toml
</code></pre>
<p>Package <code>package-1</code> dan <code>package-2</code> merupakan package tersendiri dengan struktur yang sama seperti diluar. <code>package-1</code> dan <code>package-2</code> akan diimport oleh package di luar. Deklarasi import sub-packages ke dalam package luar di toml adalah:</p>
<pre><code class="language-toml">package-name = {path = &quot;path-to-subpackage&quot;, package = &quot;package-name&quot;}
</code></pre>
<ul>
<li><strong>package-name</strong>: nama yang akan di import menggunakan <code>use package-name::</code></li>
<li><strong>path-to-subpackage</strong>: path ke subpackage dimulai dari root package. Pada contoh di atas maka bisa digunakan: <code>package-1</code></li>
<li><strong>package-name</strong>: nama package dari path di atas. Biasanya nama package sama dengan nama directory.</li>
</ul>
<p>Secara <em>convetion</em> cargo, cargo akan secara otomatis membaca binary crates yang ada di dalam direktori <em>src/bin/&lt;file_name.rs&gt;</em> tanpa mendeklarasikan crate path di dalam <em>Cargo.toml</em>. Jika kita tidak mengikuti <em>convention</em> tersebut, maka kita harus deklarasikan nama dan path dari crate di dalam <em>Cargo.toml</em> di bawah section <code>[package]</code> di atas section <code>[dependencies]</code> seperti contoh:</p>
<pre><code class="language-ini">...

[[bin]]
name = &quot;main_1&quot;
path = &quot;src/main_1.rs&quot;

[lib]
name = &quot;lib&quot;
path = &quot;src/lib/lib.rs&quot;

[[bin]]
name = &quot;main_2&quot;
path = &quot;src/main_2.rs&quot;

[[bin]]
name = &quot;main_3&quot;
path = &quot;src/main_3/main_3.rs&quot;

...
</code></pre>
<h3 id="workspace"><a class="header" href="#workspace">Workspace</a></h3>
<pre><code>sample_workspace/
|--package_1_binary/
    |--src/
        |--file1/                   # direktori submodule yang diakses dari file1.rs
            |--sub_file_1/          # direktori submodule yang diakses dari sub_file_1.rs
                |--sub_sub_file_1/  # nama submodule yang diakses dari sub_file_1.rs
                    |--mod.rs       # kode submodule sub_sub_file_1 yang diakses dari sub_file_1.rs
            |--sub_file_1_2.rs      # module sub_file_1_2.rs diakses dari file1.rs
            |--sub_file_1.rs        # module sub_file_1.rs diakses dari file1.rs
        |--file2/                   # direktori module file2 yang diakses dari main.rs
            |--mod.rs               # module file2 yang diakses dari main.rs
            |--sub_mod.rs           # submodule sub_mod yang diakses dari file2/mod.rs
        |--file1.rs                 # module `file1` diakses di main.rs
        |--main.rs                  # tempat entrypoint program fn main()
    |--Cargo.toml
|--package_2_binary/
    |--src/
        |--file1/                   # direktori submodule yang diakses dari file1.rs
            |--sub_file_1/          # direktori submodule yang diakses dari sub_file_1.rs
                |--sub_sub_file_1/  # nama submodule yang diakses dari sub_file_1.rs
                    |--mod.rs       # kode submodule sub_sub_file_1 yang diakses dari sub_file_1.rs
            |--sub_file_1_2.rs      # module sub_file_1_2.rs diakses dari file1.rs
            |--sub_file_1.rs        # module sub_file_1.rs diakses dari file1.rs
        |--file2/                   # direktori module file2 yang diakses dari main.rs
            |--mod.rs               # module file2 yang diakses dari main.rs
            |--sub_mod.rs           # submodule sub_mod yang diakses dari file2/mod.rs
        |--file1.rs                 # module `file1` diakses di main.rs
        |--main.rs                  # tempat entrypoint program fn main()
    |--Cargo.toml
|--package_3_library/
    |--src/
        |--file1/                   # direktori submodule yang diakses dari file1.rs
            |--sub_file_1/          # direktori submodule yang diakses dari sub_file_1.rs
                |--sub_sub_file_1/  # nama submodule yang diakses dari sub_file_1.rs
                    |--mod.rs       # kode submodule sub_sub_file_1 yang diakses dari sub_file_1.rs
            |--sub_file_1_2.rs      # module sub_file_1_2.rs diakses dari file1.rs
            |--sub_file_1.rs        # module sub_file_1.rs diakses dari file1.rs
        |--file2/                   # direktori module file2 yang diakses dari main.rs
            |--mod.rs               # module file2 yang diakses dari main.rs
            |--sub_mod.rs           # submodule sub_mod yang diakses dari file2/mod.rs
        |--file1.rs                 # module `file1` diakses di main.rs
        |--lib.rs                  # tempat entrypoint program fn main()
    |--Cargo.toml
|--target/
|--Cargo.lock
|--Cargo.toml
</code></pre>
<p>Workspace punya toml sendiri yang berisi deklarasi member2 package di dalamnya:
contoh:</p>
<pre><code class="language-ini">[workspace]

members = [
    &quot;package_1_binary&quot;,
    &quot;package_2_binary&quot;,
    &quot;package_3_library&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="komponen-codebase-1"><a class="header" href="#komponen-codebase-1">Komponen Codebase</a></h1>
<p>Kita akan membahas komponen codebase yang merupakan segmentasi dari program Rust:
<code>Workspace -&gt; Packages -&gt; Modules -&gt; Constants/Statics/Types/Associated Items</code></p>
<p>Sebelum kita membahas beberapa komponen pada Rust program, kita akan membahas beberapa konsep yang berkaitan dengan komponen tersebut.</p>
<h2 id="immutability-vs-mutability"><a class="header" href="#immutability-vs-mutability">Immutability vs Mutability</a></h2>
<p>Setiap variables dan statics pada Rust bersifat <em>immutable</em> secara default. Ini merupakan salah satu pendekatan functional programming dimana untuk menghindari side-effects pada data. Immutability menyebabkan data tidak bisa di-<em>assign</em> dengan value lain dan tidak bisa diubah. 
Jika ingin memberikan mutability pada variable, bisa menggunakan keyword <code>mut</code> atau <code>&amp;mut</code> untuk mutable borrow.
Mutability hanya berlaku untuk variables dan statics. Untuk statics jika ingin melakukan mutasi, harus di dalam <code>unsafe</code> block.</p>
<h2 id="let-binding"><a class="header" href="#let-binding"><code>let</code> binding</a></h2>
<p>Merupakan keyword untuk mendeklarasi variable dan memberikan lifetime pada variable tersebut sampai berpindah/akhir scope. Karena semua variable pada rust bisa di-referensikan/borrowed, maka semua variable memiliki lifetime. Ketika kita mendeklarasi <code>let</code> untuk menciptakan variable dengan nama, maka kita sudah mendeklarasikan lifetime dari reference dari variable tersebut, sepanjang lifetime dari deklarasi <code>let</code>. </p>
<p>Kita bisa mendeklarasi reference pada data literal langsung tanpa <code>let</code> binding, akan tetapi ini menyebabkan reference tersebut hanya memiliki lifetime sepanjang statement assignment tempat literal reference tersebut dibuat. <a href="https://users.rust-lang.org/t/temporary-value-is-freed-at-the-end-of-this-statement/84667/4?u=mfathirirhas">Ref</a> , hal ini hanya berlaku untuk <em>mutable reference</em>.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let mut orphan_reference = &amp;123;
    orphan_reference = &amp;900;
    println!(&quot;{:?}&quot;, orphan_reference);
    dbg!(orphan_reference);

    // failed karena mutable orphan reference without let binding live only as long as its statement.
    // let mut orphan_reference = &amp;mut 123;
    // orphan_reference = &amp;mut 900;
    // println!(&quot;{:?}&quot;, orphan_reference);
    // dbg!(orphan_reference);

    let binding: i32 = 123;
    let borrow = &amp;binding;
    dbg!(binding);
    dbg!(borrow);

    let binding: String = &quot;123&quot;.to_owned();
    let borrow = &amp;binding;
    println!(&quot;{:?}&quot;, binding);
    println!(&quot;{:?}&quot;, borrow);
    dbg!(&amp;binding);
    dbg!(borrow);
}
<span class="boring">}</span></code></pre></pre>
<p>Kita akan membahas lebih detail tentang komponen-komponen yang ada di dalam codebase Rust. Secara umum dapat terbagi di antaranya:</p>
<ul>
<li>Variables (local variables)</li>
<li>Statics (global variables)</li>
<li>Constants</li>
<li>Functions</li>
<li>Closures</li>
<li>Types (User Defined Types)</li>
<li>Associated Types/Items</li>
</ul>
<p>Semua komponen di atas berada di dalam module(<code>mod</code>).</p>
<h2 id="variable"><a class="header" href="#variable">Variable</a></h2>
<p>Variable di dalam Rust hanya bisa dideklarasi di dalam scope function. Variable ini bersifat local dan akan dihapus setelah function return/exit.
Naming convention local variable menggunakan <em>snake_case</em>.
Berikut contoh deklarasi local variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 123;
let b: i32 = 123;
let c = &quot;literal string&quot;;
let d: String = &quot;Object String&quot;.to_string();
let e: = &amp;123;

// deklarasi mutable
let mut a = 123;
a = a + 1; // 124

let mut s = String::from(&quot;test&quot;);
s.push_str(&quot;anu&quot;);
println!(&quot;{}&quot;, s); // testanu
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas, terdapat 4 jenis deklarasi variable. Variable <code>a</code> tidak memiliki deklarasi tipe karena Rust dapat meng-<em>infer</em> tipe data tersebut saat compile time. Variable <code>b</code> memiliki tipe data setelah colon <code>:</code>. Variable <code>c</code> merupakan jenis string literal atau reference string. Variable <code>d</code> merupakan jenis string <em>owned</em> dimana value string literal harus diubah ke owned menggunakan method <code>to_string()</code>.</p>
<h2 id="reference-variable-"><a class="header" href="#reference-variable-">Reference Variable (<code>&amp;</code>)</a></h2>
<p>Merupakan variable yang berisi address dari variable yang direferensikan.
Beberapa kegunaan reference variable:</p>
<ul>
<li>Menyediakan data secara <em>read-only</em> menggunakan <em>immutable</em> reference tanpa memindahkan <em>ownership</em> data jika <em>clonable</em></li>
<li>Memberikan <em>side-effect</em> kepada fungsi menggunakan <em>mutable</em> reference tanpa memindahkan <em>ownership</em> data jika <em>clonable</em></li>
<li>Mem-<em>passing</em> data antar fungsi/method tanpa melakukan <em>copy</em>/<em>clone</em> terhadap value, sehingga yang di-<em>copy</em>/<em>clone</em> hanyalah address dari data(lebih murah).</li>
</ul>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Shadowing adalah ketika local variable lama dioverwrite dengan tipe dan value baru. Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 123; // i32
let a = &quot;from i32 to string&quot;; // &amp;str
let a = &quot;from string to owned string&quot;.to_string(); // String
<span class="boring">}</span></code></pre></pre>
<p>Variable <code>a</code> dapat dideklarasikan kembali berulang-ulang dengan tipe yang berbeda. Value yang digunakan adalah yang terakhir kali dideklarasikan.</p>
<h2 id="constant"><a class="header" href="#constant">Constant</a></h2>
<p>Constant juga immutable by default dan tidak bisa dijadikan mutable. Deklarasi constant mengharuskan menggunakan tipe data. Constant harus dideklarasikan menggunakan value yang dapat dikomputasi pada saat kompilasi. Jika value butuh alokasi heap, maka tidak bisa di-<em>assign</em> ke constant . Constant dapat berisi ekspresi non-final dan dikomputasi pada saat kompilasi. Constant dievaluasi pada saat kompilasi dan ditaruh ke dalam binary program, sehingga tidak memiliki address di memory. Constant valid selama program berjalan. Contoh deklarasi constant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const a: i32 = 123;
const b: &amp;str = &quot;anu&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Masih banyak jenis constant evaluated values/expressions lainnya yang akan dibahas berikutnya.</p>
<h2 id="static"><a class="header" href="#static">Static</a></h2>
<p>Memiliki kemiripan dengan <code>const</code>, perbedaan terletak pada static memiliki alamat memory ketika dikompilasi. Ketika variable static dipanggil maka ada proses dereference terhadap value yang ada di alamat memori dari variable static tersebut. Perbedaan lainnya adalah static dapat menjadi mutable pada saat runtime. Mutability static pada saat runtime hanya bisa dilakukan di dalam blok <code>unsafe</code>. Contoh deklarasi static:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static a: i32 = 123;
static b: &amp;str = &quot;anu&quot;;
println!(&quot;{:p}&quot;, a);
println!(&quot;{:p}&quot;, b);
<span class="boring">}</span></code></pre></pre>
<p>Bukti bahwa static memiliki alamat memori adalah kita bisa mendapatkan alamat memori tersebut dengan cara di atas. Sementara kita tidak bisa melakukan hal itu terhadap constant karena constant tidak memiliki alamat memori.</p>
<h2 id="types-user-defined-types"><a class="header" href="#types-user-defined-types">Types (User Defined Types)</a></h2>
<p>Berikut beberapa tipe data yang bisa di-deklarasi oleh user dan bisa masuk ke dalam bagian namespace:</p>
<ul>
<li><code>struct</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct {
    f1: i32,
    f2: String,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>enum</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    F1(i32),
    F2(String),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>union</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Types aliases</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Integer32 = i32;
type Float64 = f64;
<span class="boring">}</span></code></pre></pre>
<p>Type alias bisa menerima value dengan tipe yang sama dengan alias-nya.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Types disini merupakan user defined types, yang biasanya berupa struct, tuple, enum, dan alias. 
Contoh alias:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type CustomResult&lt;T&gt; = Result&lt;T, String&gt;

fn get() -&gt; CustomResult&lt;T&gt; {
    Ok(1)
}
fn get_2() -&gt; CustomResult&lt;T&gt; {
    Err(&quot;error_message&quot;.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>Type aliases berguna untuk mempersingkat tipe yang panjang.</p>
<h2 id="associated-typesitems"><a class="header" href="#associated-typesitems">Associated types/items</a></h2>
<p>Merupakan type custom atau items yang ada di dalam deklarasi inherent implementations seperti <code>impl X</code> atau di dalam trait.</p>
<p>Contoh Associated types/items:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Struct;

impl Struct {
    // pub type Item = i32; // as of now it's unstable
    pub const CONSTANT_STR: &amp;str = &quot;test&quot;; // associated constant

    pub fn function() {} // associated function

    // ...
}

trait Trait {
    const C: i32; // associated constant without default value.
    const D: &amp;'static str = &quot;defined&quot;; // associated constant with default value, can be replaced with implementor.
    type CustomResult&lt;'a, T&gt;; // associated type without default value.
    // type CustomResult&lt;'a, T&gt; = Result&lt;T,&amp;'a str&gt;; // associated type with default value, as of now it's unstable.

    fn function();
    fn default_function() {

    }

    fn method(&amp;self);
    fn default_method(&amp;self) {

    }
}

impl Trait for Struct {
    const C: i32 = 123;
    const D: &amp;'static str = &quot;replaced&quot;; // overwrite Trait default value of D
    type CustomResult&lt;'a, T&gt; = Result&lt;T, &amp;'a str&gt;;

    fn function() {
        
    }
    
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Fungsi merupakan unit komputasi paling dasar dengan deklarasi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_name(param1: Type1, param2: Type2, ...) -&gt; ReturnType {
    ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="constant-function"><a class="header" href="#constant-function">Constant Function</a></h2>
<p>Merupakan constant expression dalam bentuk fungsi yang bisa dievaluasi/komputasi pada saat compile-time.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">// calculate_at_compile computed at compile-time.
const CONSTANT: [i32;5] = calculate_at_compile(true);

const fn calculate_at_compile(b: bool) -&gt; [i32;5] {
    if b {
        return [1,2,3,4,5];
    }
    [6,7,8,9,10]
}

fn main() {
    // after compiled, CONSTANT already replaced with `[1,2,3,4,5]`
    println!(&quot;{:?}&quot;, CONSTANT);
}</code></pre></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Closures merupakan anonymous function atau lambda pada Rust yang digunakan ketika kita ingin menjadikan function sebagai argument pada parameter fungsi lainnya.
Berbeda dengan fungsi biasa di Rust yang tidak bisa meng-<em>capture</em> data pada environment bersangkutan, Closures secara default akan menangkap environment sekitar dengan cara borrow/reference.
Berikut contoh deklarasi closures yang valid di dalam Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// deklarasi closure dengan tipe data.
let add_one_v2 = |x: u32| -&gt; u32 { 
    x + 1
    //...
    //... 
};

// deklarasi tanpa tipe data, dengan curly brackets.
let add_one_v3 = |x| { 
    x + 1;
    //...
    //...
};

// deklarasi tanpa tipe data, tanpa curly brackets.
let add_one_v4 = |x| x + 1;
add_one_v4(5); // return 6
<span class="boring">}</span></code></pre></pre>
<p>Compiler akan secara otomatis meng-infer tipe data dari parameter yang tidak diberi tipe data. Jika body hanya 1 baris, maka block curly brackets bisa dihilangkan.</p>
<p>Closure menangkap data sekitar secara borrow/reference secara default, jika ingin memindahkan ownership(move) dari data tersebut, kita bisa menggunakan move semantics dengan keyword <code>move</code> sebelum bar pertama.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let owned_data = String::from(&quot;im owned&quot;);
let catch_by_move = move || {
    println!(&quot;catched data: {:?}&quot;, owned_data);
}
println!(&quot;{:?}&quot;, owned_data); // will failed because moved into closure
<span class="boring">}</span></code></pre></pre>
<p>Move semantics hanya berlaku untuk tipe data yang bersifat <em>clone-able</em>. Untuk data-data yang bersifat static seperti primitive types, move semantics akan meng-<em>copy</em> data tersebut kedalam closure sehingga masih valid jika dipanggil lagi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let int = 123;
let closure = || {
    let x = 123;
    println!(&quot;{}&quot;, x);
};
closure();
println!(&quot;{}&quot;, int);
<span class="boring">}</span></code></pre></pre>
<h2 id="jenis-jenis-closure"><a class="header" href="#jenis-jenis-closure">Jenis-jenis Closure</a></h2>
<p>Semua closures pada Rust akan memiliki 1,2 atau 3 dari jenis di bawah ini tergantung bagaimana body closure meng-handle environment sekitar.</p>
<h3 id="fnonce"><a class="header" href="#fnonce"><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html">FnOnce</a></a></h3>
<p>Closure trait paling dasar dimana semua jenis closure akan compatible.
Beberapa sifat <code>FnOnce</code>:</p>
<ul>
<li>Dipanggil cuma 1 kali.</li>
<li>Call-by-value, karena value yang dimasukkan ke dalam body closure di-consumed sehingga hanya bisa di-call sekali.</li>
<li>menerima semua jenis closures(FnMut &amp; Fn) jika ditaruh sebagai parameter input.
Karena FnOnce merupakan supertype dari semua jenis functional trait yang ada di dalam Rust, sehingga bisa menerima semua child-nya.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string = String::from(&quot;string_value&quot;);
    do_fn_once(|| {
        println!(&quot;do_fn_once {:?}&quot;, string);
    });
    println!(&quot;{:?}&quot;,string);
}

fn do_fn_once&lt;F: FnOnce()&gt;(f: F) {
    f();
    // f(); /// if this is invoked, will failed because FnOnce will moved the `string` into the closure without requiring `move` declaration before closure bar.
}</code></pre></pre>
<h3 id="fnmut"><a class="header" href="#fnmut"><a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html">FnMut</a></a></h3>
<p>Subtype dari <code>FnOnce</code>, dengan kriteria:</p>
<ul>
<li>Bisa dipanggil lebih dari 1 kali</li>
<li>Call-by-mutable-reference</li>
<li>Digunakan ketika ingin meng-capture mutable value by reference.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut string = String::from(&quot;mutate me&quot;);
    do_fn_mut(|| {
        string.push_str(&quot;|changed|&quot;);
    });
    println!(&quot;{}&quot;, string); // print &quot;mutate me|changed||changed||changed|&quot;, because closure invoked 3 times inside `do_fn_mut()`
}

fn do_fn_mut&lt;F: FnMut()&gt;(mut f: F) {
    f();
    f();
    f();
}</code></pre></pre>
<h3 id="fn"><a class="header" href="#fn"><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html">Fn</a></a></h3>
<p>Subtype dari <code>FnMut</code>, dengan kriteria:</p>
<ul>
<li>Bisa dipanggil lebih dari 1 kali</li>
<li>Call-by-immutable-reference</li>
<li>Digunakan ketika ingin meng-capture value sekitar by reference berkali2.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string = String::from(&quot;borrow me&quot;);
    do_fn(|| {
        println!(&quot;called from closure: {:?}&quot;, string);
    });
    println!(&quot;{}&quot;, string);
}

fn do_fn&lt;F: Fn()&gt;(f: F) {
    // can be called multiple times since values trapped inside only borrowed(referenced).
    f();
    f();
    f();
}</code></pre></pre>
<h2 id="function-pointer"><a class="header" href="#function-pointer">Function Pointer</a></h2>
<p>Kalau closure merupakan trait, maka function pointer merupakan type. Kita tidak perlu mendeklarasi generic dengan bound closure traits untuk mem-<em>passing</em> function pointer. Function pointer merupakan ekstensi dari semua function traits, sehingga function pointer bisa diterima di parameter fungsi dengan tipe parameter function traits apapun(FnOnce, FnMut, Fn). Hal ini berguna khususnya ketika kita sudah punya definisi fungsi dan ingin menggunakan fungsi tersebut sebagai value pada fungsi/method lain.</p>
<p>Perbedaan lainnya closure dengan function pointer adalah function pointer tidak bisa menangkap variable sekitar, hanya lewat parameter.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

pub fn f(x: i32) -&gt; fn(i32) -&gt; i32 {
    f2
}

fn f2(x: i32) -&gt; i32 {
    123
}

// failed, because return type is covariance so subtype should be passed to supertype,
// but what happen here is we are passing supertype(closure) into subtype(function pointer)
// pub fn multiply(x: i32, y: i32) -&gt; fn(i32) -&gt; i32 {
//     |z| -&gt; i32 { x * y * z }
// }

pub fn accept_fn(f: fn(i32, i32) -&gt; i32, x: i32, y: i32) -&gt; i32 {
    f(x, y)
}

pub fn return_fn() -&gt; fn(i32, i32) -&gt; i32 {
    add
}

pub fn return_nested_fn_with() -&gt; fn(i32) -&gt; fn(i32) -&gt; i32 {
    f
}

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Rust memiliki tipe-tipe paling dasar untuk menghandle beberapa data diantaranya numerik, karakter, kalimat, bytes, dan lainnya.</p>
<p>Berikut beberapa tipe-tipe dasar dalam Rust:</p>
<h2 id="unit-"><a class="header" href="#unit-">Unit <code>()</code></a></h2>
<p>Tipe data yang tidak berarti apa-apa. Biasanya digunakan ketika ingin meng-<em>ignore</em> deklarasi tipe data. 
Salah satu kegunaan tipe ini adalah untuk meng-<em>ignore</em> deklarasi tipe data untuk generic type.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn return_nothing() -&gt; () {
    println!(&quot;do nothing&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>true</td><td>true</td></tr>
<tr><td>false</td><td>false</td></tr>
</tbody></table>
</div>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b: bool = true;
<span class="boring">}</span></code></pre></pre>
<h2 id="integer"><a class="header" href="#integer">Integer</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>i8</td><td>8bit integer</td></tr>
<tr><td>i16</td><td>16bit integer</td></tr>
<tr><td>i32</td><td>32bit integer</td></tr>
<tr><td>i64</td><td>64bit integer</td></tr>
<tr><td>i128</td><td>128bit integer</td></tr>
<tr><td>isize</td><td>bit size depends on target arch</td></tr>
</tbody></table>
</div>
<p>Untuk tipe <em>unsigned</em> tinggal mengganti <em>i</em> menjadi <em>u</em> seperti u8, u16, u32, u64, u128, dan usize.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n: i64 = 123345;
<span class="boring">}</span></code></pre></pre>
<h2 id="floating-point"><a class="header" href="#floating-point">Floating Point</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>f32</td><td>32bit floating point</td></tr>
<tr><td>f64</td><td>64bit floating point</td></tr>
</tbody></table>
</div>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: f64 = 123.5;
<span class="boring">}</span></code></pre></pre>
<h2 id="character"><a class="header" href="#character">Character</a></h2>
<p>Menggunakan <em>single quote</em> seperti <code>'a'</code>.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c: char = 'a';
<span class="boring">}</span></code></pre></pre>
<p>Semua tipe data di atas harus diketahui ukurannya pada saat compile time dan tetap dalam ukuran.</p>
<h2 id="pointer"><a class="header" href="#pointer">Pointer</a></h2>
<p>Ada 2 jenis pointer di rust, yaitu reference pointer dan raw pointer.</p>
<ul>
<li>Reference Pointer(<code>&amp;</code> &amp; <code>&amp;mut</code>): menggunakan ampersand <code>&amp;</code>. Memiliki safety guaranty dari Rust menggunakan borrow checker. Reference pointer lebih sering digunakan karena safe dan dijamin oleh borrow checker rust. Tidak memerlukan unsafe operation dan value selalu valid.</li>
<li>Raw Pointer(<code>*const</code> &amp; <code>*mut</code>): menggunakan asterisk <code>*</code>. Tidak memiliki safety guaranty dari Rust menggunakan borrow checker. Deferencing raw pointer is unsafe.
Raw pointer jarang digunakan, biasanya untuk interop dengan FFI.</li>
</ul>
<p>Contoh: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 123;
let p: *const i32 = &amp;a;
assert!(!p.is_null());
let mut b = 123;
let p_mut: *mut i32 = &amp;mut b;
assert!(!p_mut.is_null());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-types"><a class="header" href="#string-types">String Types</a></h1>
<p>Rust memiliki 2 jenis tipe data dasar yang umum digunakan untuk berhubungan dengan <em>string</em>. Yaitu:</p>
<h2 id="reference-string-str"><a class="header" href="#reference-string-str">Reference string (&amp;str)</a></h2>
<p>Reference string yaitu value string yang tidak memiliki <em>owner</em>, dalam artian hanya bisa di-pass sebagai reference. 
String semacam ini bisa dibentuk dengan berbagai cara, diantaranya secara <em>hardcode</em> di kodingan, di-<em>referenced</em> dari data lainnya atau dibentuk dari array u8(utf8). Ketika string jenis ini didapat dari reference owned value, maka reference nya akan valid selama object owner nya valid(tidak out of scope).</p>
<p>Berikut penjelasan beberapa cara string jenis ini muncul:</p>
<ul>
<li><em>Hardcode</em>: cara ini yaitu dengan menuliskan value string secara literal pada saat menulis kode program. String jenis ini bersifat static, yaitu di-<em>compile</em> bersama program ke dalam binary dan exist selama program berjalan.
Contoh: </li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;str = &quot;this is literal string&quot;;
println!(&quot;{}&quot;,s);

let mut s: &amp;str = &quot;lskdmfsdf&quot;;
s = &quot;asdasd&quot;;
println!(&quot;{s}&quot;);
let mut ss: String = s.into();
ss.push('p');
println!(&quot;{ss}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>String jenis ini diketahui ukuran nya pada saat compile time dan hanya bisa di-<em>borrow</em> dalam bentuk reference(&amp;).</p>
<ul>
<li><em>Referenced</em>: cara ini yaitu dengan mengambil reference dari object(owned) <strong>String</strong> di runtime. 
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: String = &quot;this is owned string&quot;.to_string();
let ref_s: &amp;str = s.as_str();
<span class="boring">}</span></code></pre></pre>
<p><code>ref_s</code> valid selama <code>s</code> tidak di <code>drop</code> atau keluar scope. Hal ini karena <code>s.as_str()</code> hanya memberika reference kepada value <code>&amp;str</code> yang ada pada object <code>s</code> sehingga pemilik &amp;str nya adalah <code>s</code>. String jenis ini dialokasikan pada <em>heap memory</em> karena <code>String</code> dialokasikan di <em>heap memory</em>.</p>
<ul>
<li><em>Array u8(utf8)</em>: cara ini dibentuk ketika string di encode kedalam utf8, sehingga value array u8 bisa digunakan untuk membentuk string tsb.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let utf8 = [105, 109, 32, 102, 114, 111, 109, 32, 98, 121, 116, 101, 115];
let s_ref: &amp;str = std::str::from_utf8(&amp;utf8).unwrap();
println!(&quot;{}&quot;,s_ref); // print &quot;this is owned string&quot;
<span class="boring">}</span></code></pre></pre>
<p>String jenis ini dialokasikan di dalam <em>stack memory</em>. 
String jenis ini lebih dianjurkan digunakan ketika kita memiliki string yang hanya <em>read-only</em>.</p>
<h2 id="owned-string-string"><a class="header" href="#owned-string-string">Owned String (String)</a></h2>
<p>String jenis ini merupakan string yang dibentuk pada saat runtime dimana ukurannya tidak diketahui dan bisa berubah-ubah sehingga perlu dialokasikan pada <em>heap memory</em>. String ini sifatnya di-<em>owned</em>, dalam artian memiliki owner yang mana value nya valid selama owner nya tidak out of scope dan tidak di-<em>drop</em>.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let owned_string: String = String::from(&quot;im owned&quot;);
println!(&quot;{}&quot;,owned_string);
<span class="boring">}</span></code></pre></pre>
<p>String di atas di-<em>owned</em> oleh variable <code>owned_string</code>, selama <code>owned_string</code> masih di dalam scope yang sama, maka string valid digunakan. <code>owned_string</code> menjadi tidak valid ketika berpindah kepemilikan seperti di-<em>pass</em> ke dalam suatu fungsi atau berpindah scope <code>{}</code>.
String jenis ini digunakan ketika kita ingin lebih leluasa mengoperasikan suatu string.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<p>Compound types merupakan tipe data yang terdiri dari beberapa tipe data yang dimasukkan ke dalam suatu variable. Tipe data ini bisa berisi tipe primitif, string, struct, tuple, enum atau lainnya.</p>
<h2 id="array-tsize"><a class="header" href="#array-tsize">Array <code>[T;size]</code></a></h2>
<p>Array merupakan tipe data gabungan dari value-value dengan tipe yang sama. Size array bersifat <em>fixed</em> dengan value-value yang diinisialisasi pada saat compile time. Ownership dari array tergantung dari elemen-elemen yang terkandung. Jika mengandung tipe data yang <em>copyable</em> atau <em>reference</em> maka tidak ada ownership tertentu sehingga array tetap valid jika keluar dari scope. Sebaliknya jika elemen terkandung merupakan <em>heap-allocated</em> data, maka array tidak akan valid jika telah keluar dari scope.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array_1 = [1,2,3,4,5];
println!(&quot;{}&quot;, array_1[0]); // print 1
println!(&quot;{}&quot;, array_1[1]); // print 2
println!(&quot;{}&quot;, array_1[2]); // print 3

let array_2: [i32; 5] = [1,2,3,4,5];
println!(&quot;{}&quot;, array_2[0]); // print 1
println!(&quot;{}&quot;, array_2[1]); // print 2
println!(&quot;{}&quot;, array_2[2]); // print 3
<span class="boring">}</span></code></pre></pre>
<h2 id="slice-t"><a class="header" href="#slice-t">Slice <code>&amp;[T]</code></a></h2>
<p>Berbeda dengan array, slice memiliki size yang dinamis dan tidak dideklarasi pada saat <em>compile-time</em>. Slice merupakan tipe data reference yang mereferensikan ke suatu lokasi memori yang mengandung data di dalam slice. Slice bertujuan ketika kita ingin mendefenisikan array dengan jumlah data yang tidak pasti dan bisa berubah ke depannya. Berbeda dengan array yang ownership data tergantung elemen terkandung, Slice merupakan reference type sehingga slice tetap valid di scope manapun.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let slice_1 = &amp;[1,2,3,4,5];
println!(&quot;{}&quot;, slice_1[0]); // print 1
println!(&quot;{}&quot;, slice_1[1]); // print 2
println!(&quot;{}&quot;, slice_1[2]); // print 3

let slice_2: &amp;[i32] = &amp;[1,2,3,4,5];
println!(&quot;{}&quot;, slice_2[0]); // print 1
println!(&quot;{}&quot;, slice_2[1]); // print 2
println!(&quot;{}&quot;, slice_2[2]); // print 3
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algebraic-types"><a class="header" href="#algebraic-types">Algebraic Types</a></h1>
<p>Algebraic Types merupakan tipe data gabungan(<em>compound</em>) yang dibentuk dari kombinasi notasi matematika berupa: <em>AND</em> dan <em>OR</em>.
Rust memiliki 2 jenis <em>Algebraic Types</em> yaitu: <em>Product Type</em> dan <em>Sum Type</em>.</p>
<h2 id="product-type"><a class="header" href="#product-type">Product Type</a></h2>
<p>Tipe ini merupakan tipe data yang bersifat kombinatorik terhadap semua kemungkinan value-value yang ada di dalamnya. Tipe ini menggunakan logika <em>AND</em> untuk membentuknya. Seperti logika <em>AND</em> pada umumnya, semua harus ada atau tidak sama sekali. Hal ini karena jika ada satu value kosong, maka kombinasi dari semua nya menjadi hilang. Kita bisa manganalogikan <em>Product</em> sebagai hasil dari sebuah perkalian, dimana jika ada 1 value saja yang 0, maka semua jadi kosong. Jadi ini adalah tipe yang mengharuskan kita memberi value kepada semua field yang ada dalam tipe ini.</p>
<p>Terdapat 2 jenis Product Type di Rust, yaitu: <code>struct</code> dan <code>tuple</code>. Ketika hendak mengdeklarasikan 2 hal tersebut kita diharuskan mengisi semua field yang ada padanya atau kalau tidak mendapat error.</p>
<h3 id="struct"><a class="header" href="#struct">Struct</a></h3>
<p>Merupakan tipe bentukan yang terdiri dari beberapa fields dengan values dari berbagai macam tipe data.
Deklarasi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Volume {
    height: u8,
    width: u8,
    length: u8,
}
<span class="boring">}</span></code></pre></pre>
<p>Inisialisasi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let volume = Volume {
    height: 12,
    width: 10,
    length: 15,
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika inisialisasi ketiga field harus diisi atau akan error.
Manakah sifat kombinatorik yang dimaksud?, bisa kita lihat pada contoh di atas, setiap field punya tipe u8, dengan begitu ketika dikombinasikan dengan logika <em>AND</em> atau dimultiplikasikan memiliki total kombinasi product yaitu: 256 * 256 * 256 = 16777216 kemungkinan representasi dari tipe <code>Volume</code>.</p>
<h3 id="struct-with-tuple"><a class="header" href="#struct-with-tuple">Struct with Tuple</a></h3>
<p>Deklarasi struct tanpa fields name. Merupakan gabungan struct dan Tuple.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Volume(u8,u8,u8);

let volume = Volume(5,10,20);
println!(&quot;{:?}&quot;,volume);
println!(&quot;{}&quot;,volume.0);
println!(&quot;{}&quot;,volume.1);
println!(&quot;{}&quot;,volume.2);
<span class="boring">}</span></code></pre></pre>
<h2 id="tuple"><a class="header" href="#tuple">Tuple</a></h2>
<p>Merupakan tipe bentukan yang terdiri dari values dari berbagai macam tipe data tanpa deklarasi field.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple_1 = (1, true, 'a');
println!(&quot;{}&quot;,tuple_1.0); // print 1
println!(&quot;{}&quot;,tuple_1.1); // print true
println!(&quot;{}&quot;,tuple_1.2); // print 'a'

let tuple_2: (i32,bool,char) = (1, true, 'a');
println!(&quot;{}&quot;,tuple_2.0); // print 1
println!(&quot;{}&quot;,tuple_2.1); // print true
println!(&quot;{}&quot;,tuple_2.2); // print 'a'

let (tuple_elem_1, tuple_elem_2, tuple_elem_3) = (1, true, 'a');
println!(&quot;{}&quot;,tuple_elem_1); // print 1
println!(&quot;{}&quot;,tuple_elem_2); // print true
println!(&quot;{}&quot;,tuple_elem_3); // print 'a'
<span class="boring">}</span></code></pre></pre>
<h2 id="sum-type"><a class="header" href="#sum-type">Sum Type</a></h2>
<p>Tipe ini kebalikan dari Product Type. Tipe ini menggunakan logika <em>OR</em> dimana cukup 1 value yang dibutuhkan dari semua kemungkinan value. Seperti namanya <em>Sum</em> yang mirip operasi penjumlahan jika ada 1 saja non-null value maka masih akan mendapatkan hasil non-null, e.g. 1+0+0+0 = 1. </p>
<p>Rust memiliki Sum Type berupa <code>enum</code>. Berikut contoh penggunaan enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Day {
    Sun,
    Mon,
    Tue,
    Wed,
    Thu,
    Fri,
    Sat,
}

let day = Day::Fri;
<span class="boring">}</span></code></pre></pre>
<p>Seperti contoh di atas, terdapat 7 hari yang ada, akan tetapi value yang dibutuhkan hanya 1 yaitu salah satu dari value-value yang ada.
Di Rust terdapat 2 <em>Sum Type</em> yang sering digunakan yaitu: <em>Result</em> dan <em>Option</em>. 
<em>Result</em> digunakan untuk operasi-operasi yang mempunyai kemungkinan error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p><em>Option</em> digunakan untuk operasi-operasi yang mempunyai kemungkanan null.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh penggunaan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result: Result&lt;String, String&gt; = Ok(&quot;Success&quot;.to_string());
println!(&quot;{}&quot;, result.unwrap()); // Print &quot;Success&quot;
let result: Result&lt;String, String&gt; = Err(&quot;Failed&quot;.to_string());
println!(&quot;{}&quot;, result.unwrap_err()); // Print &quot;Failed&quot;
<span class="boring">}</span></code></pre></pre>
<h2 id="kombinasi-product-type-dan-sum-type"><a class="header" href="#kombinasi-product-type-dan-sum-type">Kombinasi Product Type dan Sum Type</a></h2>
<p>Kita bisa mengkombinasikan 2 tipe ini untuk menciptakan model data yang lebih kompleks. Bisa dengan memasukkan <em>Product Type</em> ke dalam <em>Sum Type</em>, atau sebaliknya. Salah satu contoh yang sering digunakan adalah ketika kita ingin menerima data json yang memiliki kemungkinan beberapa fields nya kosong/null. </p>
<p>Berikut contohnya:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RequestJson {
    id: i64,
    name: String,
    phone: Option&lt;String&gt;,
}

let request = RequestJson {
    id: 123,
    name: &quot;anu&quot;.to_string(),
    phone: None, // if from json payload this field `null`, then None is given to us.
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh di atas menunjukkan contoh data yang menerima request json dimana field <code>phone</code> bisa <code>null</code> dari json payload.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle2DTuple(i32,i32),
    Rectangle3DTuple(i32,i32,i32),
    Rectangle2DStruct{
        length: i32,
        width: i32,
    },
    Rectangle3DStruct{
        length: i32,
        width: i32,
        height: i32,
    },
}

let shape = Shape::Rectangle2DTuple(10,20);
let shape = Shape::Rectangle3DStruct{
    length: 12,
    width:13,
    height:14,
};
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas kita melihat kombinasi product type dan sum type. Tipe enum <code>Shape</code> memiliki value-value yang dikombinasikan dengan tuple(Rectangle2DTuple &amp; Rectangle3DTuple) dan struct(Rectangle2DStruct &amp; Rectangle3DStruct). Masing-masing varian enum tersebut harus mengisi semua value untuk tuple dan struct masing-masing secara utuh atau deklarasi enum gagal.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>Bahasa yang memiliki <em>Algebraic Types</em> selayaknya juga memiliki fitur <em>Pattern Matching</em>. Hal ini digunakan untuk melakukan pengecekkan tipe, struktur, dan value-value yang terkandung di dalam <em>Algebraic Types</em> tersebut. Rust memiliki feature ini menggunakan <code>match</code>. Setiap enumerasi tipe/value dari match disebut <code>arm</code>.
Pattern matching bersifat <em><strong>exhaustive</strong></em> yaitu semua kemungkinan signature/value harus dienumerasi ke-dalam setiap <em>arms</em> dari value tersebut.
Jika suatu value dengan tipe tertentu memiliki banyak enumerasi value yang ada padanya, tentunya tidak mungkin ditulis semua, selain itu pula kadang kita hanya butuh mengecek sebagian saja dari kemungkinan value yang ada. Untuk ini kita bisa mengabaikan value/signature lain dengan menggunakan <em>wildcard</em> untuk sisa dari value/signature yang tidak kita deklarasikan.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Gender {
    Male
    Female
}

let gender = Gender::Female;
match gender {
    Gender::Male =&gt; println!(&quot;Gender is male&quot;),
    Gender::Female =&gt; println!(&quot;Gender is female&quot;),
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh dengan wildcard:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: u8 = 12;
match num {
    1 =&gt; println!(&quot;one&quot;),
    _ =&gt; panic!(&quot;gone&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas ada kemungkinan 255 value dari num(unsigned 8 bit integer), ketika kita cuma butuh mengecek beberapa kemungkinan value saja dari variable dalam pattern matching, kita cukup menambahkan <code>_</code> pada akhir <em>arm</em> dari pattern matching sehingga kita bisa mangabaikan sisa dari semua kemungkinan enumerasi.</p>
<p><span style="color:red"><em><strong>NOTE Wildcard selalu berada di akhir karena sifat exhaustive pattern matching dari atas ke bawah, sehingga jika kita tidak meletakkan wildcard paling bawah, maka value apapun akan masuk ke dalam <em>arm</em> wildcard sehingga menghasilkan <em>unintended</em> consequence.</strong></em></span></p>
<p><code>match</code> juga sering digunakan untuk mengecek value dari 2 tipe enum <code>Result</code> dan <code>Option</code>, serta men-destrukturalisasi tipe-tipe tersebut dan mengambil value di dalamnya.
Ketika suatu operasi memungkinkan mengembalikan value kosong, maka tipe data yang cocok digunakan adalah <code>Option</code> dengan melakukan pengecekkan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let optional_value = Some(&quot;thing&quot;);
match optional_value {
    Some(thing) =&gt; println!(&quot;there is a {}&quot;, thing), // print &quot;there is a thing&quot;
    None =&gt; println!(&quot;there is nothing&quot;),
}
// akan return &quot;there is a thing&quot;
<span class="boring">}</span></code></pre></pre>
<p>Ketika suatu operasi memungkinkan mengembalikan error, maka tipe data yang cocok digunakan adalah <code>Result</code> dengan melakukan pengecekkan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let error_value = Err(&quot;error&quot;);
match error_value {
    Ok(result) =&gt; println!(&quot;Success with result {}&quot;, result),
    Err(error) =&gt; println!(&quot;failed with error {}&quot;,error) // print &quot;failed with error error&quot;
}
// akan return &quot;failed with error error&quot;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h1>
<p>Compound dan Collection types hampir mirip kecuali Collection type lebih dinamis dan disimpan ke dalam heap memory.</p>
<h2 id="vector-vect"><a class="header" href="#vector-vect">Vector <code>Vec&lt;T&gt;</code></a></h2>
<p>Vector merupakan tipe data seperti list. Perbedaan vector dengan array dan slice adalah vector memiliki ownership terhadap data yang dikandung baik itu tipe data yang bersifat <em>copyable</em>(stack-allocated) atau <em>clonable</em>(heap-allocated). Hal ini menjadikan vector akan invalid ketika berpindah ownership atau keluar dari scope.
Vector memiliki tipe berparameter(<em>generic type</em>) <code>&lt;T&gt;</code> yang merupakan tipe data dari elemen-elemen terkandung.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec_string: Vec&lt;String&gt; = Vec::new();
vec_string.push(&quot;first string&quot;.to_string());
vec_string.push(&quot;second string&quot;.to_string());
vec_string.push(&quot;third string&quot;.to_string());
vec_string.push(&quot;fourth string&quot;.to_string());
println!(&quot;{}&quot;, vec_string); // prints [&quot;first string&quot;, &quot;second string&quot;, &quot;third string&quot;, &quot;fourth string&quot;]

let mut vec_i32 = vec![1,2,3,4];
vec_i32.push(5)
println!(&quot;{:?}&quot;, vec_i32); // [1, 2, 3, 4, 5]
vec_i32.remove(1); // remove element by index and shift elements after it to the left.
println!(&quot;{:?}&quot;, vec_i32); // [1, 3, 4, 5]
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas dapat dilihat terdapat 2 jenis deklarasi vector, yaitu dengan menggunakan inisialisasi <code>Vec::new()</code> atau dengan menggunakan macro <code>vec!</code>. Ketika menggunakan macro, tipe data di-<em>infer</em> secara otomatis oleh compiler. Terlihat bahwa vector harus bersifat <em>mutable</em> agar bisa di ubah(assign/update).</p>
<h2 id="hashmap-hashmapk-v-s--randomstate"><a class="header" href="#hashmap-hashmapk-v-s--randomstate">HashMap <code>HashMap&lt;K, V, S = RandomState&gt;</code></a></h2>
<p>Tipe data map yang memetekan suatu key(K) ke suatu value(V). Berbeda dengan tipe data lainnya yang sudah termasuk ke dalam <em>prelude</em>, hashmap harus diimport terlebih dahulu sebelum digunakan.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map: HashMap&lt;i32, &amp;str&gt; = HashMap::new();
    map.insert(1, &quot;test&quot;);
    println!(&quot;{map:?}&quot;); // {1: &quot;test&quot;}
    map.insert(1, &quot;updated_value&quot;); // if key 1 already existed, then the value will be updated, else will be inserted
    map.insert(2, &quot;test2&quot;);
    map.insert(3, &quot;test3&quot;);
    map.insert(4, &quot;test4&quot;);
    println!(&quot;{map:?}&quot;); // {2: &quot;test2&quot;, 1: &quot;updated_value&quot;, 3: &quot;test3&quot;, 4: &quot;test4&quot;}
    map.remove(&amp;2); 
    println!(&quot;{map:?}&quot;); // {1: &quot;updated_value&quot;, 4: &quot;test4&quot;, 3: &quot;test3&quot;}
    let key_1 = map.get(&amp;1); // `get` will read the value by key's reference returning Option&lt;V&gt;. If not exist will return `None`.
    println!(&quot;{:?}&quot;, key_1); // Some(&quot;updated_value&quot;)

    let mut new_map: HashMap&lt;&amp;str, &amp;str&gt; = HashMap::from(
        [
            (&quot;key_1&quot;,&quot;value_1&quot;),
            (&quot;key_2&quot;,&quot;value_2&quot;),
            (&quot;key_3&quot;,&quot;value_3&quot;),
            (&quot;key_4&quot;,&quot;value_4&quot;),
        ]
    ); // initialize map with a known keys and values using array of tuples (K,V)
    println!(&quot;{new_map:?}&quot;) // {&quot;key_3&quot;: &quot;value_3&quot;, &quot;key_4&quot;: &quot;value_4&quot;, &quot;key_2&quot;: &quot;value_2&quot;, &quot;key_1&quot;: &quot;value_1&quot;}
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Kita akan membahas beberapa control flow yang ada pada Rust seperti <code>if</code> <code>else</code>, loops dan match.</p>
<h2 id="ifelse"><a class="header" href="#ifelse">If/Else</a></h2>
<p>Percabangan pada kode.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// single if
let a = 1;
if a == 1 {
    println!(&quot;true&quot;);
}

// if and else
if a == 2 {
    println!(&quot;True&quot;);
} else {
    println!(&quot;False&quot;);
}

// if, else if, and else
let a = 3;
if a == 2 {
    println!(&quot;True&quot;);
} else if a == 3 {
    println!(&quot;True again&quot;);
} else {
    println!(&quot;False&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Karena if/else adalah expression maka kita bisa return value ke suatu variable lewat if/else.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 5;
let f = if a % 2 == 0 {
    String::from(&quot;a: {a} is even&quot;)
} else {
    String::from(&quot;a: {a} is odd&quot;)
};
println!(&quot;--&gt; {f:?}&quot;); // &quot;a: 5 is odd&quot;
<span class="boring">}</span></code></pre></pre>
<h2 id="loop"><a class="header" href="#loop">Loop</a></h2>
<p>Infinite loop.
Exit loop using <code>break</code>.
Continue to the next loop before finishing current loop using <code>continue</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut c = 0;
loop {
    std::thread::sleep(std::time::Duration::from_millis(500));
    if c == 10 {
        println!(&quot;Done&quot;);
        break;
    }
    if c % 2 == 0 {
        println!(&quot;c: {c} even number&quot;);
        c += 1;
        continue;
    } else if c % 2 != 0 {
        println!(&quot;c: {c} odd number&quot;);
        c += 1;
        continue;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Kita bisa menggunakan <code>break</code> untuk menghentikan loop dan mengembalikan value ke variable dengan meletakkan expression setelah <code>break</code>;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut g = 0;
let ret = loop {
    g += 1;
    if g == 10 {
        break g * 50; // 500
    }
};
println!(&quot;---&gt; ret: {ret}&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="loop-with-labels"><a class="header" href="#loop-with-labels">Loop with labels</a></h2>
<p>Rust memiliki semacam konsep <code>goto</code> yang bisa digunakan untuk <code>break</code> atau <code>continue</code> loop kesuatu tempat yang telah diberi label menggunakan lifetime <code>'label</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut d = 0;
'outer: loop {
    d += 1;
    'inner: loop {
        std::thread::sleep(std::time::Duration::from_millis(500));
        if d == 10 {
            break 'outer;
        }
        if d % 2 == 0 {
            println!(&quot;d: {d} even number&quot;);
            continue 'outer;
        } else {
            println!(&quot;d: {d} odd number&quot;);
            d += 1;
            continue; // no label means continue current label ('inner)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<p>Loop berjalan selama kondisi terpenuhi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 0;
while a &lt; 10 {
    println!(&quot;while loop: {a}&quot;);
    a += 1;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="for-loop"><a class="header" href="#for-loop">for loop</a></h2>
<p>Melakukan iterasi terhadap tipe data yang mengimplementasi trait <code>Iterator</code>. Biasanya data tersebut berupa data compunds atau collections seperti array, slices, vector, map dan lainnya. Semua tipe-tipe data tersebut sudah implement trait <code>Iterator</code> di dalam Rust secara built-in.
Rust memiliki <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html">range expression</a> sebagai ekspresi ketika melakukan looping data. 
Berikut 2 contoh:</p>
<ul>
<li>Loop excluding last index:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// akan melakukan print dari 0 sampai 9
for i in 0..10 {
  println!(&quot;{i}&quot;);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>Loop including last index:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// akan melakukan print dari 0 sampai 10
for i in 0..=10 {
  println!(&quot;{i}&quot;);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>Ekspresi tersebut sudah mengimplementasikan Iterator Trait menggunakan tipe range dari <a href="https://doc.rust-lang.org/stable/std/ops/#structs">ops</a>.</p>
<p>Selain menggunakan expression di atas, kita juga bisa menggunakan tipe data lain yang juga sudah implements Trait Iterator. Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// iterate over slice
let data = &amp;[1,2,3,4,5];
for x in data {
    println!(&quot;data: {x}&quot;);
}

// iterate over vector
let data = vec![1,2,3,4,5];
for x in data {
    println!(&quot;data: {x}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Terdapat 3 methods yang menjadi idiom dan di-implement hampir semua tipe data di dalam Rust untuk menghasilkan data <code>Iterator</code>, yaitu:</p>
<ul>
<li><code>into_iter()</code>: Take and own each items in the data. Default jika tidak dideclare pada saat looping.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // into_iter()
  let data1 = [1, 2, 3, 4, 5];
  println!(&quot;into_iter():&quot;);
  /**
  * Since data type is array and elements are primitive types(i32),
  * Using into_iter() on it will only copy it since no moving required.
  * Hence you can still call data after these 2 iterator since &quot;move&quot; mechanism for copy data(stack allocated) is only &quot;copy&quot;.
  */
  // `into_iter()` will be applied by default by compiler if not specified
  for x in data1 {
      println!(&quot;{x}&quot;);
  }
  // kode di atas sama dengan
  for x in data1.into_iter() {
      println!(&quot;{x}&quot;);
  }

  // getting index and value
  for (i, x) in data1.into_iter().enumerate() {
      println!(&quot;{i}:{x}&quot;);
  }
  println!(&quot;data: {data1:?}&quot;);

  /**
  * if you use into_iter() to data with borrowed type(reference), then into_iter() cannot own the elements since its parent is referenced/borrowed.
  * Hence in each iterator you only see the element as &amp;i32.
  */
  let data1: &amp;[i32] = &amp;[1, 2, 3, 4, 5];
  for x in data1.into_iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;{data1:?}&quot;);

  let data1 = &amp;[1, 2, 3, 4, 5];
  for x in data1.into_iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;{data1:?}&quot;);

  /**
  * data1 is vector type which is owned type. So into_iter() will make it moved.
  */
  let data1 = vec![1, 2, 3, 4, 5];
  for x in data1 {
      // implicitly and defaultly implement into_iter()
      println!(&quot;{}&quot;, x);
  }
  // println!(&quot;data: {data1:?}&quot;); //// won't work because data already moved by into_iter()
  let data1_1 = vec![1, 2, 3, 4, 5];
  for x in data1_1.into_iter().enumerate() {
      println!(&quot;{} {}&quot;, x.0, x.1);
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li><code>iter()</code>: Borrow and make reference to each items immutably in the data.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // iter()
  let data2 = [1, 2, 3, 4, 5];
  println!(&quot;iter():&quot;);
  /**
   * Data type is array and calling iter() method in interation making it borrow the items inside array `&amp;i32`.
   * No copy happen since it's referencing data from array.
   */
  for x in data2.iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;data: {data2:?}&quot;);

  // getting index and value
  for x in data2.iter().enumerate() {
      println!(&quot;{} {}&quot;, x.0, x.1);
  }

  /**
   * vector is owned type but iter() only borrow the items inside so can be used after iteration.
   */
  let data2 = vec![1, 2, 3, 4, 5];
  for x in data2.iter() {
      println!(&quot;{x}&quot;);
  }
  println!(&quot;data: {data2:?}&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
<li><code>iter_mut()</code>: Borrow and make reference to each items mutably in the data.
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // iter_mut()
  let mut data3 = [1, 2, 3, 4, 5];
  /**
   * iter_mut() will borrow each items as mutable reference if the source data is mutable.
   */
  for x in data3.iter_mut() {
      *x = *x * 2;
  }
  println!(&quot;data: {data3:?}&quot;);

  let mut data3 = vec![1, 2, 3, 4, 5];
  /**
   * When you iter_mut and enumerate the data, you can only mutate the data's value, not index.
   * Also it won't take any ownership since it's borrowed/referenced.
   */
  for (i, x) in data3.iter_mut().enumerate() {
      *x = *x * 5;
      println!(&quot;{i} {x}&quot;);
  }
  println!(&quot;data: {data3:#?}&quot;);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="match"><a class="header" href="#match">match</a></h2>
<p>Match merupakan feature pada rust untuk melakukan pattern matching terhadap value dan/atau tipe data, khususnya sum type(enum). 
Bersifat <strong>exhaustive</strong> karena semua kemungkinan value harus dideklarasi, atau bisa diignore menggunakan keyword wildcard <code>_</code>.
Setiap value yang mungkin matched disebut sebagai <em>arm</em>.
Arm wildcard <code>_</code> <strong>HARUS</strong> ditaruh paling bawah karena sifat exhaustive dan menemukan kemungkinan pertama pada match akan menghilangkan purpose dari pattern matching itu sendiri. Match akan melakukan pengecekkan dari atas kebawah, sehingga wildcard butuh ditaruh paling bawah.</p>
<ul>
<li>Match against single value:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 19;
println!(&quot;Tell me about {}&quot;, number);
/**
 * If we want to match against i32, 
 * there'll be 2147483647 possible arms that we have to specify inside match.
 * This is impossible to write by hand,
 * most of the time you only need certain values to be checked against,
 * hence you can use `_` to handle the rest of the possible arms.
 */
match number {
    // Match a single value
    1 =&gt; println!(&quot;One!&quot;),
    // Match several values
    2 | 3 | 5 | 7 | 11 | 13 =&gt; println!(&quot;This is a prime&quot;),
    // Match an inclusive range
    13..=19 =&gt; println!(&quot;A teen&quot;),
    // Handle the rest of cases
    _ =&gt; println!(&quot;SUDAH TUA!!!!&quot;),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Match against tuple:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple = (1, 2, 3);
match tuple {
    (2, y, z) =&gt; println!(&quot;1st arm&quot;), // invalidated because first tuple element must be 1 in order to match.
    (x, 5, z) =&gt; println!(&quot;2nd arm&quot;), // invalidated because second element must be 2 in order to match.
    (x, y, 3) =&gt; println!(&quot;3rd arm&quot;), // validated because 3rd matched, 1st and 2nd arm only fetched as variable(can be anything from the tuple itself).
    _ =&gt; println!(&quot;404&quot;),
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Match against array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// from https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_slice.html
  // Try changing the values in the array, or make it a slice!
  let array = [1, -2, 6];

  match array {
      // Binds the second and the third elements to the respective variables
      [0, second, third] =&gt; println!(&quot;array[0] = 0, array[1] = {}, array[2] = {}&quot;, second, third),

      // Single values can be ignored with _
      [1, _, third] =&gt; println!(
          &quot;array[0] = 1, array[2] = {} and array[1] was ignored&quot;,
          third
      ),

      // You can also bind some and ignore the rest
      [-1, second, ..] =&gt; println!(
          &quot;array[0] = -1, array[1] = {} and all the other ones were ignored&quot;,
          second
      ),
      // The code below would not compile
      // [-1, second] =&gt; ...

      // Or store them in another array/slice (the type depends on
      // that of the value that is being matched against)
      [3, second, tail @ ..] =&gt; println!(
          &quot;array[0] = 3, array[1] = {} and the other elements were {:?}&quot;,
          second, tail
      ),

      // Combining these patterns, we can, for example, bind the first and
      // last values, and store the rest of them in a single array
      [first, middle @ .., last] =&gt; println!(
          &quot;array[0] = {}, middle = {:?}, array[2] = {}&quot;,
          first, middle, last
      ),
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Match against enum</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `allow` required to silence warnings because only
  // one variant is used.
  #[allow(dead_code)]
  enum Color {
      // These 3 are specified solely by their name.
      Red,
      Blue,
      Green,
      // These likewise tie `u32` tuples to different names: color models.
      RGB(u32, u32, u32),
      HSV(u32, u32, u32),
      HSL(u32, u32, u32),
      CMY(u32, u32, u32),
      CMYK(u32, u32, u32, u32),
  }

  let color = Color::RGB(122, 17, 40);
  // TODO ^ Try different variants for `color`

  println!(&quot;What color is it?&quot;);
  // An `enum` can be destructured using a `match`.
  match color {
      Color::Red =&gt; println!(&quot;The color is Red!&quot;),
      Color::Blue =&gt; println!(&quot;The color is Blue!&quot;),
      Color::Green =&gt; println!(&quot;The color is Green!&quot;),
      Color::RGB(r, g, b) =&gt; println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
      Color::HSV(h, s, v) =&gt; println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
      Color::HSL(h, s, l) =&gt; println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
      Color::CMY(c, m, y) =&gt; println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
      Color::CMYK(c, m, y, k) =&gt; println!(
          &quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
          c, m, y, k
      ),
      // Don't need another arm because all variants have been examined
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Match against reference and pointer</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assign a reference of type `i32`. The `&amp;` signifies there
  // is a reference being assigned.
  let reference = &amp;4;

  match reference {
      val =&gt; println!(&quot;value: {val:?}&quot;),
  }
  match reference {
      &amp;4 =&gt; println!(&quot;reference of four&quot;),
      _ =&gt; println!(&quot;other&quot;),
  }
  match reference {
      4 =&gt; println!(&quot;value of four&quot;),
      _ =&gt; println!(&quot;other&quot;),
  }
  match reference {
      // If `reference` is pattern matched against `&amp;val`, it results
      // in a comparison like:
      // `&amp;i32`
      // `&amp;val`
      // ^ We see that if the matching `&amp;`s are dropped, then the `i32`
      // should be assigned to `val`.
      &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
  }

  // To avoid the `&amp;`, you dereference before matching.
  match *reference {
      val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
  }

  // What if you don't start with a reference? `reference` was a `&amp;`
  // because the right side was already a reference. This is not
  // a reference because the right side is not one.
  let _not_a_reference = 3;

  // Rust provides `ref` for exactly this purpose. It modifies the
  // assignment so that a reference is created for the element; this
  // reference is assigned.
  let ref _is_a_reference = 3;

  // Accordingly, by defining 2 values without references, references
  // can be retrieved via `ref` and `ref mut`.
  let value = 5;
  let mut mut_value = 6;

  // Use `ref` keyword to create a reference.
  match value {
      ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
  }

  // Use `ref mut` similarly.
  match mut_value {
      ref mut m =&gt; {
          // Got a reference. Gotta dereference it before we can
          // add anything to it.
          *m += 10;
          println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
      }
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Match against struct</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
      x: (u32, u32),
      y: u32,
  }

  // Try changing the values in the struct to see what happens
  let foo = Foo { x: (1, 2), y: 3 };

  match foo {
      Foo { x: (1, b), y } =&gt; println!(&quot;First of x is 1, b = {},  y = {} &quot;, b, y),

      // you can destructure structs and rename the variables,
      // the order is not important
      Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),

      // and you can also ignore some variables:
      Foo { y, .. } =&gt; println!(&quot;y = {}, we don't care about x&quot;, y),
      // this will give an error: pattern does not mention field `x`
      //Foo { y } =&gt; println!(&quot;y = {}&quot;, y),
  }
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="match-with-guards"><a class="header" href="#match-with-guards">match with guards</a></h2>
<p>Ketika kita ingin menambahkan kondisi terhadap matching arms.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// from: https://doc.rust-lang.org/rust-by-example/flow_control/match/guard.html
    enum Temperature {
        Celsius(i32),
        Fahrenheit(i32),
    }

    let temperature = Temperature::Celsius(35);

    match temperature {
        // guard harus ditaruh lebih awal dibanding tanpa guard karena lebih spesifik.
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        // The `if condition` part ^ is a guard
        Temperature::Celsius(t) =&gt; println!(&quot;{}C is below 30 Celsius&quot;, t),

        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
    }

    match temperature {
        // guard harus ditaruh lebih awal dibanding tanpa guard karena lebih spesifik.
        Temperature::Celsius(t) if t &gt; 30 =&gt; println!(&quot;{}C is above 30 Celsius&quot;, t),
        // The `if condition` part ^ is a guard
        Temperature::Celsius(20) =&gt; println!(&quot;C is below 30 Celsius&quot;),

        Temperature::Fahrenheit(t) if t &gt; 86 =&gt; println!(&quot;{}F is above 86 Fahrenheit&quot;, t),
        Temperature::Fahrenheit(t) =&gt; println!(&quot;{}F is below 86 Fahrenheit&quot;, t),
        _ =&gt; println!(&quot;404&quot;), // wildcard dibutuhkan karena arm ke-dua memiliki value langsung yang menghilangkan sifat exhautiveness dari arms.
    }

    let number: i8 = 4;
    match number {
        i if i == 0 =&gt; println!(&quot;Zero&quot;),
        i if i &gt; 0 =&gt; println!(&quot;Greater than zero&quot;),
        i if i &lt; 0 =&gt; println!(&quot;Lesser than zero&quot;),
        _ =&gt; println!(&quot;404&quot;), // wildcard tetap harus ada karena guards tidak memvalidasi sifat exhaustive dari arms.
    }

    let number: i8 = 4;
    match number {
        i if i == 0 =&gt; println!(&quot;Zero&quot;),
        i if i &gt; 0 =&gt; println!(&quot;Greater than zero&quot;),
        i if i &lt; 0 =&gt; println!(&quot;Lesser than zero&quot;),
        i =&gt; println!(&quot;{i}&quot;), 
        // wildcard tidak dibutuhkan karena exhaustiveness sudah di-achieve oleh arm `i =&gt; println!(&quot;{i}&quot;)` karena sudah nge-cover apa saja.
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="match-with-binding"><a class="header" href="#match-with-binding">match with binding</a></h2>
<p>Melakukan match dengan melakukan <em>binding</em> suatu variable ke kemungkinan-kemungkinan values yang tersedia.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// from: https://doc.rust-lang.org/rust-by-example/flow_control/match/binding.html
// A function `age` which returns a `u32`.
    fn age() -&gt; u32 {
        15
    }

    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I haven't celebrated my first birthday yet&quot;),
        // Could `match` 1 ..= 12 directly but then what age
        // would the child be? Instead, bind to `n` for the
        // sequence of 1 ..= 12. Now the age can be reported.
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // Nothing bound. Return the result.
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }


    fn some_number() -&gt; Option&lt;u32&gt; {
        Some(42)
    }
    
    match some_number() {
        // Got `Some` variant, match if its value, bound to `n`,
        // is equal to 42.
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),
        // Match any other number.
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),
        // Match anything else (`None` variant).
        _            =&gt; (),
    }
<span class="boring">}</span></code></pre></pre>
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<p>Digunakan ketika:</p>
<ul>
<li>Mengecek 1 kemungkinan value dari sebuah variable dengan meng-assign value ke dalam variable baru untuk digunakan selanjutnya</li>
<li>Me-destructure 1 variable  untuk hanya 1 type/value, tanpa harus melalui pattern matching.
Contoh:
Ketika ingin memeriksa sebuah enum, jika menggunakan match:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(5);
match s {
    Some(n) =&gt; println!(&quot;{n:?}&quot;),
    _ =&gt; panic!(&quot;panic&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Kita harus mematuhi sifat exhaustiveness dari pattern matching, padahal kita hanya butuh 1 kemungkinan value. </p>
<p>Alternative lain yang lebih simple adalah menggunakan <code>if let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(5);
if let Some(n) = s {
    println!(&quot;{n}&quot;);
}
if let Some(3) = s {
    println!(&quot;matched!&quot;);
} else {
    println!(&quot;not matched!&quot;);
}

if let n = s {
    println!(&quot;{:#?}&quot;, n);
}

struct A {
    pub a: i32,
    pub b: String,
}

let astruct = A {
        a: 123,
        b: String::from(&quot;anu&quot;),
    };
let bb = String::from(&quot;anu&quot;);
if let A {
    a: 123, 
    b: bb,
} = astruct {
    println!(&quot;matched$$&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="while-let"><a class="header" href="#while-let">while let</a></h2>
<p>Sama seperti <code>if let</code>, hanya saja menggunakan loop <code>while</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = Some(5);
while let Some(n) = a {
    a = Some(n+1);
    if n &gt; 10 {
        a = None;
    }
    println!(&quot;$&quot;);
    std::thread::sleep(std::time::Duration::from_millis(loop_duration));
}
println!(&quot;DONE while let&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership--borrowing"><a class="header" href="#ownership--borrowing">Ownership &amp; Borrowing</a></h1>
<p>Sebelum kita membahas tentang <em>Ownership</em> dan <em>Borrowing</em>, kita akan membahas terlebih dahulu tentang dua jenis memori yaitu <em>Stack</em> dan <em>Heap</em>:</p>
<ul>
<li><em>Stack</em>: adalah memori bersifat LIFO(<em>Last In First Out</em>) merupakan memori yang digunakan tempat menyimpan function frame(function stack frame) yang merupakan semua intruksi-intruksi pada suatu fungsi. Selain itu juga menyimpan tipe data primitif dan pointer address. Data yang dialokasi pada <em>stack</em> dapat diketahui size-nya pada saat compile time dan fixed in size selama program berjalan. Access cepat dan semua memori di-release ketika selesai digunakan(e.g function return/exit).</li>
<li><em>Heap</em>: adalah memori yang lebih kompleks dari stack. Memori ini digunakan untuk data yang tidak diketahui sizenya secara pasti pada saat compile time, dan bisa berubah-ubah size nya selama program berjalan. Memori ini butuh dynamic allocation pada saat runtime sehingga memiliki <em>overhead</em> dan butuh di-<em>deallocate</em> ketika sudah tidak digunakan. Di dalam Rust, proses de-<em>allocate</em> ini disebut dengan <em>Drop</em>.</li>
</ul>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Ownership merupakan hal unik pada Rust yang membuat rust mampu manage memory tanpa memiliki <em>Garbage Collector</em> serta tanpa manual memory management seperti <em>alloc/free</em>. Ownership memiliki 3 aturan:</p>
<ul>
<li><em>Each value in Rust has an owner.</em></li>
<li><em>There can only be one owner at a time.</em></li>
<li><em>When the owner goes out of scope, the value will be dropped.</em></li>
</ul>
<p>Owner merupakan suatu variable yang memiliki sebuah value. Owner ini memiliki scope. Jika owner keluar dari scopenya, maka akan di-drop(released from memory).
Selain <em>drop</em>, ownership bisa berpindah tangan atau disebut dengan <em>move</em>, yaitu ketika owner masuk scope baru, sehingga owner tersebut tidak bisa digunakan di scope yang sama lagi.</p>
<p>Tipe data yang sering memiliki ownership adalah yang biasanya butuh alokasi <em>heap memory</em>, tidak fixed in size dan tidak diketahu size nya pada saat compile time.</p>
<p>Tipe data yang memiliki ownership terhadap valuenya adalah tipe data selain primitif.</p>
<p>Di dalam Rust terdapat 2 jenis trait yang berkaitan dengan <em>scope</em> variable:</p>
<ul>
<li><em>Copy</em>: Semua tipe data primitif sudah meng-implementasikan <em>copy</em> secara implisit. Trait ini memungkinkan data di-pass atau keluar scope tanpa khawatir kehilangan ownership, Karena semua data tersebut memiliki struktur memori sederhana sehingga copy data terjadi dengan sangat cepat ketika keluar/berpindah scope.</li>
<li><em>Clone</em>: Tipe data selain primitif atau yang tidak meng-implementasi <em>copy</em> secara implisit, harus implement <em>clone</em> secara eksplisit. Jika data keluar/pindah scope, maka <em>ownership</em> akan di-drop/pindah. Tipe data yang <em>clonable</em> biasanya dialokasi ke dalam <em>heap memory</em>, sehingga harus melakukan <em>deep copy</em> terhadap struktur datanya.</li>
</ul>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>Scope adalah segment kode yang menandai batas ownership suatu data yang di-<em>owned</em>. Seperti dibahas di atas, terdapat dua mekanisme yang berkaitan dengan variable yang di-<em>owned</em> yaitu <em>drop</em> atau <em>move</em>. Dua jenis scope yang ada pada Rust yaitu <em>curly brackets</em>(drop) dan <em>functions/methods arguments</em>(move).</p>
<ul>
<li>Contoh drop:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let s = String::from(&quot;string value&quot;);
        // string s will be dropped here at the end of the scope
    } // this curly bracket mark the end of s owning the String value so be dropped.
}</code></pre></pre>
<p><em>Drop</em> merupakan sebuah trait yang hampir semua tipe <em>owned</em>/<em>heap allocated</em> sudah implement secara implisit. Compiler <em>rustc</em> akan meng-<em>embed</em> drop function untuk data terkait di setiap end of scope.</p>
<ul>
<li>Contoh move:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hooh&quot;);
    function(s);
    println!(&quot;{}&quot;, &amp;s);
    println!(&quot;{}&quot;, s);
}

fn function(s: String) {} </code></pre></pre>
<p>Pada contoh di atas, variable <code>s</code> sudah berpindah scope dari <code>main</code> ke scope fungsi <code>function</code> sehingga <code>s</code> tidak bisa lagi digunakan setelah <code>function(s)</code>.
<em>Move</em> hanya terjadi pada tipe data yang bersifat <em>clonable</em> atau implement trait <code>Clone</code>. Tipe-tipe data ini biasanya dialokasi pada heap, contoh seperti di atas adalah <code>String</code>. Cara memanfaatkan data <em>clonable</em> setelah move terjadi adalah dengan memanggil method dari trait <em>Clone</em> itu sendiri yaitu <code>clone</code>. Sehingga code di atas menjadi:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hooh&quot;);
    function(s.clone());
    println!(&quot;{}&quot;, &amp;s);
    println!(&quot;{}&quot;, s);
}

fn function(s: String) {} </code></pre></pre>
<p>Sehingga <code>s</code> masih bisa digunakan setelah <code>function</code>, karena value dari <code>s</code> di-clone(eksplisit copy) ke dalam parameter <code>function</code>.
Clone melakukan <em>deep copy</em> untuk menyalin semua data yang ada ke memory baru, sehingga ini memiliki cost yang jauh lebih besar ketimbang <em>copy</em> biasa. Hal ini karena kebanyakan <em>copy</em> terjadi pada stack memory atau data dengan tipe sederhana(primitif) sehingga copy dan alokasi baru dapat dengan sangat cepat dan mudah. Untuk Clone kebanyakan data merupakan <em>heap allocated</em> sehingga butuh clone semua bentuk struktur data yang arbitrary dan mencari segment memory baru untuk alokasi baru. 
Untuk menghindari <em>overhead</em> ini, ada cara lain untuk mem-passing variable, yaitu dengan cara <em>Borrowing</em>.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Borrow adalah ketika kita me-<em>reference</em> suatu data, disebut juga dengan <em>reference type</em>. Berbeda dengan <em>Owned</em> data, <em>borrowed</em> data tidak memindahkan ownership ketika memasukin scope baru. <em>Borrowed</em> data bisa berpindah2 scope bahkan ke dalam parameter fungsi lain sehingga data masih bisa digunakan di scope yang sama. 
Reference type berbeda dengan pointer type, dimana:</p>
<ul>
<li>Reference type: must not null, always valid state and value, can be operated like normal variable.</li>
<li>Pointer type: can be null, unsafe, can cause program crash if dereferencing null pointer, butuh dereferencing saat ingin menggunakan valuenya.
Di dalam rust, kode normal sehari2 kebanyakan menggunakan reference type, jarang kita membutuhkan pointer karena konsep safety pada rust menghindari null pointer exception. Ada pengecualian untuk hal seperti butuh fleksibilitas management memory sehingga butuh pointer dan ini hanya bisa dilakukan dalam context <em>unsafe</em> pada Rust.</li>
</ul>
<p>Semua tipe di dalam Rust bisa di-<em>borrowed</em> dengan cara menambah <em>ampersand</em>(&amp;) di awal tipe seperti <code>&amp;i32</code>. Ketika suatu tipe data di-<em>borrowed</em> tidak terjadi copy terhadap memory, akan tetapi <em>borrower</em> mereferensikan memory lokasi si data.</p>
<p>Borrow memiliki beberapa rules diantaranya:</p>
<ul>
<li>There can be <strong>more</strong> than one immutable borrow</li>
<li>There can be <strong>only</strong> one mutable borrow</li>
<li>Reference must always be valid</li>
</ul>
<p>Contoh immutable borrowing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn borrow() {
    let anu = &quot;anu&quot;;
    {
        println!(&quot;{}&quot;, anu); // move scope
    }

    println!(&quot;{}&quot;, anu); // still valid here
    accept_borrow(anu);
    println!(&quot;{}&quot;, anu); // still valid here
}

fn accept_borrow(s: &amp;str) { // this function borrow s as reference of string(&amp;str)
    println!(&quot;{}&quot;, s);
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh mutable borrowing:
Failed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mutable_borrow() {
    let mut a = 123;

    let b = &amp;mut a; // first mutable borrow
    let c = &amp;mut a; // second mutable borrow

    {
        let d = &amp;mut a; // third mutable borrow
    }

    println!(&quot;{}&quot;, b);
    println!(&quot;{}&quot;, c);
}
<span class="boring">}</span></code></pre></pre>
<p>Pencegahan multiple mutable reference ini bertujuan untuk menghindari kemungkinan <em>data race</em>. Data race adalah ketika suatu data di lokasi memori yang sama diakses oleh lebih dari 1 reference/pointer baik dalam 1 thread yang sama atau dalam thread yang berbeda. Dalam thread berbeda sangat jelas kemungkinan data race karena kita masing-masing thread tersebut bisa berjalan secara <em>concurrent</em> yang menyebabkan <em>undefined behaviour</em> pada data yang diaccess dengan minimal salah 1 nya adalah proses <em>write</em>/<em>modify</em> data. Selain itu pengaksessan mutable dalam 1 thread juga bisa bermasalah karena masing2 reference bisa memiliki waktu proses yang berbeda terhadap data yang diakses, sehingga tidak ada sinkronisasi data yang pasti sehingga menyebabkan <em>undefined behaviour</em>.</p>
<p><em>Immutable borrowing</em> digunakan ketika data yang di-passing tidak membutuhkan ownership dan berpindah ke berbagai thread.
<em>mutable borrowing</em> harus digunakan dengan mekanisme <em>mutex</em> untuk menjaga konsistensi data agar tidak terjadi <em>undefined behaviour</em>.</p>
<p>Borrowing dapat dengan mudah dilakukan ketika mem-<em>passing</em> data antar stack-frame fungsi2 yang <em>nested</em> ke dalam. Akan tetapi ketika ingin me-<em>return</em> data reference, hal ini tidak bisa dilakukan, apalagi pemilik asli data yang di-<em>borrowed</em> berada dalam stack-frame tersebut sehingga ketika data reference di-return, akan terjadi <em>use-after-free</em> atau semacam <em>dangling pointer</em> karena stack-frame sumber data reference tersebut sudah di-release dari stack memory. Bahasa-bahasa lain seperti Go menerapkan konsep <em>escape analysis</em> untuk menentukan lokasi data-data reference/pointer ketika keluar dari scope fungsi(stackframe). Dalam Go, ketika keluar dari stack-frame sedangkan data yang di-<em>pointed</em>/di-<em>referenced</em> ada di dalam stack frame tersebut, maka data tersebut dilarikan(<em>escape</em>) ke <em>heap memory</em> dan akan di-release oleh GC. Rust memiliki pendekatan lain untuk hal ini, yaitu dengan menggunakan <em>lifetime</em> yang akan kita bahas pada pembahasan selanjutnya.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-item"><a class="header" href="#associated-item">Associated Item</a></h1>
<p>Associated Items merupakan tipe data yang memiliki kaitan dengan tipe, constants, fungsi, atau method. Hal ini juga bisa digunakan sebagai salah satu metode untuk <em>&quot;namespacing&quot;</em> di dalam Rust.</p>
<p>Associated items bisa dilakukan di dalam traits atau type implementations.</p>
<p>Associated items secara keseluruhan bisa dibagi kedalam 3 jenis:</p>
<ul>
<li>Associated functions and methods</li>
<li>Associated types</li>
<li>Associated constants</li>
</ul>
<h2 id="associated-functions-and-methods"><a class="header" href="#associated-functions-and-methods">Associated functions and methods</a></h2>
<p>Fungsi dan method yang berhubungan dengan suatu type. Jenis deklarasi seperti ini disebut <em>inherent functions/methods</em>. Type-type yang bisa mendeklarasi <em>inherent functions/methods</em> adalah non-primitive types dan harus dideklarasikan di dalam 1 crate yang sama dengan type bersangkutan. Jika selain dari itu, gunakan trait.</p>
<h3 id="associated-functions--methods"><a class="header" href="#associated-functions--methods">Associated Functions &amp; Methods</a></h3>
<p>Di Rust, perbedaan antara <strong>function</strong> dan <strong>method</strong> adalah:</p>
<ul>
<li><strong>function</strong>: <em>standalone</em>, <em>pure</em> dan tidak memiliki objek yang berkait, bisa dideklarasikan tanpa <code>impl</code>.</li>
<li><strong>method</strong>: berkait dengan suatu objek(self) dengan berbagai macam tipe(struct, enum, dll), hanya bisa dideklarasikan dengan <code>impl</code>.</li>
</ul>
<p>Contoh function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// free function
fn function_name() {
    // body
}

struct Type;

// associated function
impl Type {
    fn function_name() {

    }
}

// cara memanggil associated function
Type::function_name();
<span class="boring">}</span></code></pre></pre>
<p>Contoh method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type {
    id: i32;
}

impl Type {
    // self merupakan parameter sekaligus argumen yang merepresentasikan tipe terkait dengan method.
    fn method_name(&amp;self) {
        println!(&quot;{}&quot;, self.id);
    }
}

// cara memanggil method
let t = Type {
    id: 123,
}
t.method_name()
<span class="boring">}</span></code></pre></pre>
<h3 id="self-type-pada-method"><a class="header" href="#self-type-pada-method">Self type pada method</a></h3>
<p>Setiap method harus diawali oleh parameter sekaligus argumen pertama berupa <code>self</code>. Terdapat beberapa jenis/bentuk tipe <code>self</code> yaitu:</p>
<div class="table-wrapper"><table><thead><tr><th>1st form</th><th>ref with lifetime</th><th>Short form(with lifetime)</th></tr></thead><tbody>
<tr><td>self: Self</td><td>self</td><td></td></tr>
<tr><td>self: &amp;Self</td><td>self: &amp;'a Self</td><td>&amp;'a self</td></tr>
<tr><td>self: mut Self</td><td>mut self</td><td></td></tr>
<tr><td>self: &amp;mut Self</td><td>self: &amp;'a mut Self</td><td>&amp;'a mut self</td></tr>
<tr><td>self: Box<Self></td><td></td><td></td></tr>
<tr><td>self: Rc<Self></td><td></td><td></td></tr>
<tr><td>self: Arc<Self></td><td></td><td></td></tr>
<tr><td>self: Pin&lt;&amp;Self&gt;</td><td></td><td></td></tr>
<tr><td>self: <code>&lt;MyType as MyTrait&gt;::associated_type</code></td><td></td><td></td></tr>
</tbody></table>
</div>
<p><em>Note: untuk <code>self: &lt;MyType as MyTrait&gt;::associated_type</code>, <code>associated_type</code> harus refer ke tipe implementor, tidak bisa ke tipe lainnya.</em></p>
<p>Contoh inherent functions/methods pada struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyStruct {
    a: i32,
    b: String,
}

impl MyStruct {
    pub fn function1() -&gt; i32 {
        123
    }

    pub fn function2(&amp;self) -&gt; String {
        String::from(&quot;anu&quot;)
    }

    fn function3() -&gt; f32 {
        234_f32
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh memanggil inherent functions/methods pada struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp = MyStruct::function1();
println!(&quot;{}&quot;, resp);
println!(&quot;{}&quot;, MyStruct::function3());
let s = MyStruct {
    a: 123,
    b: String::from(&quot;lskmdf&quot;),
};
println!(&quot;{}&quot;, s.function2());
<span class="boring">}</span></code></pre></pre>
<p>Contoh inherent functions/methods pada enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MyEnum {
    A(String),
    B(i32),
    C(f32),
}

impl MyEnum {
    pub fn function1() -&gt; i32 {
        123
    }

    pub fn function2(&amp;self) -&gt; String {
        match *self {
            MyEnum::A(ref s) =&gt; s.clone(),
            _ =&gt; String::from(&quot;null&quot;)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh memanggil inherent functions/methods pada enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;,MyEnum::A(&quot;halo&quot;.to_string()).function2());
println!(&quot;{}&quot;,MyEnum::B(123).function2());
<span class="boring">}</span></code></pre></pre>
<h3 id="associated-traits"><a class="header" href="#associated-traits">Associated Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    fn method1() -&gt; i32;
    fn method2(&amp;self) -&gt; String;
}

struct MyStruct {
    a: i32,
    b: String,
}

impl MyTrait for MyStruct {
    fn method1() -&gt; i32 {
        123
    }

    fn method2(&amp;self) -&gt; String {
        self.b
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Berikut 4 cara memanggil associated trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Karena function method3() mengembalikan tipe `Self`, maka memanggil function tersebut dari `MyTrait` akan secara otomatis memanggil implementasi oleh `MyStruct`
// karena MyStruct dijadikan tipe data return oleh variable penerima.
let _: MyStruct = MyTrait::method3();

// Wildcard akan membaca return method3 yang `Self` dan mencocokkan dengan tipe data variable penerima sebelah kiri.
let _: MyStruct = &lt;_ as MyTrait&gt;::method3();

// Implementor sudah didefine ketika memanggil method3 dengan menggunakan Fully Qualified Syntax
let _ = &lt;MyStruct as MyTrait&gt;::method3();

// Langsung menggunakan tipe implementor dengan syarat tipe trait sudah dimasukkan ke dalam scope caller berada.
let _ = MyStruct::method3();

// sebagai contoh, jika dipanggil dari module lain:
// MyTrait harus dibawa ke dalam scope module untuk dapat memanggil method yang diimplement oleh MyStruct
mod a {
    use super::{MyStruct, MyTrait};

    fn sdf() {
        let d = MyStruct::method3();
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h2>
<p>Associated Types hanya dideklarasi di dalam <code>trait</code> dan didefinisikan di dalam implementor. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    type Error: Display + Debug + Clone;

    fn method1() -&gt; i32;
    fn method2(&amp;self) -&gt; String;
    fn method3() -&gt; Self;
    fn method4() -&gt; Result&lt;(), Self::Error&gt;;
}

impl MyTrait for MyStruct {
    type Error = String;

    fn method1() -&gt; i32 {
        123
    }

    fn method2(&amp;self) -&gt; String {
        self.b.clone()
    }

    fn method3() -&gt; Self {
        MyStruct { a: 123, b: &quot;sdf&quot;.to_string() }
    }

    fn method4() -&gt; Result&lt;(), Self::Error&gt; {
        return Err(&quot;error bung&quot;.to_string());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika memanggil tipe tersebut:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, MyStruct::method4().unwrap_err());
<span class="boring">}</span></code></pre></pre>
<h2 id="associated-constant"><a class="header" href="#associated-constant">Associated Constant</a></h2>
<p>Sama dengan associated type, constants juga bisa di-declare pada trait, dan di-definisikan pada implementor.
Hal yang beda adalah kita bisa memberi default value pada constant yang di-declare di trait bersangkutan. Jika kita memberi default value pada constant trait,
dan mendefinisikannya juga pada implementor, maka value pada implementor akan meng-overwrite default value pada trait.
Associated Constant bisa dideklarasi dan didefinisikan langsung pada <code>impl</code> tanpa trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyStruct {
    pub const C: &amp;str = &quot;nganu&quot;;
}

trait MyTrait {
    const D: i32;
    // const D: i32 = 0; // default value, 
    type Error: Display + Debug + Clone;

    fn method1() -&gt; i32;
    fn method2(&amp;self) -&gt; String;
    fn method3() -&gt; Self;
    fn method4() -&gt; Result&lt;(), Self::Error&gt;;
}

impl MyTrait for MyStruct {
    const D: i32 = 123; // -&gt; will overwrite default value in trait if declared
    type Error = String;

    fn method1() -&gt; i32 {
        123
    }

    fn method2(&amp;self) -&gt; String {
        self.b.clone()
    }

    fn method3() -&gt; Self {
        MyStruct { a: 123, b: &quot;sdf&quot;.to_string() }
    }

    fn method4() -&gt; Result&lt;(), Self::Error&gt; {
        println!(&quot;const: {}&quot;, Self::D);
        return Err(&quot;error bung&quot;.to_string());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil, kita tidak bisa memanggil constant langsung dari trait, harus melewati type implementor.</p>
<p>Ketika memanggil:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, MyStruct::C);
println!(&quot;{}&quot;, MyStruct::D);
println!(&quot;{}&quot;, &lt;MyStruct as MyTrait&gt;::D);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p>Trait merupakan tipe data <em>opaque</em> yang tidak memiliki tipe data konkrit, akan tetapi hanya mengandung behaviour(collection of methods/functions). Tipe ini bisa digunakan untuk mengimplementasikan <em>polymorphism</em> dimana semua tipe bisa diterima selama memiliki behaviour yang sama.
Semua method-method yang ada pada trait adalah public, sehingga ketika meng-implementasikan trait tidak perlu mendeklarasikan method sebagai public.</p>
<p>Trait dapat digunakan untuk beberapa hal di-antaranya:</p>
<ul>
<li><em>Shared behaviour</em>: banyak tipe bisa mengimplementasikan behaviour yang sama(<em>polymorphism</em>). Kegunaan lain adalah untuk membuat objek <em>mock</em> yang bisa digunakan untuk unit testing, khususnya IO bound operations.</li>
<li><em>Generic bound</em>: bisa digunakan untuk memberikan batasan tipe generic, sehingga memperkecil tipe data yang bisa dimasukkan ke dalam generic dan memberikan API yang lebih konkrit dan mudah dipahami dan digunakan.</li>
</ul>
<p>Trait dapat digunakan di tempat-tempat berikut(V1.64+):</p>
<ul>
<li>Function input and return params</li>
<li>Type aliasing</li>
<li>Bound for generic type</li>
</ul>
<p>Trait dapat diimplementasikan oleh:</p>
<ul>
<li>struct</li>
<li>enum</li>
<li>primitive types</li>
<li>non-primitive types</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {
    fn method1(&amp;self) -&gt; i32;
    fn method2(param1: &amp;str) -&gt; Result&lt;(),String&gt;;
    fn method3(param1: String);
}
<span class="boring">}</span></code></pre></pre>
<p>Implementasi trait harus eksplisit sehingga harus di-define untuk masing-masing type yang ingin mengimplementasikan trait tersebut.
Berikut contoh implementasi trait dan beberapa cara memanggilnya:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Struct yang akan mengimplementasikan trait `MyTrait`
pub struct MyStruct {
    a: i32,
    b: String,
}

// Implementasi MyTrait oleh MyStruct
impl MyTrait for MyStruct {
    // implementasi trait dengan immutable reference dari struct implementor.
    // struct harus punya nilai terlebih dahulu sebelum memanggil method ini dan diikuti `.`
    fn method1(&amp;self) -&gt; i32 {
        self.a
    }

    // implementasi trait tanpa menginisialisasi struct implementor.
    // cukup dengan memanggil type struct diikuti `::`
    fn method2(param1: &amp;str) -&gt; Result&lt;(),String&gt; {
        if param1.is_empty() {
            return Err(&quot;empty string&quot;.to_string());
        }
        Ok(())
    }

    fn method3(param1: String) {
        println!(&quot;do nothing&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Beberapa cara pengaplikasian trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Param input fungsi
let ms = MyStruct {
    a: 1,
    b: String::from(&quot;test&quot;),
};

fn accept_trait(t: &amp;impl MyTrait) {
    let resp = t.method1();
    dbg!(&quot;accept_trait: &quot;,resp);
    let ret = MyStruct::method2(&quot;param1&quot;);
    dbg!(&quot;accept_trait: &quot;,ret);

    MyStruct::method3(&quot;nothing inside accept_trait: &quot;.to_string());
}

accept_trait(&amp;ms);

// Param output fungsi
fn return_trait() -&gt; impl MyTrait {
    MyStruct {
        a: 100,
        b: &quot;test&quot;.to_string(),
    }
}
let t = return_trait();

// Param input dan output fungsi from associated function
struct F {
    a: i32,
}
impl F {
    fn accept_trait_from_impl(param: &amp;impl MyTrait) {
        param.method1();
    }

    fn return_trait_from_impl() -&gt; impl MyTrait {
        MyStruct {
            a: 123,
            b: String::from(&quot;sdf&quot;),
        }
    }
}

// membatasi method2 yang akan dipanggil dengan menggunakan `as Trait`
// disebut juga dengan Fully Qualified Syntax
let ret = &lt;MyStruct as MyTrait&gt;::method2(&quot;param1&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil fungsi/method trait dari module lain yang diimplementasikan oleh suatu implementor, tipe trait tersebut harus dibawa ke dalam scope caller. Contoh:</p>
<p>file: src/a.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait T {
    fn t(&amp;self);
    fn t2();
}

pub struct S {
    pub s: String,
}

impl T for S {
    fn t(&amp;self) {
        println!(&quot;{}&quot;, self.s);
    }
    fn t2() {}
}
<span class="boring">}</span></code></pre></pre>
<p>file: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">mod a;
use a::{S, T};

fn main() {
    let sss = S {
        s: &quot;sdf&quot;.to_string(),
    };
    sss.t();
    S::t2();
}</code></pre></pre>
<p>Trait <code>T</code> harus dideklarasikan lewat module <code>a</code> sekalipun trait tersebut tidak pernah digunakan secara langsung, akan tetapi ada tipe lain yang implement trait tersebut, memanggil fungsi/method dari trait tersebut. Jika trait tidak dibawa ke dalam scope, maka akan menyebabkan kompilasi error karena compiler tidak bisa menemukan fungsi/method yang dipanggil oleh struct <code>S</code>, karena fungsi/method tersebut didefinisikan oleh trait bersangkutan.</p>
<p>Selain <code>struct</code>, trait juga bisa diimplementasikan oleh tipe lain seperti <code>enum</code>, primitive types, dan non-primitive types. Contoh:</p>
<p>file: src/a.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Trait {
    fn t(&amp;self) -&gt; i32;
    fn t2();
}

pub enum Enum {
    F,
    G,
    H(String),
}

impl Trait for Enum {
    fn t(&amp;self) -&gt; i32 {
        match &amp;*self {
            Enum::H(s) =&gt; {
                println!(&quot;{}&quot;, s);
            }
            _ =&gt; {
                println!(&quot;nothing&quot;);
            }
        }
        123
    }
    fn t2() {
        
    }
}

impl Trait for i32 {
    fn t(&amp;self) -&gt; i32 {
        *self
    }
    fn t2() {
        println!(&quot;i32::t2&quot;);
    }
}

impl Trait for &amp;[i32] {
    fn t(&amp;self) -&gt; i32 {
        *self.get(0).unwrap_or(&amp;123)
    }
    fn t2() {
        println!(&quot;&amp;[i32]::t2&quot;);
    }
}

impl Trait for [f32;5] {
    fn t(&amp;self) -&gt; i32 {
        if !self.is_empty() {
            return *self.get(0).unwrap() as i32;
        }
        123
    }

    fn t2() {
        println!(&quot;[f32;5]::t2&quot;);
    }
}

impl Trait for Vec&lt;String&gt; {
    fn t(&amp;self) -&gt; i32 {
        if !self.is_empty() {
            let parsed_string = self.get(0).unwrap().parse::&lt;i32&gt;();
            if parsed_string.is_err() {
                return 0;
            }
            return parsed_string.unwrap();
        }
        123
    }

    fn t2() {
        println!(&quot;Vec&lt;String&gt;::t2&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil implementasi2 trait tersebut dari <code>src/a.rs</code>:</p>
<p>file: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let e = Enum::H(&quot;anu&quot;.to_string());
e.t();
Enum::t2();

// -----------

let num = 123;
println!(&quot;{}&quot;,num.t());
i32::t2();

// -----------
let slice: &amp;[i32] = &amp;[1,2,3,4];
println!(&quot;{}&quot;, slice.t());
&lt;&amp;[i32]&gt;::t2();

// -----------
let array = [1.2, 2_f32, 3_f32, 4.2, 5.2];
println!(&quot;{}&quot;, array.t());
&lt;[f32;5]&gt;::t2();

// -----------
let v = vec![String::from(&quot;345&quot;), &quot;that&quot;.to_string(), &quot;asd&quot;.to_owned()];
println!(&quot;{}&quot;,v.t());
&lt;Vec&lt;String&gt;&gt;::t2();
<span class="boring">}</span></code></pre></pre>
<p>Untuk tipe data non-primitive seperti array, slice, vector dan lainnya, untuk memanggil associated functions dari tipe-tipe tersebut, maka harus menggunakan <code>Fully Qualified Syntax</code> dengan cara:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;type&gt;::function();
<span class="boring">}</span></code></pre></pre>
<h2 id="default-implementation"><a class="header" href="#default-implementation">Default Implementation</a></h2>
<p>Ketika mendefinisikan suatu trait, dan ingin mengimplementasikan trait tersebut oleh suatu tipe, kadang kita belum tentu ingin mengimplementasikan seluruh fungsi/methods yang ada, untuk hal ini, kita bisa define default implementation untuk sebagian atau keseluruhan fungsi. </p>
<p>file: src/default.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait D {
    fn de(&amp;self) -&gt; String {
        String::from(&quot;default&quot;)
    }
    fn not_de() -&gt; String;
}

pub struct P;

impl D for P {
    fn not_de() -&gt; String {
        String::from(&quot;P&quot;)
    }
}

pub struct O;

impl D for O {
    fn de(&amp;self) -&gt; String {
        String::from(&quot;overwrited&quot;)
    }
    fn not_de() -&gt; String {
        String::from(&quot;O&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil:</p>
<p>file: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p = P;
println!(&quot;{}&quot;, p.de());
println!(&quot;{}&quot;, P::not_de());
let o = O;
println!(&quot;{}&quot;, o.de());
println!(&quot;{}&quot;, O::not_de());
<span class="boring">}</span></code></pre></pre>
<p>Default implementation tidak mengharuskan tipe implementor mengimplementasikan fungsi/method dengan default behaviour tersebut. Akan tetapi jika kita mengimplementasikan fungsi/method dengan default behaviour, maka akan meng-overwrite default behaviour tersebut.</p>
<h2 id="trait-associated-type"><a class="header" href="#trait-associated-type">Trait Associated Type</a></h2>
<p>Merupakan placeholder type untuk tipe data yang akan digunakan oleh method-method pada trait.</p>
<p>Perbedaan penggunaan associated type dengan generics, adalah dengan menggunakan associated API implementor tidak perlu membuat implementasi generic untuk suatu tipe, karena hal ini terlihat seolah-olah memiliki berbagai jenis tipe. Misal jika kita ada <code>trait Trait&lt;T&gt; {...}</code>, maka akan bisa di deklarasi berbagai tipe untuk T seperti <code>Trait&lt;String&gt;</code>, <code>Trait&lt;i32&gt;</code>, etc. Dari sudut pandang API user, mereka tidak perlu memberi spesifikasi tipe, karena implementor sudah meng-enkapsulasi type implementor dan tipe yang terasosiai ke dalam satu trait tersebut. API user bahkan tidak perlu membawa definisi trait ke dalam scope hanya untuk memenuhi fully qualified syntax dengan spesifikasi tipe generic. User hanya cukup tau suatu tipe sudah mengimplementasi suatu trait dengan semua data yang terasosiasi. Secara idiom, generic type pada trait menggunakan associated type, dan generic type sebenarnya akan digunakan oleh implementor type.</p>
<p>Perbedaan lainnya adalah menggunakan associated type tipe data dipilih oleh implementor, sedangkan menggunakan generics tipe data dipilih API user.</p>
<p>General Rule-of-thumb penggunaan associated type dan generics type(<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md">source</a>):</p>
<ul>
<li>Use associated types when there should only be a single impl of the trait per type.</li>
<li>Use generic types when there can be many possible impls of the trait per type.</li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

pub trait TraitAss {
    type Item: Sized + Debug + Default;

    fn method1(&amp;self) -&gt; &amp;Self::Item;

    fn method2(&amp;self) -&gt; (Self::Item, i32) {
        (Default::default(), 0)
    }
}

pub struct Struct&lt;T&gt; {
    field1: i32,
    field2: T,
}
impl&lt;T&gt; Struct&lt;T&gt; {
    pub fn new(name: T) -&gt; Self {
        Self {
            field1: 123,
            field2: name,
        }
    }
}

impl&lt;T&gt; TraitAss for Struct&lt;T&gt;
where
    T: Sized + Debug + Default,
{
    type Item = T;

    fn method1(&amp;self) -&gt; &amp;Self::Item {
        &amp;self.field2
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic"><a class="header" href="#generic">Generic</a></h1>
<p>Generic merupakan polimorfisme dari suatu tipe data. Rust menerapkan <em>Monomorphization</em> untuk generic type, yaitu dengan membuat setiap copy dari tipe data yang dideklarasikan pada saat compile time. Hal ini membuat generic pada Rust <em>fully zero-cost</em>, yang berbeda dengan generic pada Java dan Go dimana Java menerapkan <em>Type-erasure</em> dan golang menerapkan <em>Stenciling</em> yang keduanya masih menyisakan setidaknya sedikit runtime overhead.
Generic dapat diterapkan pada tempat seperti: <code>functions</code>, <code>type aliases</code>, <code>structs</code>, <code>enumerations</code>, <code>unions</code>, <code>traits</code> and <code>implementations</code>.</p>
<p>Berikut beberapa penerapan Generic pada Rust:</p>
<h2 id="function-generic-parameters"><a class="header" href="#function-generic-parameters">Function generic parameters</a></h2>
<p>Generic parameter pada deklarasi fungsi untuk memberikan parameter bertipe untuk parameter fungsi/method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function&lt;T&gt;(param: T) -&gt; T {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil fungsi generic tersebut:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>function::&lt;i32&gt;(123); // secara eksplisit mendefinisikan tipe data yang diinginkan
let t = function(123); // secara implicit di-infer dari tipe data param, 123 -&gt; i32(default value of number type)
<span class="boring">}</span></code></pre></pre>
<p>Fungsi dengan <em>dedicated</em> type akan di-generate sehingga tidak ada lagi <em>runtime overhead</em> ketika program berjalan.</p>
<h2 id="struct-generic-fields"><a class="header" href="#struct-generic-fields">Struct generic fields</a></h2>
<p>Generic untuk tipe data pada field-field di dalam struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt; {
    a: T,
    b: T,
} // single generic param

struct A2&lt;T, E&gt; {
    a: T,
    b: E.
} // multiple generic params
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil struct generic tersebut:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = A::&lt;f32&gt; {
        a: 123.2,
        b: 23.0,
    }; // secara eksplicit mendefinisikan tipe data yang diinginkan

let a = A {
        a: 123,
        b: 34,
    }; // secara implicit di-infer dari tipe data yang dimasukkan ke field2 struct -&gt; i32

let a2 = A2::&lt;i32,f32&gt; {
        a: 123,
        b: 34.4,
    }; // secara eksplicit mendefinisikan tipe data yang diinginkan

let a2 = A2 {
    a: 123,
    b: 34.5,
}; // secara implicit di-infer dari tipe data yang dimasukkan ke field2 struct -&gt; i32 dan f32
<span class="boring">}</span></code></pre></pre>
<h2 id="enum-generic-associated-data"><a class="header" href="#enum-generic-associated-data">Enum generic associated data</a></h2>
<p>Generic untuk tipe data yang berkaitan dengan deklarasi enum.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum B&lt;T&gt; {
    Field1,
    Field2(T),
    Field3 {
        t: T,
    }
} // single generic param

enum B2&lt;T, E&gt; {
    Field1,
    Field2(T),
    Field3 {
        t: E,
    }
} // multiple generic params
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil enum generic tersebut:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = B::&lt;i32&gt;::Field2(123); // secara eksplicit mendefinisikan tipe data yang diinginkan
let b = B::Field2(123); // secara implicit mendefinisikan tipe data yang diinginkan

let b2 = B2::&lt;i32, f32&gt;::Field2(123); // secara eksplicit mendefinisikan tipe data yang diinginkan
let b2: B2&lt;&amp;str, i32&gt; = B2::Field2(&quot;123&quot;); // deklarasi multiple generic params untuk enum harus eksplicit karena hanya 1 value enum dari multiple enum yang dideklarasikan yang digunakan, sehingga tipe harus eksplicit untuk value lainnya yang tidak/belum dipanggil.
<span class="boring">}</span></code></pre></pre>
<h2 id="methods-generic-parameters"><a class="header" href="#methods-generic-parameters">Methods generic parameters</a></h2>
<p>Generic untuk tipe data pada penerapan <em>associated functions</em> pada suatu tipe.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt; {
    a: T,
    b: T,
}

impl&lt;T&gt; A&lt;T&gt; {
    fn method1(param: T) -&gt; T {
        param
    }

    fn method2(param: T) {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika ingin memanggil generic methods tersebut</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = A::&lt;i32&gt; {
        a: 123,
        b: 234,
    };
a.method2(123);
let a = A::&lt;i32&gt;::method1(123);
<span class="boring">}</span></code></pre></pre>
<h2 id="trait-with-generic-parameter"><a class="header" href="#trait-with-generic-parameter">Trait with generic parameter</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait&lt;T&gt; {
    fn method1(param: T) -&gt; T;
}

pub struct MyStruct&lt;T&gt; {
    field1: T,
}

// ketika ingin mengimplementasikan suatu trait dengan generic parameter, tipe konkrit harus di deklarasi.
impl MyTrait&lt;String&gt; for MyStruct&lt;T&gt; {
    fn method1(param: String) -&gt; String {
        String::from(&quot;hello&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-alias-with-generic"><a class="header" href="#type-alias-with-generic">Type alias with generic</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MyResult&lt;T&gt; = Result&lt;T, String&gt;
<span class="boring">}</span></code></pre></pre>
<p>Sehingga cukup menggunakan <code>MyResult</code> ketika ingin mengembalikan <em>fallible operation</em> dengan error tipe string.</p>
<h2 id="generic-default-type"><a class="header" href="#generic-default-type">Generic Default Type</a></h2>
<p>Memberika tipe default ketika tipe tidak didefinisikan.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Debug;

#[derive(Debug)]
pub struct Data&lt;T = i32&gt; {
    field: T,
}

// default generic type parameter doesn't require us to give parameter type declaration and default will be used.
impl Data {
    pub fn new() -&gt; Self {
        Data { field: 123 }
    }
}

impl&lt;T: Copy + Debug&gt; Data&lt;T&gt; {
    pub fn new_custom(t: T) -&gt; Self {
        Data { field: t }
    }
}

fn main() {
    let dt = generic_default::Data::new();
    dbg!(dt);
    let dt = generic_default::Data::new_custom(&quot;anu&quot;);
    dbg!(dt);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-trait-bounds"><a class="header" href="#generics-trait-bounds">Generics Trait Bounds</a></h1>
<p>Ketika ingin membatasi tipe-tipe yang dibolehkan pada generic, kita bisa menggunakan <code>trait</code> sehingga tipe-tipe yang bisa dimasukkan ke dalam generic type hanya tipe yang sudah mengimplementasikan <code>trait</code> bersangkutan.</p>
<p>Generic trait bound bisa dideklarasikan pada tempat-tempat dimana generic berada.</p>
<p>Berikut beberapa tempat mendeklarasi trait bound pada generic type:</p>
<h2 id="function-params"><a class="header" href="#function-params">Function Params</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::fmt::Display;

fn my_format&lt;T: Display&gt;(param: T) {
    println!(&quot;--&gt;: {}&quot;, param);
}
<span class="boring">}</span></code></pre></pre>
<p>Trait <code>Display</code> diimport dari module <code>core::fmt</code>. Trait ini merupakan trait untuk tipe-tipe yang bisa di-print ke stdout atau stderr. Semua tipe-tipe primitive sudah memiliki implementasi ini built-in, beberapa tipe non-primitive lain juga sudah. Untuk tipe yang belum kita bisa implement sendiri trait tersebut.</p>
<p>Trait <code>Display</code> dibutuhkan karena tipe T akan digunakan di dalam <code>println!()</code> yang membutuhkan data dengan tipe yang implement <code>Display</code> trait.</p>
<ul>
<li>Multiple generics:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_generic_multiple_bounds&lt;T: Display + Clone&gt;(param: T) {
    println!(&quot;{}&quot;, param.clone());
}

fn function_multiple_generic_multiple_bounds&lt;T: Display + Clone, U: Debug&gt;(param1: T, param2: U) {
    println!(&quot;{} -&gt; {:?}&quot;, param1.clone(), param2)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Memanggil multiple generics:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// memanggil dengan definisi tipe
function_generic_multiple_bounds::&lt;&amp;str&gt;(&quot;this is testing&quot;); 
function_multiple_generic_multiple_bounds::&lt;&amp;str, i64&gt;(&quot;test&quot;, 123);

// memanggil dengan tipe data infered
function_generic_multiple_bounds(&quot;this is testing&quot;);
function_multiple_generic_multiple_bounds(&quot;test&quot;, 123);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Multiple generics dengan <code>where</code>:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_generic_trait_bounds_where&lt;T, U, V&gt;(param1: T, param2: U, param3: V) -&gt; String
where
    T: Clone + Display,
    U: Debug,
    V: Display,
    String: From&lt;V&gt;
{
    println!(&quot;{} {:?}&quot;, param1, param2);
    String::from(param3)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Memanggil multiple generics dengan <code>where</code>:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let resp: String = function_generic_trait_bounds_where(&quot;test&quot;, 123, &quot;this&quot;);
println!(&quot;{}&quot;, resp);
<span class="boring">}</span></code></pre></pre>
<h2 id="struct-dan-enum-beserta-associated-functions-dan-methods"><a class="header" href="#struct-dan-enum-beserta-associated-functions-dan-methods">Struct dan Enum beserta associated functions dan methods</a></h2>
<h3 id="struct-1"><a class="header" href="#struct-1">Struct</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct MyStruct&lt;T, U&gt; {
    field1: T,
    field2: U,
}

impl&lt;T: Display, U: Debug + Display&gt; MyStruct&lt;T, U&gt; {
    pub fn method1(param1: T, param2: U) {
        println!(&quot;{}, {}&quot;, param1, param2);
    }

    pub fn method2(&amp;self) {
        println!(&quot;{}, {}&quot;, self.field1, self.field2);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Implementasi menggunakan <code>where</code> clause:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; MyStruct&lt;T, U&gt; where
    T: Display,
    U: Debug + Display
{
    pub fn method1(param1: T, param2: U) {
        println!(&quot;{}, {}&quot;, param1, param2);
    }

    pub fn method2(&amp;self) {
        println!(&quot;{}, {}&quot;, self.field1, self.field2);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Memanggil:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MyStruct::&lt;i32, &amp;str&gt;::method1(123, &quot;test&quot;);
MyStruct::method1(123, &quot;test&quot;); // infered
<span class="boring">}</span></code></pre></pre>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum MyEnum&lt;T,U&gt; {
    Value1(T),
    Value2(U),
}

impl&lt;T: Debug + Display, U: Debug + Display&gt; MyEnum&lt;T,U&gt; {
    pub fn method1(param1: T, param2: U) {
        println!(&quot;{:?}, {:?}&quot;, param1, param2);
    }

    pub fn method2(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Implementasi menggunakan <code>where</code> clause:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; MyEnum&lt;T,U&gt; where
    T: Debug + Display,
    U: Debug + Display
{
    pub fn method1(param1: T, param2: U) {
        println!(&quot;{:?}, {:?}&quot;, param1, param2);
    }

    pub fn method2(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Memanggil:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MyEnum::&lt;i32, f32&gt;::Value1(9999).method2();
<span class="boring">}</span></code></pre></pre>
<p>Untuk <code>Struct</code> dan <code>Enum</code> trait bounds lebih baik di deklarasikan untuk <code>impl</code> karena filter tipe berlaku ketika ada operasi terhadap data generic tersebut. Jika hanya struct dan enum saja, maka tidak berarti apa-apa bounds yang diberikan karena kita tidak melakukan apa-apa terhadap data tersebut.</p>
<h2 id="trait-1"><a class="header" href="#trait-1">Trait</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait&lt;T: Display, U: Display + Clone&gt; {
    fn method1(param: T);
    fn method2(&amp;self, param: U);
    fn method3(&amp;self, param: T) -&gt; U;
}

struct MyStruct4 {
    field1: String,
    field2: i32,
}

impl MyTrait&lt;i32, String&gt; for MyStruct4 {
    fn method1(param: i32) {
        println!(&quot;{}&quot;, param);
    }

    fn method2(&amp;self, param: String) {
        println!(&quot;{} : {}&quot;, self.field2, param.clone());
    }

    fn method3(&amp;self, param: i32) -&gt; String {
        format!(&quot;field1: {}, field2: {}, param: {}&quot;, self.field1, self.field2, param)
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Pemanggilan kode di atas:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MyStruct4::method1(123);
let my_struct4 = MyStruct4 {
    field1: String::from(&quot;this&quot;),
    field2: 234,
};
my_struct4.method2(String::from(&quot;lskdmf&quot;));
&lt;MyStruct4 as MyTrait&lt;i32, String&gt;&gt;::method1(4999);
let resp = my_struct4.method3(7890);
println!(&quot;{}&quot;, resp);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Implementasi trait dengan generic implementor:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait&lt;T: Display, U: Display + Clone&gt; {
    fn method1(param: T);
    fn method2(&amp;self, param: U);
    fn method3(&amp;self, param: T) -&gt; U;
}

struct MyStruct4&lt;T, U&gt; {
    field1: T,
    field2: U,
}

impl&lt;T: Display, U: Clone + Display&gt; MyTrait&lt;i32, String&gt; for MyStruct4&lt;T, U&gt; {
    fn method1(param: i32) {
        println!(&quot;{}&quot;, param);
    }

    fn method2(&amp;self, param: String) {
        println!(&quot;{} : {}&quot;, self.field2, param.clone());
    }

    fn method3(&amp;self, param: i32) -&gt; String {
        format!(&quot;field1: {}, field2: {}, param: {}&quot;, self.field1, self.field2, param)
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Pemanggilan kode di atas:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>MyStruct4::&lt;String, i32&gt;::method1(123);
let my_struct4 = MyStruct4 {
    field1: String::from(&quot;this&quot;),
    field2: 234,
};
my_struct4.method2(String::from(&quot;lskdmf&quot;));
&lt;MyStruct4&lt;String, i32&gt; as MyTrait&lt;i32, String&gt;&gt;::method1(4999);
let resp = my_struct4.method3(7890);
println!(&quot;{}&quot;, resp);
<span class="boring">}</span></code></pre></pre>
<p>Untuk <code>trait</code> bounds dapat ditaruh pada deklarasi trait, sehingga bound ini akan diterapkan pada setiap tipe yang mengimplementasikan trait tersebut.</p>
<p>Perbedaan generic bounds pada <code>impl</code> antara trait dengan inherent adalah dengan trait kita bisa deklarasi generic return type, yang akan didefinisikan tipenya saat implementasi oleh suatu tipe. Seperti contoh di atas, fungsi <code>fn method3(&amp;self, param: T) -&gt; U;</code> memiliki generic return dan tipe dari return didefinisikan pada saat implementasi <code>impl MyTrait&lt;i32, String&gt; for MyStruct4</code> sehingga return type menjadi String.</p>
<h2 id="generic-method"><a class="header" href="#generic-method">Generic Method</a></h2>
<p>Generic method merupakan deklarasi generics parameter pada method di dalam trait. </p>
<p>Rule: Generic parameter pada method di dalam deklarasi trait harus <strong>lebih atau sama strict</strong> dibanding method generic parameter di dalam trait impl. </p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">trait Trait&lt;T&gt; {
    // fn method&lt;U: Display&gt;(&amp;self, t: T, u: U); // minimal
    fn method&lt;U: Display + Debug&gt;(&amp;self, t: T, u: U);
}

struct Struct&lt;T&gt; {
    field: T
}

impl&lt;T: Display&gt; Trait&lt;T&gt; for Struct&lt;T&gt; {
    fn method&lt;U: Display&gt;(&amp;self, t: T, u: U) {
        println!(&quot;{}&quot;, self.field);
        println!(&quot;{}&quot;, t);
        println!(&quot;{}&quot;, u);
    }
}

fn main() {
    let s = Struct{field: &quot;this&quot;};
    s.method(&quot;that&quot;, 123_f64);
    
}</code></pre></pre>
<p>Pada contoh code di atas, generic parameter pada trait memiliki trait bounds: <code>Display + Debug</code> lebih strict dari impl yang cuma <code>Display</code>.
Hal ini supaya ketika trait digunakan, tidak akan konflik ketika mengdefinisikan dan menggunakan method bersangkutan. Karena jika impl method masih di dalam boundaries trait methods, maka value-value yang diharapkan masih bisa masuk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h1>
<p>Lifetime adalah scope validnya suatu data ketika di-<em>borrowed</em>. Lifetime umumnya sudah implisit untuk setiap variable yang dideklarasikan. Lifetime memberi penanda pada scope dari <em>borrowed</em> value supaya compiler bisa memastikan bahwa <em>borrowed</em> value tersebut tetap valid digunakan. Lifetime harus selalu merujuk ke suatu atau beberapa <em>borrowed</em> value. Lifetime yang dirujuk harus valid selama data yang mereferensikan lifetime tersebut digunakan/valid.</p>
<p>Contoh deklarasi anotasi generic lifetime:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a: &amp;'a str // variable of a with 'a lifetime on immutable data
a: &amp;'a mut str // variable of a with 'a lifetime on mutable data
<span class="boring">}</span></code></pre></pre>
<p>Metode yang digunakan Rust untuk mendeteksi validnya suatu reference disebut juga dengan <em>Borrow Checker</em>.</p>
<h2 id="function-lifetime-annotation"><a class="header" href="#function-lifetime-annotation">Function Lifetime Annotation</a></h2>
<p>Lifetime pada fungsi digunakan untuk memberi penanda lifetime pada parameter dan return values. Tidak bisa digunakan untuk memberi lifetime terhadap data yang di-<em>borrowed</em> dari dalam fungsi karena data tersebut akan dihapus setelah fungsi return/exit, kecuali <em>borrowed</em> value bersifat static.
Contoh deklarasi annotasi lifetime pada fungsi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Pada fungsi di atas deklarasi lifetime setelah nama fungsi. Selanjutnya lifetime digunakan untuk menyambungkan lifetime parameter kepada return value. Dalam hal ini, compiler akan memilih lifetime paling pendek untuk dijadikan acuan return value. Hal itu karena kalau menggunakan lifetime terpanjang, dan ternyata return valuenya berasal dari lifetime terpendek, maka akan terjadi dangling reference. Parameter dengan lifetime terpendek itu akan di remove di scope nya yang lebih pendek sehingga jika masih ada referensi terhadap value tersebut, menjadi invalid. Inilah yang dideteksi oleh compiler rust dengan cara menambahkan lifetime annotasi.</p>
<p>Contoh lain ketika memberi lifetime kepada value reference di dalam fungsi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fff&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str { // worked
    let ret = &quot;anu&quot;;
    ret
}
fn fff2&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str { // doesn't work
    let ret = String::from(&quot;anu&quot;);
    ret.as_str()
}
<span class="boring">}</span></code></pre></pre>
<p>Fungsi pertama berjalan karena default lifetime untuk string yang dideklarasikan secara literal adalah <em>static</em>, yaitu hidup sepanjang program berjalan. Sehingga lifetime <code>'a</code> akan menggunakan lifetime static tersebut.</p>
<p>Fungsi kedua tidak berjalan karena <code>String::from(&quot;anu&quot;)</code> bersifat <em>owned</em> karena data dialokasi secara dynamic sehingga akan berakhir ketika fungsi return/exit dan menyebabkan reference ke data tersebut menjadi invalid.</p>
<h2 id="struct-lifetime-annotation"><a class="header" href="#struct-lifetime-annotation">Struct Lifetime Annotation</a></h2>
<p>Lifetime pada struct berarti field-field dari struct tersebut <em>borrow</em> value dari luar. Sehingga untuk menyambung lifetime <em>borrowed</em> data tersebut ke dalam field-field struct, field tersebut harus menggunakan generic lifetime annotation.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string = String::from(&quot;string&quot;);
    let s = StructWithLifetime{
        string: string.as_str(),
    };
    
    println!(&quot;{:?}&quot;, s);
}

#[derive(Debug)]
struct StructWithLifetime&lt;'a&gt; {
    string: &amp;'a str,
}</code></pre></pre>
<p>Pada contoh di atas, dilihat bahwa field <code>string</code> dari <code>StructWithLifetime</code> menggunakan lifetime dari String dari luar di dalam fungsi <code>main</code>, sehingga field tersebut valid selama <code>string</code> masih di dalam scope.</p>
<p>Untuk lifetime pada type lainnya seperti enum, akan sama dimana lifetime diberi anotasi setelah nama tipe.</p>
<h2 id="methodinherent-functions-lifetime-annotation"><a class="header" href="#methodinherent-functions-lifetime-annotation">Method/inherent functions Lifetime Annotation</a></h2>
<p>Lifetime juga bisa ditaruh untuk inherent functions/methods untuk mendeklarasi lifetime yang akan digunakan oleh implementor type dan fungsi/method di dalamnya.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// deklarasi lifetime struct yang digunakan oleh field `name`
struct Service&lt;'a&gt; {
    name: &amp;'a str,
}

// deklarasi lifetime inherent items
impl&lt;'a&gt; Service&lt;'a&gt; {
    // penggunaan generic lifetime pada parameter fungsi untuk lifetime dari self
    pub fn method1(&amp;'a self) -&gt; &amp;str {
        f(self.name);
        self.name
    }
}

// deklarasi lifetime inherent items, dengan lifetime Service bersifat wildcard(ignored)
impl&lt;'a&gt; Service&lt;'_&gt; {
    pub fn method2(&amp;self) -&gt; &amp;str {
        self.name
    }
}

// tanpa deklarasi lifetime inherent items, dengan lifetime Service bersifat wildcard(ignored)
impl Service&lt;'_&gt; {
    pub fn method3(&amp;self) -&gt; &amp;str {
        self.name
    }
}

// deklarasi lifetime fungsi yang dipanggil di inherent items di atas, chaining lifetime from caller to callee
fn f&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
    println!(&quot;f() -&gt; {}&quot;, s);
    s
}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-lifetimestatic"><a class="header" href="#static-lifetimestatic">Static Lifetime(&amp;'static)</a></h2>
<p>Adalah lifetime dari suatu <em>borrowed</em> type yang hidup sepanjang program berjalan. Contoh yang sering kita lihat adalah ketika kita mendeklarasi constant <code>&amp;str</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let static_str: &amp;'static str = &quot;live forever&quot;;
println!(&quot;{static_str}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Contoh static lifetime yang di-infer secara otomatis oleh compiler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const I_LIVE_LONGEST: &amp;str = &quot;anu&quot;;
<span class="boring">}</span></code></pre></pre>
<p>Konstant <code>I_LIVE_LONGEST</code> akan bisa di-<em>pinjam</em> selama program berjalan karena <em>borrowed</em> type <code>str</code> akan di-<em>infered</em> sebagai static oleh compiler menjadi <code>&amp;'static str</code>. Hal ini karena deklarasi string literal pada program yang akan dipersisted kedalam binary program.
Tidak semua tipe akan di-infer secara otomatis oleh compiler sehingga butuh deklarasi static lifetime eksplisit.</p>
<h2 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision</a></h2>
<p>Adalah set of rules yang digunakan compiler untuk menentukan lifetime suatu/beberapa <em>borrowed</em> type tanpa deklarasi eksplisit. 
Berikut 3 rules tersebut:</p>
<ol>
<li>Compiler will assign unique lifetime to each parameters in function/inherent function/method.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: &amp;i32) --&gt; fn foo&lt;'a&gt;(x: &amp;'a i32)
fn foo(x: &amp;i32, y: &amp;i32) --&gt; fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>If there's only one parameter, then the parameter lifetime will be applied to all output parameters lifetime.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;i32) -&gt; (&amp;i32,&amp;i32,&amp;i32) --&gt; fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; (&amp;'a i32,&amp;'a i32,&amp;'a i32)
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Apply to method with multiple input parameters and one of them is <code>&amp;self</code> or <code>&amp;mut self</code>, the lifetime of <code>self</code> will be applied to all output parameters.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Type&lt;'a&gt; {
    fn method(&amp;self, &amp;str, &amp;str) -&gt; (&amp;str, &amp;str){...}
} 
// menjadi
impl&lt;'a&gt; Type&lt;'a&gt; {
    fn method&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b str, &amp;'c str) -&gt; (&amp;'a str, &amp;'a str){...}
}
<span class="boring">}</span></code></pre></pre>
<p>Deklarasi lifetime pada method signature tidak diperlukan ketika menulis program, karena sudah di-infer oleh lifetime elision rule yang mana lifetime yang akan digunakan adalah lifetime self dari <code>impl&lt;'a&gt;</code> dan <code>Type&lt;'a&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Error terjadi di dalam <em>fallible operations</em>, yaitu operasi-operasi yang memungkinkan terjadi efek samping diluar dugaan dan terjadi pada saat runtime. Hal-hal ini biasanya seperti <em>IO operations</em>, index access beyond size, etc. Di dalam Rust terdapat dua jenis eror yaitu: <em>Recoverable Error</em> and <em>Unrecoverable Error</em>.</p>
<ul>
<li><em>Recoverable Error</em> merupakan error karena kesalahan logic atau efek samping dari operasi IO. Error jenis ini dihandle menggunakan tipe data <code>Result&lt;T,E&gt;</code> yang merupakan tipe dasar sebuah enum yang menghasilkan salah satu dari dua kemungkinan yaitu <code>T</code> untuk berhasil, dan <code>E</code> untuk error. Setiap fungsi/method yang memiliki return type <code>Result</code> memiliki efek samping/kemungkinan error, sehingga ada penanganan khusus untuk dua kemungkinan return value.</li>
<li><em>Unrecoverable Error</em> merupakan error karena kesalahan teknis ketika program berjalan, seperti mengakses array diluar size. Error jenis ini akan menghasilkan kondisi disebut panic yang menyebabkan program exit.</li>
</ul>
<h2 id="recoverable-error"><a class="header" href="#recoverable-error">Recoverable Error</a></h2>
<p>Merupakan error yang disebabkan oleh efek samping dari program yang biasanya terjadi karena operasi-operasi yang bersifat <em>fallible</em> seperti IO atau interaksi dengan users. Error ini tentunya tidak mungkin menyebabkan program <em>down</em> karena kita tidak bisa sepenuhnya mengendalikan efek samping itu. Tipe data dasar yang disediakan Rust untuk meng-<em>handle</em> error jenis ini adalah enum <code>Result&lt;T,E&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result {
    Ok(T),  // T adalah tipe data jika proses berhasil dan mengembalikan nilai dengan tipe T
    Err(E), // E adalah tipe data jika proses gagal dan mengembalikan error dengan tipe E
}
<span class="boring">}</span></code></pre></pre>
<p><code>Result</code> Merupakan tipe varian yang memiliki dua kemungkinan yaitu berhasil(<code>Ok(T)</code>) atau error(<code>Err(e)</code>). Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fallible_function() -&gt; Result&lt;i32, String&gt; {
    // some process
    // Err(String::from(&quot;got error&quot;)) // jika gagal
    Ok(1) // jika berhasil
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-recoverable-error"><a class="header" href="#handling-recoverable-error">Handling Recoverable Error</a></h3>
<p>Ketika ingin memanggil fungsi/method yang memiliki kemungkinan error, tentunya kita ingin meng-handle error tersebut. Terdapat beberapa cara menghandle error di dalam Rust diantaranya:</p>
<h4 id="pattern-matching-menggunakan-match"><a class="header" href="#pattern-matching-menggunakan-match"><strong>Pattern matching Menggunakan <code>match</code></strong></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ret = fallible_function();
match ret {
    Ok(t) =&gt; println!(&quot;val: {}&quot;, t),
    Err(e) =&gt; panic!(&quot;{}&quot;, e),
}
<span class="boring">}</span></code></pre></pre>
<p>Pattern matching melakukan destrukturalisasi terhadap tipe data yang di-<em>match</em> sehingga kita bisa membaca value-value hasil destruktur dengan menulis signature tipe tersebut. Contoh di atas <code>fallible_function()</code> mengembalikan tipe <code>Result&lt;i32, String&gt;</code> sehingga berdasarkan definisi tipe enum Result menjadi:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Result&lt;i32, String&gt; = Ok(i32) | Err(String)
<span class="boring">}</span></code></pre></pre>
<p>Return value merupakan nilai antara i32 jika berhasil, atau String jika gagal/error.
Ketika ingin membaca value dari pattern matching, terdapat beberapa cara membaca:</p>
<ul>
<li><strong>Signature dengan variable</strong>
Ketika ingin membaca value dari <code>T</code> tanpa meng-enumerasi semua kemungkinan value tersebut, cukup dengan mendeklarasikan suatu variable arbitrary seperti:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match ret {
  // variable `t` bisa diganti menjadi apapun
  Ok(t) =&gt; println!(&quot;val: {}&quot;, t),
  // variable `e` bisa diganti menjadi apapun
  Err(e) =&gt; panic!(&quot;{}&quot;, e),
}
<span class="boring">}</span></code></pre></pre>
Tipe data dari variable tersebut sesuai dengan tipe data dari deklarasi <code>Result&lt;i32, String&gt;</code>.</li>
<li><strong>Signature dengan value</strong>
Ketika ingin memeriksa langsung kepada value yang diinginkan, bisa langsung menulis value yang diinginkan seperti:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match fallible_function() {
  // kita ingin memastikan bahwa kriteria berhasil hanya jika value dari T adalah 5
  Ok(5) =&gt; println!(&quot;berhasil&quot;),
  // kita menggunakan wildcard jika kita tidak 
  _ =&gt; panic!(&quot;panic&quot;),
}
<span class="boring">}</span></code></pre></pre>
Seperti yang sudah dibahas pada chapter algebraic types bahwa <code>match</code> bersifat <em>exhaustive</em> sehingga kita bisa menggunakan wildcard <code>_</code> untuk mengabaikan semua enumerasi value selain dari yang kita inginkan.</li>
</ul>
<h3 id="pattern-matching-menggunakan-macro-matches"><a class="header" href="#pattern-matching-menggunakan-macro-matches">Pattern Matching menggunakan macro <code>matches!</code></a></h3>
<p><code>matches!</code> merupakan macro yang melakukan pengecekkan match langsung terhadap ekspresi yang dimasukkan dengan pattern yang dicocokkan. Dengan ini tidak harus meng-enumerasi semua kemungkinan value, kita hanya ingin memeriksa value/pattern suatu variable/ekspresi. Macro ini mengembalikan boolean <code>true</code> jika sesuai.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = 123;
let ret = matches!(num, 4);
println!(&quot;{}&quot;, ret);

let option = Some(5);
let ret = matches!(option, Some(5));
println!(&quot;{}&quot;, ret);
<span class="boring">}</span></code></pre></pre>
<h4 id="associated-methods"><a class="header" href="#associated-methods">Associated Methods</a></h4>
<p>Tipe Result&lt;T,E&gt; memiliki beberapa methods untuk meng-<em>handle</em> tipe error recoverable diantaranya <code>unwrap</code>.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fallible_function&lt;'a&gt;() -&gt; Result&lt;i32, &amp;'a str&gt; {
    Err(&quot;error ninu ninu&quot;) // jika gagal
}

let resp = fallible_function();

/// unwrap akan mengembalikan nilai jika `Result` berhasil(Ok(T))
/// akan panic jika hasil tidak `Ok(T)`
/// *NOTE: hindari penggunaan `unwrap()` karena kita tidak pernah tau hasil dari fallible operation tersebut. Kecuali jika kita yakin 100% bahwa hasil Ok(T).
let ret = resp.unwrap();

/// unwrap_err akan mengembalikan error jika `Result` error(Err(E))
/// akan panic jika hasil tidak `Err(E)`
/// *NOTE: hindari penggunaan `unwrap_err()` karena kita tidak pernah tau hasil dari fallible operation tersebut. Kecuali jika kita yakin 100% bahwa hasil Err(E).
let ret = resp.unwrap_err();

/// unwrap_or mengembalikan nilai jika Ok(T), 
/// jika tidak, maka akan mengembalikan nilai alternatif `123` sesuai dengan tipe data T.
/// Gunakan jika kita memiliki alternatif value selain dari yang diharapkan.
let ret = resp.unwrap_or(123);

/// unwrap_or_default mengembalikan nilai jika Ok(T), 
/// jika tidak, akan mengembalikan default value sesuai dengan tipe data T(e.g. i32 -&gt; 0).
let ret = resp.unwrap_or_default();

/// unwrap_or_else akan mengembalikan nilai jika `Result` berhasil(Ok(T))
/// jika tidak, akan menjalankan suatu closure `FnOnce(E) -&gt; T` dimana `E` adalah value dengan tipe yang sama dengan error `E` dari `Result&lt;T,E&gt;` dan `T` adalah value dengan tipe yang sama dengan hasil `T` dari `Result&lt;T,E&gt;` yang merupakan alternatif dari return value ketika yang sebelumnya error.
/// Gunakan ini ketika kita memiliki alternatif lain dari T dalam Result&lt;T,E&gt; dengan menjalankan suatu fungsi.
let ret = resp.unwrap_or_else(|x| -&gt; i32 {
    println!(&quot;--:: {}&quot;, x);
    123
});
<span class="boring">}</span></code></pre></pre>
<p>Masih banyak associated methods lainnya yang harus dieksplor sendiri yang memiliki tujuan masing-masing.</p>
<h3 id="propagating-recoverable-error"><a class="header" href="#propagating-recoverable-error">Propagating Recoverable Error</a></h3>
<p>Ketika kita ingin mengembalikan error ke fungsi <code>caller</code> dan seterusnya atau membuat rantai return error, maka kita bisa menggunakan operator <code>?</code> atau disebut juga operator <code>try</code>. Hal ini dilakukan ketika kita ingin menyerahkan error handling kepada fungsi yang memanggil. Syarat untuk try operator adalah memiliki tipe yang sama antara <em>caller</em> dan <em>callee</em>. 
<em>Try</em> operator berlaku untuk untuk tipe <code>Result&lt;T,E&gt;</code> dan <code>Option&lt;T&gt;</code>. 
Pada pembahasan error handling ini, kita menggunakan try operator untuk tipe <code>Result&lt;T,E&gt;</code>. Try operator pada <code>Result&lt;T,E&gt;</code> akan meng-<em>unwrap</em> <code>T</code> jika Ok, atau <em>return</em> fungsi jika error dimana tipe <code>Err(E)</code> antara <em>caller</em> dan <em>callee</em> compatible.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function1() -&gt; Result&lt;String, String&gt; {
    let resp_funciton2 = function2()?; // if function2() return error, then this function will return the error from function2() into function1() error
    // do something with `resp`
    Ok(String::from(&quot;yay&quot;))
}

fn function2&lt;'a&gt;() -&gt; Result&lt;i32, &amp;'a str&gt; {
    Err(&quot;error in function 2&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas, tipe data error dari fungsi2/method2 yang mem-propagasi error harus memiliki tipe yang sama. Pada contoh di atas terlihat kalau tipe data tidak sama, akan tetapi contoh di atas berjalan dengan benar. Hal ini karena selain tipe yang sama, tipe berbeda bisa dengan syarat masing-masing tipe meng-implementasi trait conversion pada Rust yaitu <code>From&lt;T&gt;</code>. Dengan implementasi trait konversi ini, tipe error tetap bisa di propagasi tanpa error. Hal ini karena tipe <code>String</code> implement method <code>from</code> dari trait <code>From&lt;T&gt;</code> sehingga bisa membaca error dari function2() berupa <code>&amp;str</code>.</p>
<h2 id="unrecoverable-error"><a class="header" href="#unrecoverable-error">Unrecoverable Error</a></h2>
<p>Merupakan error yang tidak dapat ditolerir lagi karena bisa menyebabkan <em>undefined behaviour</em> pada program yang mana sebagian besar disebabkan oleh <em>logic error</em> dan juga beberapa side-effects. 
Pada saat panic terjadi, rust akan menghapus stack program atau yang disebut dengan <code>unwinding</code>.
Contoh dari error ini diantaranya: </p>
<h3 id="index-out-of-bound-access"><a class="header" href="#index-out-of-bound-access">index out of bound access</a></h3>
<p>Di antara hal yang lumrah pada bahasa pemograman manapun. Yang membedakan adalah bahasa dengan <em>safety measure</em> akan langsung memberikan error ketika ada access diluar bound array. Bahasa lain seperti C mungkin akan memberikan <em>undefined behaviour</em> dengan memberikan nilai tidak valid bagi program. Rust memiliki bound checking pada saat pengaksesan array sehingga mengembalikan error ketika akses melebihi ukuran array.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];

v[99];
<span class="boring">}</span></code></pre></pre>
<h3 id="memanggil-macro-panic"><a class="header" href="#memanggil-macro-panic">memanggil macro <code>panic!()</code></a></h3>
<p>Macro <code>panic!()</code> adalah macro untuk menyebabkan panic secara intentional ketika situasi tidak memungkinkan untuk meng-<em>recover</em> error yang terjadi.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_fail() {
  panic!(&quot;im done&quot;);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memanggil-associated-methods-yang-tidak-sesuai-dengan-value-yang-diharapkaneg-expect-atau-unwrap"><a class="header" href="#memanggil-associated-methods-yang-tidak-sesuai-dengan-value-yang-diharapkaneg-expect-atau-unwrap">memanggil associated methods yang tidak sesuai dengan value yang diharapkan(e.g. <code>expect</code> atau <code>unwrap</code>)</a></h3>
<p>Kali ini kita akan membahas <code>expect</code> dimana kita ingin menambahkan pesan tambahan pada panic ketika terjadi error dari hasil <code>Result&lt;T,E&gt;</code> dan kita ingin panic. Method <code>expect</code> ini biasa digunakan untuk inisiasi program dengan berbagai pra-kondisi yang harus dipenuhi sebelum program berjalan seperti dependensi dan lainnya. Jika hal-hal itu tidak terpenuhi maka tentunya program tidak bisa berjalan dan harus exit dengan panic. <code>expect</code> digunakan ketika kita ingin menambahkan informasi tambahan terkait operasi yang kita lakukan yang tidak diketahui oleh compiler.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
  let db_conn = init_db().expect(&quot;FAILED CONNECTING TO DB&quot;); // will return value of `DB` from function, or panic error with additional information
}

fn init_db() -&gt; Result&lt;DB, String&gt; {
  // logic for initiating DB connection
}</code></pre></pre>
<h3 id="testing-assertions"><a class="header" href="#testing-assertions">testing assertions</a></h3>
<p>Default behaviour dari fungsi-fungsi macro untuk test assertions ketika tidak sesuai ekspektasi adalah panic.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_addition() {
    let result = 2 + 2;
    assert_eq!(result, 5); // will cause fail tests and panic
}
<span class="boring">}</span></code></pre></pre>
<p>Ketika kita ingin melakukan recovery terhadap situasi panic, maka kita dapat menggunakan fungsi <code>std::panic::catch_unwind</code> yang menerima closure yang mungkin terjadi panic.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = std::panic::catch_unwind(|| {
    panic!(&quot;im panic&quot;);
});
assert!(result.is_err()); // result akan mengembalikan error karena kondisi unwind terjadi di dalam closure karena fungsi `panic!()` dipanggil.
<span class="boring">}</span></code></pre></pre>
<p>Pada development Rust, fungsi <code>catch_unwind</code> ini sangat jarang digunakan karena error yang disebabkan oleh panic memang error yang tidak bisa ditolerir yang bisa menyebabkan <em>undefined behaviour</em> pada program, ada side effects lainnya. Hal lain juga penyebab error panic ini jauh lebih kecil dibandingkan error yang disebabkan oleh IO atau side-effects lainnya, sehingga programmer sebaiknya mengantisipasi error ini pada saat development ditambah dengan testing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-test"><a class="header" href="#unit-test">Unit Test</a></h1>
<p>Unit Test adalah untuk mengvalidasi/mengverifikasi suatu fungsi/method terhadap semua kemungkinan input dan output. Unit test harus mengcover banyak edge cases dari suatu program agar mengurangi bugs. Unit Test juga digunakan dalam <em>code coverage</em> agar semua logic terkover dari semua path yang mungkin ada pada program. Ada berbagai macam cara Unit Test tergantung bahasa pemograman yang digunakan. Sebagian besar Unit Test bersifat idempotent sehingga ketika dijalankan berulang-ulang tidak ada yang berubah dan akan selalu menghasilkan output yang sama, dalam bahasa lain bisa juga disebut <em>stateless</em>. Hal ini bagian dari otomatisasi testing yang juga akan dilakukan dalam pipeline CI/CD. Kali ini kita akan bahas mekanisme testing dalam Rust.</p>
<p>Rust menggunakan 2 macro untuk menandai segment code untuk testing, yaitu <code>#[cfg(test)]</code> dan <code>#[test]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// #[cfg(test)] menandakan module sebagai testing sehingga tidak dimasukkan pada saat kompilasi/build(cargo build) program, hanya dieksekusi dengan perintah `cargo test`
#[cfg(test)]
mod tests {
    use super::*;

    // #[test] menandakan fungsi testing yang akan dieksekusi oleh `cargo test`.
    #[test]
    fn test_add() {
        assert!(5 == add(3, 2));  // memvalidasi suatu ekspresi bernilai true
        assert_eq!(5, add(3, 2)); // memvalidasi 2 values/ekspresi memiliki nilai yang sama
        assert_ne!(2, add(3, 2)); // memvalidasi 2 values/ekspresi tidak memiliki nilai yang sama

        // secara manual panic untuk menandakan failed test
        if add(3, 2) != 5 {
            panic!(&quot;unexpected&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><code>#[cfg(test)]</code> membuat semua code yang berada dibawah macro ini tidak dimasukkan pada saat kompilasi ke dalam binary dan hanya berjalan pada perintah <code>cargo test</code>.
Semua fungsi test harus memiliki macro <code>#[test]</code> untuk menandakan fungsi yang akan dijalankan. Semua fungsi-fungsi ini berjalan secara parallel secara default.
Jika ingin berjalan tidak paralel, kita cukup membatasi thread eksekusi testing menjadi 1</p>
<pre><code>$ cargo test -- --test-threads=1
</code></pre>
<p><code>#[test]</code> hanya berlaku untuk fungsi/method yang <em>synchronous</em>, untuk fungsi/method yang bersifat <em>asynchronous</em> bisa menggunakan library async seperti tokio menggunakan macro <code>#[tokio::test]</code>.</p>
<h2 id="organisasi-unit-testing"><a class="header" href="#organisasi-unit-testing">Organisasi Unit Testing</a></h2>
<p>Kode unit test sebaiknya dikelompokkan ke dalam module terpisah sehingga lebih mudah menandakan segment code yang digunakan untuk testing. Ketika unit testing code semakin bertambah maka akan memudahkan memberikan configurasi <code>#[cfg(...)]</code> pada segment code di bawah <code>mod</code> tersebut.</p>
<p>Tidak ada konvensi khusus mengenai dimana letak kode unit tests ini. Code unit testing sama layaknya code lainnya di dalam rust yaitu berlaku enkapsulasi public dan private dari suatu kode. Sehingga ada pros and cons terhadap beberapa implementasi unit testing.</p>
<ul>
<li>Jika unit tests di taruh di file terpisah seperti pada konvensi Golang, seperti <em>file_name_test.rs</em>, maka code yang bisa diimport ke dalam unit tests hanyalah kode public. Hal ini karena sebuah file di dalam rust juga secara tidak langsung merupakan module <code>mod</code> tersendiri, dan antar sesama file merupakan sibling yang tidak bisa mengakses private functions mod/file lain dalam level yang sama(sibling). Sisi positif nya adalah separasi kode production dan kode testing per file.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// a.rs
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn priv_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// ------------------------------------

/// a_test.rs
/// 
/// import module dari dari file lain lewat namespace crate karena bukan di dalam file main.rs/lib.rs, dan merupakan module/file yang berada pada level yang sama. 
use crate::a;

#[test]
fn test_add_file() {
    // akses a::add berhasil karena fungsi add() public
    assert!(5 == a::add(3, 2));
    assert_eq!(5, a::add(3, 2));
    assert_ne!(2, a::add(3, 2));

    if a::add(3, 2) != 5 {
        panic!(&quot;unexpected&quot;);
    }

    // akses a::priv_add tidak bisa karena fungsi priv_add private
    if a::priv_add(3, 2) != 5 {
        panic!(&quot;unexpected&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Jika unit tests di taruh di dalam module di dalam suatu file/module, maka relasi kedua module ini menjadi parent-child, dimana kode child bisa mengakses semua code yang ada di parent level. Cara ini digunakan ketika ada banyak private code di dalam suatu module sehingga butuh deklarasi unit tests di dalam submodule tersebut. Sisi buruk nya tentu kode production bercampur dengan kode testing, dalam sudut pandang user tentunya, bukan compiler.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn priv_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::{add, priv_add};

    // kedua fungsi add dan priv_add dapat diakses dari dalam submodule karena relasi module ini(tests) dan parent nya lewat `use super::*`.

    #[test]
    fn test_add() {
        assert_eq!(5, add(3, 2));
    }

    #[test]
    fn test_priv_add() {
        assert_eq!(5, priv_add(2, 3));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-kode-yang-mungkin-panic"><a class="header" href="#testing-kode-yang-mungkin-panic">Testing Kode yang mungkin Panic</a></h2>
<p>Ada kalanya kita akan menemukan suatu operasi yang memiliki kemungkinan panic. Secara default panic adalah pertanda failed tests di dalam rust, sehingga untuk meng-<em>assert</em> panic ini dibutuhkan macro <code>#[should_panic]</code> setelah macro <code>#[test]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn im_panic() {
    panic!(&quot;OH NO!!!&quot;);
}

mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn test_im_panic() {
        im_panic();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Sekalipun ketika test dijalankan menghasilkan stack trace panic, kode test ini dianggap berhasil oleh <code>cargo test</code>.
Jika kode berhasil justru dianggap test gagal karena macro <code>#[should_panic]</code>.</p>
<h2 id="menggunakan-enum-resulte"><a class="header" href="#menggunakan-enum-resulte">Menggunakan Enum Result&lt;(),E&gt;</a></h2>
<p>Selain panic, kita bisa menggunakan return value <code>Result&lt;(),E&gt;</code> pada saat unit testing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_add_result() -&gt; Result&lt;(),String&gt; {
    let expected = 5;
    let result = add(3,2);
    if result != expected {
        return Err(&quot;ERROR!!!&quot;.to_owned());
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Tipe <code>T</code> haruslah <code>()</code> karena merupakan konvensi dari cargo. Untuk tipe <code>E</code> kita bisa menggunakan tipe apapun.</p>
<h2 id="menampilkan-output"><a class="header" href="#menampilkan-output">Menampilkan output</a></h2>
<p>Secara default jika kita mem-print sesuatu menggunakan <code>println!</code> atau <code>dbg!</code> ketika test berhasil menggunakan <code>cargo test</code> maka tidak memprint apa-apa karena ketika test berhasil semua output ke stdout di-<em>capture</em> oleh rust lebih duluan. Jika kita ingin tetap menampilkan output tersebut bisa menggunakan flag <code>cargo test -- --show-output</code>.</p>
<h2 id="menfilter-unit-tests"><a class="header" href="#menfilter-unit-tests">Menfilter Unit Tests</a></h2>
<p>Ketika kita hanya ingin menjalankan unit test tertentu saja kita bisa menulis <code>cargo test &lt;pathname/filename/part_of_path_or_file&gt;</code>, dimana argumen tambahan ke dalam command tersebut merupakan pattern yang menyerupai fullpath(mod), filename, atau nama fungsi test.
Contoh:</p>
<pre><code class="language-bash">$ cargo test test_add # menjalankan fungsi test test_add atau pathname/filename yang menyerupai
# contoh file-file yang mungkin dijalankan oleh command di atas adalah:
# test_add
# test_add_success
# test_add_failed
# test_a

$ cargo test test_ # menjalankan fungsi a::b::c::test_
# file-file atau kode test yang akan di jalankan dengan perintah di atas adalah semua kode tests dengan path `a::b::c::test_*`
</code></pre>
<h2 id="mengabaikan-unit-tests"><a class="header" href="#mengabaikan-unit-tests">Mengabaikan Unit Tests</a></h2>
<p>Mengabaikan fungsi test bisa menggunakan macro <code>#[ignore]</code> setelah deklarasi <code>#[test]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn priv_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::{add, priv_add};

    // kedua fungsi add dan priv_add dapat diakses dari dalam submodule karena relasi module ini(tests) dan parent nya lewat `use super::*`.

    #[test]
    fn test_add() {
        assert_eq!(5, add(3, 2));
    }

    #[test]
    #[ignore]
    fn test_priv_add() { // unit test will be ignored when we run cargo test
        assert_eq!(5, priv_add(2, 3));
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-dan-konfigurasi"><a class="header" href="#cargo-dan-konfigurasi">Cargo dan Konfigurasi</a></h1>
<p>Kita akan membahas mengenai build system dan package manager Rust yaitu <strong>Cargo</strong>, beserta konfigurasi projek Rust menggunakan standard konfig file Cargo yaitu .toml.
Kita sudah membahas mengenai installasi Rust yang sudah include Cargo menggunakan rustup. Pada chapter <strong>toolchain</strong> kita sudah membahas beberapa commands yang ada di Cargo untuk daily usages di dalam Rust. Kali ini kita akan membahas lebih lanjut dan juga konfigurasi projek Rust.</p>
<h2 id="struktur-projek-cargo"><a class="header" href="#struktur-projek-cargo">Struktur Projek Cargo</a></h2>
<p>Pada module 4 Struktur kita telah membahas struktur code base secara sederhana yaitu terdiri dari directory <code>src</code>, <code>target</code> dan file <code>Cargo.toml</code> dan <code>Cargo.lock</code>. 
Kali ini kita akan membahas kaitannya dengan Cargo dan konfigurasi nya. Berikut struktur codebase cargo secara keseluruhan:</p>
<pre><code>.
 Cargo.lock                          # hasil compiled Cargo.toml
 Cargo.toml                          # konfigurasi projek cargo
 src/                                # directory berisi codebase utama
  lib.rs                          # crate non-executable, to be imported
  main.rs                         # main crate for executable
  bin/                            # folder konvensi cargo dimana cargo akan menganggap file2 .rs di dalam ini sebagai entry point executable
        named-executable.rs         # executable ketika di run/build `cargo run/build --bin named-executable
    another-executable.rs       # executable ketika di run/build `cargo run/build --bin another-executable
    multi-file-executable/      # executable ketika di run/build `cargo run/build --bin multi-file-executable
        main.rs                 # ^command di atas akan meng-execute file main.rs ini
        some_module.rs          # module yang akan dipanggil oleh main.rs di dalam directory ini.
 benches/
  large-input.rs
  multi-file-bench/
      main.rs
      bench_module.rs
 examples/
  simple.rs
  multi-file-example/
      main.rs
      ex_module.rs
 tests/                              # contain integration tests
     some-integration-tests.rs
     multi-file-test/
         main.rs
         test_module.rs
</code></pre>
<h2 id="konfigurasi-cargotoml"><a class="header" href="#konfigurasi-cargotoml">Konfigurasi Cargo.toml</a></h2>
<p>Projek Rust menggunakan Cargo sebagai build system menggunakan Cargo.toml sebagai file konfigurasi projek. Komponen lengkap dari Cargo.toml bisa dilihat di <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">sini</a>, akan tetapi pada kali ini kita cuma akan membahas yang umum pada projek yaitu:</p>
<ul>
<li>[package] : Setiap distributable rust program disebut package. Setiap package memiliki konfigurasi cargo di dalam Cargo.toml. Memiliki beberapa sub-konfigurasi diantaranya: <em>name</em>, <em>version</em>, <em>edition</em>, dan lainnya.</li>
<li>[profile] : build profile sebagai konfigurasi kompilasi program. Terdiri dari <em>dev</em> dan <em>release</em>.</li>
<li>Target tables: Mendeklarasi target kompilasi/build cargo. Memiliki jenis di antaranya: [lib], [[bin]], [[example]], [[test]], [[bench]].</li>
<li>Dependency tables: Mendeklarasi dependencies dari package tersebut.</li>
<li>[workspace] : konfigurasi Cargo.toml untuk level workspace.</li>
<li>[features] : kondisional kompilasi</li>
</ul>
<h3 id="package"><a class="header" href="#package">[package]</a></h3>
<p>Secara default ketika menginisiasi program, Cargo menginisiasi 3 fields name, version, dan edition. 2 field pertama minimal wajib untuk cargo dapat membaca sebuah package. <em>name</em> mengindikasikan nama package ketika akan di-distribusikan baik internal maupun eksternal. Versi menandakan versi dari package. Berikut beberapa fields lainnya:</p>
<ul>
<li><strong>name</strong>: nama package yang digunakan sebagai identifier ketika mengekspor internal(memanggil sesama crates) atau eksternal(crates.io).</li>
<li><strong>version</strong>: versi dari package</li>
<li><strong>authors</strong>: daftar owners, maintainers, apapun yang pernah ngurus projek tersebut.</li>
<li><strong>edition</strong>: Rust edition. Cargo secara otomatis menggenerate sesuai dengan versi cargo yang digunakan untuk menggenerate.</li>
<li><strong>rust-version</strong>: Minimal rust version supported.</li>
<li><strong>description</strong>: deskripsi package</li>
<li><strong>documentation</strong>: link ke dokumentasi package.</li>
<li><strong>repository</strong>: link ke repo</li>
<li>...dan masih banyak lainnya silahkan di cek di sini <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-package-section">package</a></li>
</ul>
<p>Contoh:</p>
<pre><code class="language-ini">[package]
name = &quot;basics_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
...
</code></pre>
<h3 id="build-profile"><a class="header" href="#build-profile">Build Profile</a></h3>
<p>Terdapat 2 jenis build profile di dalam Rust: <strong>dev</strong> dan <strong>release</strong> profile. </p>
<ul>
<li><strong>dev</strong> profile: merupakan profile build untuk level development dimana beberapa config di-setup default untuk development mode. Berikut konfigurasi beserta default values dari dev mode:</li>
</ul>
<pre><code class="language-ini">[profile.dev]
# optimization level.
# 0 = no optimization, used for development/debugging, faster compilation, slower binary
# 1 = basic optimizations, perform little bit optimization, but not as much as producing production binary.
# 2 = some optimizations, more than basics optimization, might be used in production if faster compilation needed than faster binary.
# 3 = full optimizations, apply all possible optimizations to the code resulting in slowest compilation, but fastest binary.
# &quot;s&quot; = optimization for binary size
# &quot;z&quot; = no loop vectorization
opt-level = 0

# untuk mengaktifkan debuginfo pada binary hasil build, bekerja sama dengan llvm untuk generate debuginfo-nya
debug = true

# debug info dipisah dari file hasil compiled. Platform specific.
split-debuginfo = '...'  # Platform-specific.

# runtime validation checking for dev mode, like `debug_assert!()` macro.
debug-assertions = true

# Memeriksa overflow pada operasi terhadap integer.
# true: panic jika overflow.
# false: circular effect jika overflow, misal 255_u8 + 1_u8 = 3.
overflow-checks = true

# link-time optimization merupakan fitur llvm dimana melakukan optimisasi cross module/code unit/crates.
# thin/false: melakukan sedikit optimisasi pada saat linking stage dalam proses kompilasi. Lebih cepat dalam proses kompilasi, tetapi tidak menghasilkan binary yang optimal.
# fat/true: melakukan optimisasi keseluruhan pada saat compile time menyebabkan kompilasi lebih lama, tetapi menghasilkan binary yang lebih optimal.
# off: tidak melakukan lto sama sekali
lto = false

# Apa yang akan dilakukan ketika panic terjadi:
# unwind: hapus stackframe(reset) lalu stop program
# abort: langsung stop program
panic = 'unwind'

# incremental build, menyimpan state2 untuk kompilasi berikutnya sehingga tidak harus build dari scratch(faster compilation)
# true: incremental
# false: clean build, used for production release
incremental = true

# codegen-units adalah serpihan hasil build suatu crate. Semakin banyak maka proses kompilasi semakin cepat karena compiler akan melakukan kompilasi parallel sebanyak mungkin, akan tetapi ini menghasilkan binary kurang optimal sehingga hanya cocok untuk dev mode. Untuk production release menggunakan angka yang lebih sedikit dari dev mode.
codegen-units = 256

# https://en.wikipedia.org/wiki/Rpath
rpath = false
</code></pre>
<ul>
<li><strong>release</strong> profile: merupakan profile build untuk level production dimana beberapa config di-setup se-<em>optimized</em> mungkin untuk production release. Berikut konfigurasi beserta default values dari release mode:</li>
</ul>
<pre><code class="language-ini">[profile.release]
opt-level = 3
debug = false
split-debuginfo = '...'  # Platform-specific.
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<p>Merupakan hasil kompilasi kedalam binary/object file ketika projek di-build. Setiap target direpresentasikan oleh crate. Terdapat 5 jenis target di-antaranya:</p>
<ul>
<li><strong>Library(<code>[lib]</code>)</strong>: hasil kompilasi dari crate library di dalam direktori src. 1 package hanya bisa memiliki 1 library target/crate.</li>
<li><strong>Binaries(<code>[[bin]]</code>)</strong>: hasil kompilasi dari crate binary di dalam direktori src. 1 package dapat memiliki beberapa target/crate.</li>
<li><strong>Examples(<code>[[example]]</code>)</strong>: hasil kompilasi dari crate example di dalam direktori sendiri dari root level. 1 examples bisa memiliki beberapa executable example.</li>
<li><strong>Tests(<code>[[test]]</code>)</strong>: hasil kompilasi dari crate test di dalam direktori sendiri dari root level. 1 tests bisa memiliki beberapa executable test.</li>
<li><strong>Benchmarks(<code>[[bench]]</code>)</strong>: hasil kompilasi dari crate benchmark di dalam direktori sendiri dari root level. 1 benchmarks bisa memiliki beberapa executable benchmark.</li>
</ul>
<p><strong>Konfigurasi target</strong></p>
<pre><code class="language-ini">[lib]/[[bin]]/[[example]]/[[test]]/[[bench]]
name = &quot;foo&quot;           # Nama target yang akan digunakan sebagai identifier pada saat memanggil/mengimport target.
path = &quot;src/lib.rs&quot;    # source file relative terhadap Cargo.toml
test = true            # Is tested by default.
doctest = true         # Documentation for lib
bench = true           # Is benchmarked by default.
doc = true             # Is documented by default.
plugin = false         # Used as a compiler plugin (deprecated).
proc-macro = false     # Set to `true` for a proc-macro library.
harness = true         # Use libtest harness.
edition = &quot;2015&quot;       # The edition of the target.
crate-type = [&quot;lib&quot;]   # Binaries, Tests, dan Benchmarks set to &quot;bin&quot;, others can be &quot;lib&quot; and/or &quot;proc-macro&quot; for Libraries and Examples
required-features = [] # Features required to build this target (N/A for lib).
</code></pre>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<p>Merupakan list dari semua dependencies yang digunakan oleh program/projek cargo tersebut. Terdapat 4 jenis dependencies:</p>
<ul>
<li>[dependencies] : dependencies yang akan dikompilasi bersama binaries hasil akhir executable dengan perintah &quot;cargo build...&quot;</li>
<li>[dev-dependencies] : dependencies yang hanya di kompilasi pada saat melakukan testing dengan perintah &quot;cargo test...&quot;, juga untuk examples and benchmarks.</li>
<li>[build-dependencies] : dependencies untuk build script yang berjalan ketika menginisiasi program.</li>
<li>[target] : dependencies specific untuk platform tertentu(e.g. OS tertentu)</li>
</ul>
<p><strong>Spesifikasi dependencies</strong>
TODO</p>
<h3 id="workspace-1"><a class="header" href="#workspace-1">[workspace]</a></h3>
<p>Deklarasi konfigurasi workspace yang memiliki beberapa packages di dalamnya. Terdapat dua jenis penulisan workspace:</p>
<ul>
<li>Workspace dengan root package: 
<ul>
<li>Terdapat satu package di level root workspace sebagai root package</li>
<li>Contoh deklarasi:</li>
</ul>
<pre><code class="language-ini">[workspace]
members = [&quot;subpackage1&quot;,&quot;subpackage2&quot;]

# root package
[package] 
name = &quot;hello_world&quot; # the name of the package
version = &quot;0.1.0&quot;    # the current version, obeying semver
authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]
</code></pre>
</li>
<li>Workspace tanpa root package
<ul>
<li>Semua packages berada pada level yang sama</li>
<li>Contoh deklarasi:</li>
</ul>
<pre><code class="language-ini">[workspace]
members = [
  &quot;package1&quot;,
  &quot;package2&quot;,
  ...]
</code></pre>
</li>
</ul>
<h4 id="workspacepackage"><a class="header" href="#workspacepackage">[workspace.package]</a></h4>
<p>Ketika ingin mendeklarasi package yang bisa di-inherited oleh members workspace.
Contoh:</p>
<pre><code class="language-ini"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = [&quot;bar&quot;]

[workspace.package]
version = &quot;1.2.3&quot;
authors = [&quot;Nice Folks&quot;]
description = &quot;A short description of my package&quot;
documentation = &quot;https://example.com/bar&quot;
</code></pre>
<p>Ketika ingin inherit beberapa keys, bisa menggunakan <code>{key}.workspace = true</code></p>
<pre><code class="language-ini"># [PROJECT_DIR]/bar/Cargo.toml
[package]
name = &quot;bar&quot;
version.workspace = true
authors.workspace = true
description.workspace = true
documentation.workspace = true
</code></pre>
<h4 id="workspacedependencies"><a class="header" href="#workspacedependencies">[workspace.dependencies]</a></h4>
<p>Ketika ingin mendeklarasi dependencies yang bisa di-inherited oleh members workspace.
Contoh:</p>
<pre><code class="language-ini"># [PROJECT_DIR]/Cargo.toml
[workspace]
members = [&quot;bar&quot;]

[workspace.dependencies]
cc = &quot;1.0.73&quot;
rand = &quot;0.8.5&quot;
regex = { version = &quot;1.6.0&quot;, default-features = false, features = [&quot;std&quot;] }
</code></pre>
<p>Ketika ingin inherit beberapa keys, bisa menggunakan <code>{key}.workspace = true</code></p>
<pre><code class="language-ini"># [PROJECT_DIR]/bar/Cargo.toml
[package]
name = &quot;bar&quot;
version = &quot;0.2.0&quot;

[dependencies]
regex = { workspace = true, features = [&quot;unicode&quot;] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand.workspace = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h1>
<p>Pada bagian ini akan membahas mengenai hal lebih lanjut mengenai Functional Programming, khususnya pada Rust, smart pointers, IO, dan asynchronous.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h1>
<p><em>Say this with me:</em></p>
<blockquote>
<p><em>Monad is just a monoid in the category of endofunctors, What's the problem?</em> <a href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">[1]</a></p>
</blockquote>
<p><em>Before jumping into functional programming world, you have to be able to decipher what above sentence is all about. Because functional programming mostly revolves around Monad concept. But, before we decipher that, I will explain some basic concepts related to functional programming first.</em></p>
<p>Functional Programming merupakan pendekatan lain di dalam dunia pemograman(selain Procedural Programming) dimana kode program dirangkai sedemikian rupa menggunakan beberapa konsep dan notasi matematika seperti <em>set</em> dan <em>category</em>.</p>
<p>Berbeda dengan Procedural Programming yang terinspirasi langsung dari Turing Machine(Alan Turing), Functional Programming datang dari Church's Thesis(Alonzo Church) dimana program melakukan komputasi menggunakan serangkaian fungsi-fungsi yang di-<em>compose</em> sedemikian rupa. Church Thesis juga berpendapat bahwa setiap fungsi yang computable harus turing complete(computable by Turing Machine), sehingga Church's Thesis ini juga bisa disebut sebagai abstraksi lebih besar dari Turing Machine tentang bagaimana meng-ekspresikan komputasi ke dalam notasi matematika(fungsi).<a href="https://en.wikipedia.org/wiki/Church%27s_thesis_(constructive_mathematics)">[1]</a>,<a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">[2]</a></p>
<p>Berikut beberapa perbedaan Procedural Programming dan Functional Programming:</p>
<div class="table-wrapper"><table><thead><tr><th>Procedural</th><th>Functional</th></tr></thead><tbody>
<tr><td>Imperative</td><td>Declarative</td></tr>
<tr><td>Mutability</td><td>Immutability</td></tr>
<tr><td>Stateful</td><td>Stateless</td></tr>
<tr><td>Statement</td><td>Expression</td></tr>
<tr><td>Top-Down</td><td>Left-Right</td></tr>
<tr><td>Non-Algebraic</td><td>Algebraic</td></tr>
<tr><td>Low-context</td><td>High-context</td></tr>
<tr><td>E.g. Assembly, C, Go</td><td>E.g. Haskell, OCaml, Rust</td></tr>
</tbody></table>
</div>
<ul>
<li>Imperative cenderung menerapkan code program <em>step-by-step</em> dari atas ke bawah dan melakukan mutasi terhadap suatu data(dynamic). Sedangkan Declarative cenderung merangkai code program dalam bentuk <em>function compositions</em> dengan transisi data di antaranya tanpa ada mutasi terhadap data original.</li>
<li>Statements cenderung tidak memiliki values, hanya command yang melakukan proses terhadap suatu data yang dimasukkan. Sedangkan Expressions merupakan values itu sendiri yang bisa dirangkai dengan fungsi-fungsi lainnya untuk proses komputasi.</li>
<li>Pada bahasa yang memiliki non-algebraic data types, tipe data cenderung refleksi langsung dari layout memory secara low level. Tipe data tersebut tidak bisa/kurang optimal jika dikorelasikan dengan teori set dan kategori pada aljabar. Contoh: Pointer(C, C++, Go, etc), class/object(Java, C#, etc), interface(Go, Java, C, etc), beberapa tipe data pada bahasa C dan C++ dimana jika tidak dideklarasikan value, maka akan memberi default value diluar dugaan kita dan bisa menghasilkan UB(Undefined Behaviour).</li>
<li>Pada Bahasa yang memiliki algebraic data types, tipe data cenderung refleksi dari teori set dan kategori di dalam aljabar, sehingga sangat bisa dinotasikan dengan konsep tersebut di dalam pemograman. Contoh: Product Types(record, struct, tuple), Sum Types(enum in Rust, etc), reference types, hampir semua tipe data di dalam Rust bersifat algebraic karena mereka semua antara <em>set</em> dan <em>kategori</em> di dalam aljabar. Oleh karenanya di dalam Rust tidak ada empty/default values(kecuali <code>unsafe</code>), jika mau, maka harus dideklarasi secara manual. Trait di dalam rust pun bersifat algebraic karena berbeda dengan interface pada bahasa lain, trait bisa digunakan sebagai superset dari suatu tipe, untuk memberi spesifikasi dan juga mengelompokkan suatu tipe data/set.</li>
<li>Bahasa procedural cenderung menghandle error menggunakan throws/try-catch, sedangkan bahasa functional cenderung menggunakan sum type.</li>
</ul>
<p>Melihat beberapa perbedaan di atas, kita bisa lebih lanjut menjabarkan beberapa karakteristik dari Functional Programming, di antaranya:</p>
<ul>
<li><em>Immutability</em>: sifat immutability merupakan requirement dasar dan wajib dalam functional programming, karena di dalam FP, side effects dan segala macam variants dari suatu data sangat dihindari, karena bisa merusak abstraksi dan komposisi data dan fungsi. Ketika ingin melakukan transformasi/perubahan data, yang biasa dilakukan adalah menerapkan fungsi transformasi pada data original tanpa mengubah data original tersebut.</li>
<li><em>First-order function</em>: merupakan function yang mana function diterapkan sebagai unit dasar dalam komputasi yang bisa dilempar kemana-mana sebagai parameter pada fungsi lainnya atau sebagai value/argument.</li>
<li><em>Higher-order function</em>: merupakan function yang meng-komposisi beberapa fungsi untuk melakukan komputasi dan menghasilkan suatu value atau function. Kadang disebut juga sebagai kombinator, karena fungsinya yang mengkombinasikan beberapa <em>first-order functions</em>.</li>
<li><em>Algebraic types</em>: merupakan tipe data yang bisa merepresentasikan konsep set dan kategori yang ada pada aljabar kedalam kode pemograman dan menerapakan beberapa fungsi padanya.</li>
<li><em>Monadic</em>: merupakan tipe data yang memiliki sifat monadic, yaitu monoid yang di-wrap ke dalam type constructor dengan beberapa fungsi yang bisa meng-<em>flatten</em> data di dalamnya dan me-<em>mapping</em> data tersebut dengan suatu/beberapa proses(arrows).</li>
</ul>
<p><em>Disclaimer</em>: perbedaan dan konsep di atas tidak selalu bersifat absolute. Ada suatu bahasa pemograman yang cenderung procedural, ada yang cenderung functional, dan ada juga yang pure. Contoh: Assembly purely procedural, C kebanyakan procedural, Go kebanyakan procedural, Rust kebanyakan functional, Haskell purely functional.</p>
<h1 id="konsep-dasar"><a class="header" href="#konsep-dasar">Konsep Dasar</a></h1>
<p>Functional programming revolve around istilah matematika aljabar, khususnya dalam ranah ilmu set dan kategori. Berikut beberapa hal yang berkaitan dengan Functional Programming:</p>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<p>Set adalah sekumpulan objek yang memiliki kesamaan dan unik.
Unik dalam artian tidak boleh ada objek yang sama/ganda di dalam set tersebut.
Di dalam dunia pemograman, <strong>set</strong> bisa disamakan dengan tipe data, e.g integer, float, chars, booleans, etc.</p>
<h2 id="category"><a class="header" href="#category">Category</a></h2>
<p>Category merupakan abstraksi lebih besar dari set, dimana merupakan sekumpulan dari objek di dalam suatu set. Bisa juga disebut sebagai abstraksi suatu data di dalam suatu set di dalam suatu category. Selain itu objek yang telah menjadi category ini memiliki 2 karakteristik:</p>
<ul>
<li>Memiliki arrows function ter-<em>associate</em> dengannya. Arrows function merupakan semacam anonymous function yang dapat di-embed menjadi argument untuk melakukan transformasi category.</li>
<li>Memiliki identity arrows, merupakan identity function yang menerima data dan mengembalikan data yang sama, <code>f(x) -&gt; x, x  A</code></li>
</ul>
<p>Di dalam dunia pemograman, <strong>category</strong> bisa disamakan dengan <em>container</em>/<em>type constructor</em>, yaitu tipe data yang memiliki data lain di dalamnya, contoh: Vec&lt;T&gt;, HashMap&lt;K,V&gt;, LinkedList&lt;T&gt;, etc. Setiap container tersebut memiliki associative functions yang memproses arrows yang diterima.</p>
<p>Category bisa juga disebut sebagai <em>shape</em>, dimana, sekalipun memiliki tipe data yang berbeda programmatically, jika memiliki shape yang sama, maka masih bisa dimasukkan ke kategori yang sama. </p>
<p>Contoh: array dari 2-tuple([(k1,v1), (k2,v2), ...]) dan HashMap&lt;K,V&gt; memiliki tipe data yang berbeda, akan tetapi memiliki kategori yang sama, karena sejatinya map itu memang sekumpulan/array dari key dan value.</p>
<h2 id="magma"><a class="header" href="#magma">Magma</a></h2>
<p>Magma adalah suatu <em>set</em> yang berisi data dengan elemen yang sama, ketika operasi binary diaplikasikan ke dua buah data di dalam set tersebut, menghasilkan data yang juga berada di dalam set tersebut. </p>
<blockquote>
<p>a  S, b  S --&gt; ab  S</p>
</blockquote>
<p>Contoh adalah operasi pada bilangan bulat positif.
Operasi binary yang bisa di-aplikasikan terhadap bilangan bulat positif adalah +,*,-,/.</p>
<p><code>a  UInt, b  UInt --&gt; ab  UInt</code></p>
<p>ab  UInt:</p>
<ul>
<li>a+b  UInt, 1+2   = 3, 3  UInt</li>
<li>a*b  UInt, 1*2 = 2, 2  UInt</li>
<li>a/b  UInt, 1/2   = 0.5, 0.5 ~ UInt (not magma)</li>
<li>a-b  UInt, 1-2   = -1, -1 ~ UInt (not magma)</li>
</ul>
<p>Sehingga yang termasuk magma untuk UInt adalah <code>a+b</code> dan <code>a\*b</code> karena hasil nya pasti di dalam set yang sama yaitu Unsigned Integer.</p>
<h2 id="semigroup-magma--associative"><a class="header" href="#semigroup-magma--associative">Semigroup (Magma + Associative)</a></h2>
<p>Semigroup adalah suatu set yang memiliki operasi binary terhadap lebih dari dua input data dan bisa dikombinasikan dengan berbagai cara sehingga tetap menghasilkan hasil yang sama di dalam set yang sama.</p>
<blockquote>
<p>a  S, b  S, c  S --&gt; (ab)c = a(bc)  S</p>
</blockquote>
<p>Contoh:</p>
<pre><code>(1+2)+3 = 1+(2+3)   = 6 
3+3     = 1 + 5     = 6
</code></pre>
<p>Maka operasi <code>+</code> terhadap 3 bilang bulat di atas bersifat semigroup karena bagaimanapun urutan operasi yang dilakukan, akan menghasilkan nilai yang sama.</p>
<h2 id="monoid-magma--associative--identity"><a class="header" href="#monoid-magma--associative--identity">Monoid (Magma + Associative + Identity)</a></h2>
<p>Monoid adalah suatu set yang memenuhi kriteria:</p>
<ul>
<li>Magma yang bersifat associative untuk data lebih dari 2 -&gt; Semigroup, dan</li>
<li>Semigroup yang memiliki identity element/function sehingga element/function ini tidak merubah data/value tersebut(neutral)
Identity element bisa juga disebut debagai default values/empty values dari suatu set jika diterapkan suatu operasi binary tidak mengubah value dari data di dalam set tersebut, contoh operasi pertambahan, maka default values dari integer adalah <code>0</code>.</li>
</ul>
<p>Setiap set memiliki identity element(jika value) atau identity function(jika function) yang mana apabila diapply dengan suatu operasi binary, akan menghasilkan value yang sama. Hampir di semua bahasa pemograman dengan tipe data tertentu memiliki identity element atau identity function yang bisa diterapkan padanya. 
Hampir semua tipe data di Rust bisa disebut monoid.</p>
<h2 id="arrow"><a class="header" href="#arrow">Arrow</a></h2>
<p>Merupakan function yang akan di-inject ke dalam functor dan terkomposisi melakukan pemosresan data dari sebuah category.</p>
<pre><code>(A) -&gt; B
</code></pre>
<p>Merupakan arrow yang memetakan category A menjadi B.</p>
<h2 id="functor"><a class="header" href="#functor">Functor</a></h2>
<p>Functor adalah proses mapping antara suatu category ke dalam category lainnya.
Functor memiliki beberapa karakteristik:</p>
<ul>
<li>Preserve identity arrows(functions passed into the functors).</li>
<li>Preserve the composition of the arrows processing the elements inside the catgory into another category(codomain).</li>
</ul>
<pre><code>F(X) -&gt; Y

F(X) -&gt; F(Y)
</code></pre>
<p>Jadi functor adalah fungsi atau tipe data yang memiliki fungsi-fungsi yang dapat meng-komposisikan berbagai arrows(lambda) untuk memproses setiap elements di dalam category tersebut.(<em>mindblown!</em>)</p>
<h2 id="endofunctor"><a class="header" href="#endofunctor">Endofunctor</a></h2>
<p>Sama dengan functor, hanya saja endofunctor memetakan ke category yang sama, sekalipun object/set di dalamnya berubah.</p>
<p><em>Akhirnya kita sampai juga pada apa itu monad</em>.</p>
<h2 id="monad"><a class="header" href="#monad">Monad</a></h2>
<p>Jika kita kembali pada quote di atas, <em>&quot;Monad is just a monoid in the category of endofunctors&quot;</em>, </p>
<p>maka kita dapat menyimpulkan monad sebagai <em><strong>category dari sebuah monoid yang memiliki beberapa endofunctors yang mengkomposisi arrows</strong></em>.</p>
<p>Atau jika ditulis dalam bentuk lain: </p>
<blockquote>
<p><em>Monad = Category&lt;Monoid&gt;.Endofunctors(arrows)</em></p>
</blockquote>
<h1 id="konsep-lanjutan"><a class="header" href="#konsep-lanjutan">Konsep Lanjutan</a></h1>
<p>Berikut kita akan membahas sesuatu yang lebih konkrit dari teori di atas yang mana dapat diterapkan dibanyak bahasa pemograman yang memiliki fitur functional.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>Immutability merupakan konsep dari dunia matematika dimana objek di dalam matematika bersifat immutable. Tidak ada state di dalam matematika, perubahan data, dari suatu variable, atau yang biasa disebut dengan stateful.</p>
<p>Konsep dari immutability itu sederhana, suatu data yang telah dibentuk tidak dapat diubah selama pemosresan, jikapun diubah, biasanya secara monadic, dimana original data di-preserved, dan menghasilkan data baru yang berasal dari data original.</p>
<h2 id="pure-function"><a class="header" href="#pure-function">Pure Function</a></h2>
<p>Pure Function merupakan fungsi yang tidak merubah data apapun yang di-capture dari luar. Pure function ini dalam bahasa pemograman merupakan closure yang tidak meng-capture mutable data sekitar. Yang diharapkan dari pure function ini adalah tidak ada side-effect yang dihasilkan oleh fungsi tersebut. Side effect ini bisa berupa data yang diubah2 dan stateful sepanjang program berjalan.</p>
<h2 id="first-order-function"><a class="header" href="#first-order-function">First-order Function</a></h2>
<p>Merupakan fungsi yang bisa dijadikan sebagai value/argument.
First-order function belum tentu pure function, dan sebaliknya. Sedangkan di dalam functional programming, dibutuhkan dua hal ini.
First-order function merupakan arrows pada konsep di atas, yang bisa menjadi fungsi yang melakukan <code>morphism</code> pada functors.</p>
<h2 id="higher-order-function"><a class="header" href="#higher-order-function">Higher-order Function</a></h2>
<p>Merupakan fungsi yang meng-kombinasikan satu atau beberapa first-order function dan menghasilkan value atau fungsi lainnya.
Bisa juga disebut sebagai kombinator. Higher-order function bisa dikategorikan ke dalam functor karena memiliki kombinasi fungsi di dalamnya.</p>
<h2 id="referential-transparency"><a class="header" href="#referential-transparency">Referential Transparency</a></h2>
<p>Merupakan konsep dimana setiap value di dalam kode pemograman bisa di-replace dengan expression yang menghasilkan value yang sama, tanpa mengubah behaviour program. 
Hal ini berguna untuk maintainability sebuah program, dan juga sebagai cara untuk mengembangkan program lebih lanjut dengan mudah tanpa refactor terlalu besar.
Salah satu requirement dalam referential transparency ini adalah immutability, dimana value dan expression yang digunakan harus bebas dari side-effects, karena jika ada side-effects, maka akan mengganggu maintainability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programming-pada-rust"><a class="header" href="#functional-programming-pada-rust">Functional Programming pada Rust</a></h1>
<p>Rust memiliki berbagai macam paradigma pemograman yang dapat dicampurkan ke dalam kode, yaitu: Procedural/Imperative dan Functional/Declarative. Procedural merupakan pendekatan bahasa pemograman yang paling awal muncul memiliki pengaruh langsung dari konsep Turing machine itu sendiri. Selain itu juga bahasa assembly juga secara keseluruhan bersifat imperative dan procedural. Pendekatan ini menekankan penulisan kode program secara berurutan step-by-step dari atas ke bawah dengan perubahan state di antaranya.</p>
<p>Pendekatan kedua yang muncul yaitu Functional yang memiliki pengaruh dari Lambda Calculus oleh Alonzo Church. Pendekatan kedua ini menggunakan fungsi sebagai dasar komputasi yang bisa dikombinasikan dan digabungkan menghasilkan abstraksi yang lebih tinggi untuk melakukan komputasi dengan menekankan <em>immutability</em> dari data.</p>
<p>Rust dengan type system nya bisa mengaplikasikan pendekatan functional dengan memanfaatkan 3 komponen utama:</p>
<ul>
<li><a href="intermediate/../basic/15_generic.html">Generic types</a></li>
<li><a href="intermediate/../basic/14_trait.html">Traits</a></li>
<li><a href="intermediate/../basic/5_variables_function_closure.html#closures">Closures</a></li>
</ul>
<p>Rust mendapatkan polymorphic type parameters secara static dan strong oleh generics dan traits, serta dapat mengembangkan komputasi menggunakan closures.
Kita telah membahas ketiga di atas pada pembahasan sebelumnya. </p>
<p>Rust tidak murni functional, akan tetapi banyak dari praktiknya menggunakan paradigma functional.</p>
<p>Kita akan membahas kaitan konsep-konsep pada functional programming di dalam Rust.</p>
<h2 id="types--immutability"><a class="header" href="#types--immutability">Types &amp; Immutability</a></h2>
<p>Rust memiliki semua data yang bersifat immutable by default. Ini mencegah <em>side-effects</em> yang mungkin terjadi terhadap data yang di-<em>pass</em> ke berbagai fungsi, atau bahkan thread lainnya. Hampir semua tipe data di dalam Rust bersifat monoid dan bisa membentuk tipe baru(category). 
Berbeda dengan beberapa bahasa lain yang beberapa variable memiliki default values, dan beberapa memiliki undefined value, atau bahkan null. Di dalam Rust hampir semua merupakan object matematika berupa set atau kategori. </p>
<p>Semua tipe data merupakan set itu sendiri, karena tidak ada empty values padanya, dan default values yang harus ditentukan manual yang mana value nya juga bagian dari set itu. Dengan memanfaatkan generics dan trait, kita bisa membentuk type constructor/container untuk membuat tipe baru, atau disebut juga sebagai category. Semua ini bersifat immutable by default.</p>
<h2 id="pure-function-1"><a class="header" href="#pure-function-1">Pure Function</a></h2>
<p>Pure Function tidak memiliki side-effects yang reflected ke luar fungsi. Jikalau Pure Function melakukan perubahan, perubahan itu hanya local state dari fungsi tersebut tanpa reflected ke luar. Hal ini berbeda dengan beberapa idiom yang biasa terjadi di C dan Go dimana kita mem-<em>passing</em> pointer ke dalam fungsi yang akan merubah state dari pointer tersebut.
Karena semua immutable by default, maka variable yang di-pass ke dalam juga immutable by default. Kondisi variable yang di-pass ke dalam fungsi mengikuti deklarasi variable di parameternya.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut a = 20;
    accept_pure(&amp;a); // pass immutable reference
    accept_pure(&amp;mut a); // pass mutable reference
    accept_not_pure(&amp;mut a); // pass mutable reference
    // accept_not_pure(&amp;a); // can't pass immutable arguments into mutable parameter
}

// pure function
fn accept_pure(a: &amp;i32) { // whatever the condition of arguments passed, those will follow function's parameters declaration.
    println!(&quot;pure function: {a}&quot;);
}

// non-pure function
fn accept_not_pure(a: &amp;mut i32) {
    *a += 1;
    println!(&quot;non-pure function: {a}&quot;);
}</code></pre></pre>
<p>Pada contoh di atas, terdapat rules yang bisa ditulis:</p>
<ul>
<li>Immutable parameter bisa menerima immutable dan mutable arguments, karena fungsi tidak memiliki side-effects karena immutability dari parameternya.</li>
<li>Mutable parameter hanya bisa menerima mutable argument, karena fungsi ini pasti memiliki side-effects karena mutability dari parameternya.</li>
</ul>
<p>Dua rule di atas digunakan untuk memberikan abstraksi yang jelas dari API-API yang kita buat.</p>
<h2 id="first-order-function-1"><a class="header" href="#first-order-function-1">First-order function</a></h2>
<p>Rust menerapkan first-order function melalui closure, yang mana seperti yang telah dibahas sebelumnya, closure-closure pada rust menerapkan salah satu dari 3 trait closures yang telah dibahas di <a href="intermediate/basic/../../basic/5_variables_function_closure.html#closures">sini</a>, yaitu <code>FnOnce</code>, <code>FnMut</code>, dan <code>Fn</code>.
First-order function yang bersifat pure adalah <code>FnOnce</code> dan <code>Fn</code> karena tidak memiliki side-effects terhadap data dari luar.
First-order functions di dalam rust sering digunakan sebagai fungsi transformasi yang di-inject ke dalam fungsi kombinator(higher-order function).</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let double = |x| x * x;
    do_double(double);
}

fn do_double&lt;F: FnOnce(i32) -&gt; i32&gt;(f: F) {
    println!(&quot;{}&quot;, f(5)); // 25 
}</code></pre></pre>
<h2 id="higher-order-function-1"><a class="header" href="#higher-order-function-1">Higher-order function</a></h2>
<p>Merupakan fungsi kombinator yang mengkombinasikan satu atau beberapa first-order functions menjadi value atau fungsi lainnya. Bisa juga disebut sebagai kombinator.
Di dalam Rust, kombinator banyak digunakan untuk proses komputasi terhadap data yang ada di dalam container/type constructor, seperti Vec&lt;T&gt;, Option&lt;T&gt;, Result&lt;T,E&gt;, dan lainnya. Semua tipe container itu memiliki method-method yang merupakan functors, yang mana functor-functor ini bisa menerima fungsi lainnya, yang akan diproses secara <em>lazy</em>, dan akan menghasilkan category lainnya yang juga memiliki functor-functor. Contoh Higher-order function yang sering kita jumpai adalah iterator.
Iterator merupakan trait yang berisi method-method untuk melakukan operasi terhadap data berbentuk collection.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4];
let v_doubles = v.iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
println!(&quot;{:?}&quot;, v_doubles);
<span class="boring">}</span></code></pre></pre>
<p>Pada contoh di atas, variable <code>v</code> merupakan collection berbentuk Vector, yang berisi integer 32. Method <code>iter()</code> menghasilkan category <code>Map</code> yang memiliki functor <code>map</code> yang mengkombinasikan closure/arrow <code>|x| x * x</code>. Selain itu juga memiliki method <code>collect()</code> yang mengembalikan data ke category yang diinginkan yaitu <code>Vec&lt;_&gt;</code>.</p>
<p>Contoh lain adalah:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opt: Option&lt;T&gt; = Some(5);
let ret = opt.map(|x| x*x).unwrap_or(Default::default());
println!(&quot;{}&quot;, ret);
<span class="boring">}</span></code></pre></pre>
<p>Option merupakan category yang memiliki value <code>None</code> atau <code>Some(T)</code>. Option memiliki functor map yang menerima fungsi untuk data yang ada di dalam <code>Some(T)</code>, jika tidak ada maka akan mengembalikan <code>None</code>.</p>
<h2 id="referential-transparency-1"><a class="header" href="#referential-transparency-1">Referential Transparency</a></h2>
<p>Immutability by default membuat penerapan referential transparency menjadi lebih mudah. Selain immutability, sistem ownership pada Rust juga membuat referential transparency menjadi trivial. Functional traits seperti <code>FnOnce</code> dan <code>Fn</code> yang bersifat immutable, tidak memberikan side-effects keluar dari program di luar dari ekspresi yang kita gunakan. Ekspresi akan menghasilkan output yang selalu sama karena tidak adanya side-effects yang menyebabkan perubahan hasil evaluasi ekspresi.</p>
<h2 id="currying"><a class="header" href="#currying">Currying</a></h2>
<p><em><strong>Currying</strong></em> merupakan salah satu fitur yang digunakan dalam functional programming. Fitur ini adalah bagaimana membangun chain of functions dengan cara menyediakan fungsi yang mengembalikan fungsi lainnya, dan seterusnya. </p>
<p>Di dalam Rust, currying dapat di-achieve dengan menggunakan functional traits dan <em>boxing</em>(kita bahas di pembahasan selanjutnya tentang smart pointers).
Secara technical, currying mengkomposisi beberapa fungsi yang digunakan sebagai arguments dan returns. Fungsi ini merupakan pointer ketika tidak bisa di-<em>inline</em> oleh compiler. Inline merupakan proses menanamkan semua intruksi fungsi ke dalam fungsi yang memanggil fungsi tersebut. Pada saat currying tentunya inline cukup sulit dilakukan karena pada saat kompilasi, hanya fungsi terluar yang mungkin bisa di-<em>inline</em>, akan tetapi fungsi berikutnya tidak bisa di-<em>inline</em>. Untuk mengatasi ini, kebanyakan bahasa pemograman menerapkan fungsi tersebut sebagai pointer.</p>
<p>Jika kita ingin menerapkan inlined currying, menggunakan notasi closures langsung di assign ke sebuah variable, maka semua bisa di-<em>inlined</em> oleh compiler pada saat compile time.
Cotnoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func = |x| {
    move |y| {
        move |z| {
            move |a| {
                println!(&quot;{a}&quot;);
                (x * y * z) + a
            }
        }
    }
};
println!(&quot;{:?}&quot;, func(3)(9)(2)(2));

let fullname = |firstname| {
    move |middlename| move |lastname| format!(&quot;{} {} {}&quot;, firstname, middlename, lastname)
};

println!(&quot;{}&quot;, fullname(&quot;Muhammad&quot;)(&quot;Fathir&quot;)(&quot;Irhas&quot;));
<span class="boring">}</span></code></pre></pre>
<p>Notasi closures di atas menggunakan <code>move</code> semantics, hal ini untuk memindahkan ownership value dari fungsi sebelumnya ke fungsi berikutnya, hal ini karena closures by default meng-<em>capture</em> values sekitar by borrow/reference, sehingga akan ada mismatch antara lifetime closures yang disusun. Oleh sebab itu, kita butuh memindahkan ownership tersebut supaya closure berikutnya bisa menggunakan values dari closures sebelumnya sekalipun closure tersebut nge-<em>outlive</em> lifetime closures sebelumnya.</p>
<p>Jika kita ingin menggunakan currying pada named function, jika hanya memiliki 1 return fungsi, maka tidak ada masalah. Akan tetapi masalah muncul ketika kita ingin me-<em>nested</em> kan lebih dari 1 return fungsi, dalam artian 1 return fungsi tersebut juga akan mengembalikan fungsi lainnya, dan seterusnya. Masalah ini terjadi ketika kita menggunakan notasi <code>impl Trait</code> terhadap argument dan/atau return values. </p>
<p>Rust memiliki sebuah rule untuk <code>impl Trait</code> ini yaitu <strong><em>impl Trait</em> hanya bisa digunakan sebagai argument dan return langsung dari fungsi bersangkutan.</strong>
Dalam artian, jika kita juga menggunakan <code>impl Trait</code> untuk input dan output dari <code>impl Trait</code> lainnya, maka ini melanggar aturan dan failed to compile.
Karena closures di dalam rust itu adalah jelmaan dari traits <code>FnOnce</code>, <code>FnMut</code>, dan <code>Fn</code>, maka aturan <code>impl Trait</code> juga berlaku untuk closures menggunakan notasi <code>impl Trait</code>. </p>
<p>Kembali ke permasalahan di atas, yaitu ketika kita ingin mengembalikan nested currying lebih dari 1, jika menggunakan <code>impl Trait</code> saja tidak bisa, sehingga kita harus mem-<em>boxing</em> functional traits lainnya ke dalam smart pointer box dan menggunakan keyword <code>dyn</code>(kita bahas di pembahasan selanjutnya).
Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;{}&quot;, currying1(1)(2));
    println!(&quot;{}&quot;, currying3(1)(2)(3));
}

fn currying1(first: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |second| first * second
}

// failed because it against the rule of `impl Trait` placement.
// fn currying2(first: i32) -&gt; impl Fn(i32) -&gt; impl Fn(i32) -&gt; i32 {
//     move |second| move |third| first * second * third
// }

fn currying3(first: i32) -&gt; impl Fn(i32) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    move |second| Box::new(move |third| first * second * third)
}</code></pre></pre>
<p>Kenapa kita tidak bisa menggunakan notasi <code>impl</code> pada return fungsi ke tiga?, ini ada hubungannya dengan <code>static dispatch</code> pada Rust dimana <code>impl Trait</code> merupakan tipe untuk melakukan static dispatch(kita bahas pada pembahasan selanjutnya). Karena fungsi ke tiga tidak bisa di-<em>infer</em> secara static, maka butuh di-dispatch secara dynamic menggunakan kombinasi Box dan dyn(kita bahas selanjutnya).</p>
<h2 id="functional-constructs-pada-rust"><a class="header" href="#functional-constructs-pada-rust">Functional Constructs pada Rust</a></h2>
<p>Kita akan menerapkan beberapa konsep functional di atas ke dalam Rust menggunakan 3 komponen utama: Generics, Traits, dan Closures.</p>
<ul>
<li>Generics: Merupakan fitur umum yang ada pada functional programming. Fitur ini diperkenalkan oleh bahasa ML. 
Jika kita memperhatikan notasi matematika, khususnya dalam bidang set dan kategori, kita melihat bahwa set(types) selalu dinotasikan menggunakan 1 huruf kapital,
seperti A, B, C, T, U, X dan lainnya<a href="https://en.wikipedia.org/wiki/Set_(mathematics)#How_sets_are_defined_and_set_notation">[1]</a>. 
Generics merupakan representasi dari notasi <em>set</em> di dalam matematika untuk merepresentasikan berbagai set(type) yang bisa digunakan.</li>
<li>Traits: Digunakan untuk memberikan common things shared between sets, atau dalam hal ini type data yang telah di-generic-kan di atas.
Ketika kita menggunakan generic tanpa trait, maka literally semua sets bisa saja dimasukkan ke dalam generic tersebut, untuk membatasi ini, maka bisa digunakan traits.</li>
<li>Closures: Digunakan untuk merepresentasikan arrows pada matematika, yaitu memberikan kemampuan untuk meng-<em>inline</em> deklarasi fungsi pada kode. 
Ini nantinya berguna untuk membangun first-order function, dan dikombinasikan ke dalam higher-order functions.</li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let ret = functor(123, |x| x * x);
    println!(&quot;{ret}&quot;);
}

fn functor&lt;T, F&gt;(t: T, f: F) -&gt; T
where
    T: Sized + Debug,
    F: Fn(T) -&gt; T,
{
    println!(&quot;{t:?}&quot;);
    f(t)
}</code></pre></pre>
<p>Pada contoh Di atas, kita secara sederhana menerapkan 3 komponen di atas ke dalam functional approach.
Kita menggunakan generic sebagai type placeholder untuk fungsi <code>functor</code>, yang mana fungsi ini akan menerima 2 parameter <code>t: T</code> dan <code>f: F</code> yang mana masing-masing harus memenuhi trait <code>Sized dan Debug</code> dan functional trait <code>Fn(T) -&gt; T</code>. Kita menggunakan functional trait Fn untuk menerima pure function sebagai first-order function(arrows) yang akan diproses lazily oleh <code>functor</code>.</p>
<h2 id="monad-1"><a class="header" href="#monad-1">Monad</a></h2>
<p>Kita akan menelusuri kembali semua konsep berkaitan dengan monad yaitu:</p>
<ul>
<li>Set: Semua tipe data pada Rust merupakan <em>set</em> di dalam abstract algebra. Contoh: primitive types: <code>i32</code>, <code>f32</code>, <code>bool</code>, <code>char</code>, etc</li>
<li>Monoid: Semua tipe data di Rust merupakan Monoid, karena semua bisa bersifat <em>associative</em> terhadap suatu binary operation, dan memiliki identity element.
Contoh: (i32, +, 0), i32 adalah monoid untuk operasi penjumlahan dengan identity element 0.</li>
<li>Category: Merupakan tipe container atau <em>type constructor</em> yang terdiri dari Set/Monoid itu sendiri. Contoh: <code>Vec&lt;T&gt;</code>, <code>HashMap&lt;K,V&gt;</code>, etc.</li>
<li>Arrows: Merupakan first-order functions jelmaan dari functional traits: <code>FnOnce</code>, <code>FnMut</code>, dan <code>Fn</code>.</li>
<li>Functor: Merupakan mapping dari suatu category ke dalam bentuk lain, khususnya ke dalam category yang sama jika endofunctor. 
Functor sendiri bisa associated functions dari suatu category, bisa juga Category tersendiri dengan beberapa methods yang bertugas melakukan <em>mapping</em>/transformasi category.</li>
</ul>
<blockquote>
<p>Monad di dalam Rust merupakan tipe data berbentuk <strong>Category</strong> yang berisi <strong>Monoid</strong>, yang memiliki <strong>endofunctor</strong> yang melakukan mapping terhadap monoid tersebut menggunakan <strong>arrows</strong> yang dikombinasikan ke dalam endofunctor.</p>
</blockquote>
<p>Beberapa contoh monad di dalam Rust yang sering kita gunakan:</p>
<ul>
<li><code>Option&lt;T&gt;</code>: Option, berisi 1 monoid T, memiliki beberapa endofunctor di antaranya <code>.and_then(F)</code> dan <code>map(F)</code>. Masing-masing bisa memetakan <code>Option&lt;T&gt;</code> ke category yang sama dengan tipe yang sama yaitu <code>Option&lt;U&gt;</code>. Bisa juga memetakan ke tipe yang berbeda tetapi masih di dalam category yang sama, misal <code>Vec&lt;T&gt;</code>.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opsi: Option&lt;&amp;str&gt; = Some(&quot;test&quot;);

// map the monoid inside option if it's exist, by injecting it into arrows F: |x| -&gt; x
let ret = opsi.map(|x| x); //.or(None);
println!(&quot;{:?}&quot;, ret); // prints &quot;Some(&quot;test&quot;)&quot;

// do something with Option if it's exist, and return Option&lt;U&gt;
let ret = opsi.and_then(|x| Some(x)); //.or(None);
println!(&quot;{:?}&quot;, ret); // prints &quot;Some(&quot;test&quot;)&quot;

// Option&lt;T&gt; dan Vec&lt;T&gt; bisa dikategorikan ke dalam Category yang sama, karena Option adalah vector dengan 1 elemen, atau empty vector.
let ret = opsi.into_iter().map(|x| x).collect::&lt;Vec&lt;_&gt;&gt;();
println!(&quot;{:?}&quot;, ret); // prints [&quot;test&quot;], will print [] if opsi is None
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>Vec&lt;T&gt;</code>: Vec, berisi 1 monoid T, memiliki beberapa endofunctor di antaranya <code>iter()</code>/<code>into_iter()</code> untuk menghasilkan functor mapping object dari vector.
Contoh:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1, 2, 3];
// iter() get functor `Map` that containes the endofunctors for mapping the items inside vector, with `map` along with arrows, and collect it back into same category.
let ret = vec.iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
println!(&quot;{:?}&quot;, ret);

// Collect into `LinkedList&lt;_&gt;` because Vec and LinkedList have same category(shape: list of things)
let ret = vec.iter().map(|x| x * x).collect::&lt;LinkedList&lt;_&gt;&gt;();
println!(&quot;{:?}&quot;, ret);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>HashMap&lt;K,V&gt;</code>: Berisi monoid berupa compound data of K and V, memiliki endofunctors di antaranya <code>iter()</code> and <code>into_iter()</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = [(1, &quot;1&quot;), (2, &quot;2&quot;), (3, &quot;3&quot;)];
// vector of array of tuple-2 have same shape(category) with HashMap itself.
// need to use `into_iter()` to get functor owning the data from vector, since vector contain reference data(&amp;str), and HashMap is owned type and need ownership of the data it collect from.
let ret = vec.into_iter().map(|x| x).collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();
println!(&quot;{:#?}&quot;, ret);

// failed because HashMap need to take ownership of iterator elements.
// hence HashMap cannot be built from &amp;(K,V) because it's not implemented for FromIterator(&amp;(K,V))
// let ret = vec.iter().map(|x| x).collect::&lt;HashMap&lt;i32, &amp;str&gt;&gt;();
// println!(&quot;{:#?}&quot;, ret);

let tuple = [(1, 1), (2, 2), (3, 3)];
// we can use `iter()` insetead of `into_iter` because tupe values are all copyable, so no reference borrowed and move semantic occurs since i32 is copyable.
let ret = tuple.iter().map(|x| *x).collect::&lt;HashMap&lt;i32, i32&gt;&gt;();
println!(&quot;{:#?}&quot;, ret);


let tuple = [
    (&quot;1&quot;.to_string(), &quot;1&quot;.to_string()),
    (&quot;2&quot;.to_string(), &quot;2&quot;.to_string()),
    (&quot;3&quot;.to_string(), &quot;3&quot;.to_string()),
];
// since we used `iter()`, and data are not copyable(String), hence move semantic occurs, and we need to take the data by cloning(copy for mov data)
let ret = tuple
    .iter()
    .map(|x| x.clone())
    .collect::&lt;HashMap&lt;String, String&gt;&gt;();
println!(&quot;tupe string: {:#?}&quot;, ret);

// unlike above, since we already use `into_iter` which take ownership items we passed, to need to clone the data since ownership already passed by `into_iter`
let tuple = [
    (&quot;1&quot;.to_string(), &quot;1&quot;.to_string()),
    (&quot;2&quot;.to_string(), &quot;2&quot;.to_string()),
    (&quot;3&quot;.to_string(), &quot;3&quot;.to_string()),
];
let ret = tuple
    .into_iter()
    .map(|x| x)
    .collect::&lt;HashMap&lt;String, String&gt;&gt;();
println!(&quot;tupe string: {:#?}&quot;, ret);

// we can decode the tuple inside and return same structure
let tuple = [(1, 1), (2, 2), (3, 3)];
let ret = tuple
    .iter()
    .map(|x| (x.0, x.1))
    .collect::&lt;HashMap&lt;i32, i32&gt;&gt;();
println!(&quot;{:#?}&quot;, ret);

// we can also collect HashMap as Vector since it's just array of tuple-2 of keys and values
let map = HashMap::from([(1, 1), (2, 2), (3, 3)]);
let ret = map.into_iter().map(|x| x).collect::&lt;Vec&lt;_&gt;&gt;();
println!(&quot;{:#?}&quot;, ret);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>Merupakan pattern untuk melakukan perulangan pada compound/collection types tanpa control flow for/loop/while. 
Pattern ini merupakan salah satu pendekatan functional dalam melakukan looping dimana melakukan processing data pada compound/collection dengan mengkombinasikan berbagai fungsi. Kita bisa menggunakan konsep monad sebelumnya pada kali ini, yaitu monad yang merupakan kategori dengan data di dalam yang di-iterasi menggunakan functor dan arrows untuk fungsi transformasi.</p>
<p>Dalam wujudnya, pattern ini menyediakan 1 trait bernama <code>Iterator</code> yang merupakan bagian dari standard library yang berisi 1 type yang menjadi item iterasi, dan 1 method yang wajib diimplementasi dan sisanya merupakan methods dengan default implementations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {

    // item to be iterated over
    type Item;

    // method to get next data in interations
    // method next use mutable reference because it needs consume the object's data and updating its data pointed to and returning previous state.
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // ... rest of methods related to iterations implemented defaultly.
<span class="boring">}</span></code></pre></pre>
<p>Iterator memiliki beberapa objek yang mengimplementasikan iterasi ini. Objek tersebut yang menampung data iterasi dan mengolah data menggunakan method-method pada Iterator. Diantara objek-objek tersebut adalah: <code>Map&lt;I, F&gt;</code>, <code>Iter&lt;'a, A&gt;</code>, dan lainnya yang bisa dilihat di <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">doc</a>. Objek-objek tersebut tersebar di standard lib yang merupakan objek perantara iterasi dari objek yang sebenarnya memiliki data, seperti <code>Vec&lt;T&gt;</code>, <code>HashMap&lt;K, V&gt;</code>, array, slices, dan lainnya. </p>
<h2 id="iterator-constructor"><a class="header" href="#iterator-constructor">Iterator Constructor</a></h2>
<p>Terdapat 3 method yang digunakan untuk menghasilkan objek iterator di atas, yang dipanggil oleh pemilik data, yaitu:</p>
<h3 id="iter"><a class="header" href="#iter"><code>.iter()</code></a></h3>
<p>Melakukan iterasi terhadap immutable reference(<code>&amp;self</code>). Method ini tidak menghasilkan iterator objek yang meng-<em>consume</em> object yang di-iterasi, karena hanya di-<em>borrow</em> sebagai reference. Method ini menghasilkan objek Iterator <code>Iter</code> yang merupakan konvensi objek yang akan mengiterasi items by <em>immutable</em> <em>borrow</em>/<em>reference</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1,2,3,4];
let mut iterator = vec.iter();
println!(&quot;{:?}&quot;, iterator.next()); // Some(1)
println!(&quot;{:?}&quot;, iterator.next()); // Some(2)
println!(&quot;{:?}&quot;, iterator.next()); // Some(3)
println!(&quot;{:?}&quot;, iterator.next()); // Some(4)
println!(&quot;{:?}&quot;, iterator.next()); // None
<span class="boring">}</span></code></pre></pre>
<p>Kenapa <code>iterator</code> mutable?, karena method <code>next()</code> akan melakukan iterasi dengan cara mengupdate underlying object yang dijadikan acuan iterasi. 
Jarang kita menggunakan method <code>next</code> secara langsung untuk melakukan proses terhadap iterasi data, biasanya kita menggunakan method yang disediakan oleh objek iterasi <code>Iter</code> itu sendiri yang mana mengimplementasi trait <code>Iterator</code> itu sendiri, seperti <code>map</code>, <code>filter</code>, <code>reduce</code>, dan lainnya. Dengan melakukan chaining methods seperti ini, maka kita tidak butuh side effects di luar iterasi karena semua <em>enclosed</em> di dalam iterator chains.</p>
<h3 id="iter_mut"><a class="header" href="#iter_mut"><code>.iter_mut()</code></a></h3>
<p>Melakukan iterasi terhadap mutable reference(<code>&amp;mut self</code>). Method ini memiliki side-effects terhadap data yang di-iterasi jika memanggil method seperti <code>next()</code> dan lainnya. Method ini menghasilkan objek iterator <code>IterMut</code> yang merupakan konvensi objek yang akan mengiterasi item mutable <em>borrow</em>/<em>reference</em>. Method ini juga di chain dengan method-method lainnya yang mengambil data juga by <em>mutable reference</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = vec![1,2,3,4];
let mut iterator = vec.iter_mut();
println!(&quot;{:?}&quot;, iterator.next()); // Some(1)
println!(&quot;{:?}&quot;, iterator.next()); // Some(2)
println!(&quot;{:?}&quot;, iterator.next()); // Some(3)
println!(&quot;{:?}&quot;, iterator.next()); // Some(4)
println!(&quot;{:?}&quot;, iterator.next()); // None
<span class="boring">}</span></code></pre></pre>
<p>Berbeda dengan <code>iter</code> yang melakukan borrow, <code>iter_mut</code> melakukan iterasi by mutable reference, sehingga objek yang menjadi acuan iterasi(<code>vec</code>) harus mutable.</p>
<h3 id="into_iter"><a class="header" href="#into_iter"><code>.into_iter()</code></a></h3>
<p>Memindahkan ownership dari data yang di-iterasi ke dalam iterator(<code>self</code>). Method ini merupakan default ketika melakukan iterasi dengan for loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1,2,3,4];
let mut iterator = vec.into_iter();
println!(&quot;{:?}&quot;, iterator.next()); // Some(1)
println!(&quot;{:?}&quot;, iterator.next()); // Some(2)
println!(&quot;{:?}&quot;, iterator.next()); // Some(3)
println!(&quot;{:?}&quot;, iterator.next()); // Some(4)
println!(&quot;{:?}&quot;, iterator.next()); // None
// println!(&quot;{:?}&quot;, vec); // failed, because vec already moved by `.into_iter()` method invocation.
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Tahukah kamu! <code>for</code> loop merupakan syntatic sugar dari <code>IntoIterator</code>.
Kode ini:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1, 2, 3, 4];
let result = for i in vec {
   println!(&quot;{:?}&quot;, i)
};
<span class="boring">}</span></code></pre></pre>
<p>Sama dengan:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vec = vec![1, 2, 3, 4];
let iter_expr = vec![1, 2, 3, 4].into_iter();
let result = match IntoIterator::into_iter(iter_expr) {
    mut iter =&gt; 'label: loop {
        let mut next;
        match Iterator::next(&amp;mut iter) {
            Option::Some(val) =&gt; next = val,
            Option::None =&gt; break,
        };
        let PATTERN = next;
        let () = { println!(&quot;{:?}&quot;, PATTERN) };
    },
};
<span class="boring">}</span></code></pre></pre>
<p>Mungkin kita bertanya, kenapa?, well, karena <code>for</code> memang membaca data compounds/collections yang implement trait <code>IntoIterator</code> secara default.
Hal unik lainnya, extra lines yang dihasilkan tidak menambah overhead pada looping karena prinsip <strong>Zero-cost Abstraction</strong> dari Rust.</p>
</blockquote>
<h2 id="functionals"><a class="header" href="#functionals">Functionals</a></h2>
<p>Secara umum, terdapat 3 fungsionalitas utama yang biasa digunakan dalam iterator:</p>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p><em>Map</em> adalah fungsionalitas dari iterator untuk melakukan <strong>apply</strong> function terhadap data yang di-iterasi. Fungsi ini digunakan untuk melakukan operasi terhadap data seperti transformasi. Map menerima 1 closure yang bertindak sebagai apply terhadap data yaitu <code>FnMut</code>.
Map pada iterator mengembalikan objek Map yang bisa juga disebut sebagai functor yang mengkombinasikan arrows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    ...
    fn map&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt; 
        where
            Self: Sized,
            F: FnMut(Self::Item) -&gt; B, 
    { ... }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let slice: &amp;[i32] = &amp;[1, 2, 3, 4];
    let from_slice = slice.iter().map(|x| x + 1).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;slice.iter(): before: {:?}&quot;, slice);
    println!(&quot;slice.iter(): after:  {:?}&quot;, from_slice);

    let mut_slice = &amp;mut [1, 2, 3, 4];
    let from_slice = mut_slice
        .iter_mut()
        .map(|x| {
            *x += 5;
            *x + 1
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;slice.iter_mut(): before: {:?}&quot;, slice);
    println!(&quot;slice.iter_mut(): after:  {:?}&quot;, from_slice);

    let from_slice = slice.into_iter().map(|x| x * 4).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;slice.into_iter(): {:?}&quot;, slice);
    println!(&quot;slice.into_iter(): {:?}&quot;, from_slice);

    println!(&quot;-------------&quot;);

    // iterate over array
    let array: [i32; 4] = [1, 2, 3, 4];
    let from_array = array.iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;array.iter(): {:?}&quot;, array);
    println!(&quot;array.iter(): {:?}&quot;, from_array);

    let mut mut_array = [1, 2, 3, 4];
    let from_array = mut_array.iter_mut().map(|x| *x * *x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;mut_array.iter_mut(): {:?}&quot;, mut_array);
    println!(&quot;mut_array.iter_mut(): {:?}&quot;, from_array);

    let from_array = array.into_iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;mut_array.into_iter(): {:?}&quot;, array);
    println!(&quot;mut_array.into_iter(): {:?}&quot;, from_array);

    println!(&quot;-------------&quot;);

    // iterate over array_ref
    let array: &amp;[i32; 4] = &amp;[1, 2, 3, 4];
    let from_array = array.iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;array.iter(): {:?}&quot;, array);
    println!(&quot;array.iter(): {:?}&quot;, from_array);

    let mut mut_array = [1, 2, 3, 4];
    let from_array = mut_array.iter_mut().map(|x| *x * *x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;mut_array.iter_mut(): {:?}&quot;, mut_array);
    println!(&quot;mut_array.iter_mut(): {:?}&quot;, from_array);

    let from_array = array.into_iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;mut_array.into_iter(): {:?}&quot;, array);
    println!(&quot;mut_array.into_iter(): {:?}&quot;, from_array);

    println!(&quot;-------------&quot;);

    // iterate over vector
    let vector = vec![1, 2, 3, 4];
    let from_vector = vector.iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;vector.iter(): {:?}&quot;, vector);
    println!(&quot;vector.iter(): {:?}&quot;, from_vector);

    let mut mut_vector = vec![1, 2, 3, 4];
    let from_vector = mut_vector.iter_mut().map(|x| *x * *x).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;mut_vector.iter_mut(): {:?}&quot;, vector);
    println!(&quot;mut_vector.iter_mut(): {:?}&quot;, from_vector);

    let from_vector = vector.into_iter().map(|x| x * x).collect::&lt;Vec&lt;_&gt;&gt;();
    // println!(&quot;vector.into_iter(): {:?}&quot;, vector); // failed because ownership already moved into `into_iter()`.
    println!(&quot;vector.into_iter(): {:?}&quot;, from_vector);

    println!(&quot;----------&quot;);

    // iterate over hashmap
    let map = HashMap::from([(1, 2), (2, 3), (3, 4), (4, 5)]);
    let from_map = map.iter().map(|(_, v)| v * v).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;map.iter(): {:?}&quot;, map);
    println!(&quot;map.iter(): {:?}&quot;, from_map);

    let mut mut_map = HashMap::from([(1, 2), (2, 3), (3, 4), (4, 5)]);
    let from_map = mut_map
        .iter_mut()
        .map(|x| {
            *x.1 += 2; // reflects to outside because it takes mutable reference to outside data.
            (*x.0, *x.1)
        })
        .collect::&lt;HashMap&lt;i32, i32&gt;&gt;();
    println!(&quot;mut_map.iter_mut(): {:?}&quot;, mut_map);
    println!(&quot;mut_map.iter_mut(): {:?}&quot;, from_map);

    let from_map = map.into_iter().map(|x| (x.0, x.1 * 4)).collect::&lt;Vec&lt;_&gt;&gt;();
    // println!(&quot;map.into_iter(): {:?}&quot;, map); // ownership moved
    println!(&quot;map.into_iter(): {:?}&quot;, from_map);

    // iterate over vector and convert it into hashset
    let vec = vec![1, 1, 2, 3, 3, 3, 5, 10];
    let set = vec.into_iter().collect::&lt;HashSet&lt;_&gt;&gt;();
    println!(&quot;{:#?}&quot;, set);

    // capturing variables from env around
    let vec = vec![1, 2, 3, 4];
    let v = 123;
    let sdf = vec.into_iter().map(|x| x * v).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;----&gt;{:?}&quot;, sdf);

    let vec = vec![&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;];
    let v = &quot;123&quot;;
    let sdf = vec
        .into_iter()
        .map(|x| format!(&quot;{}-{}&quot;, x, v))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;----&gt;{:?}&quot;, sdf);

    let vec = vec![
        &quot;1&quot;.to_string(),
        &quot;2&quot;.to_string(),
        &quot;3&quot;.to_string(),
        &quot;4&quot;.to_string(),
    ];
    let v = &quot;123&quot;.to_string();
    let sdf = vec
        .into_iter()
        .map(|mut x| {
            x.push_str(v.as_str());
            x
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;----&gt;{:?}&quot;, sdf);

    let vec = vec![
        &quot;1&quot;.to_string(),
        &quot;2&quot;.to_string(),
        &quot;3&quot;.to_string(),
        &quot;4&quot;.to_string(),
    ];
    let mut v = &quot;123&quot;.to_string();
    let sdf = vec
        .into_iter()
        .map(|x| {
            v.push_str(x.as_str());
            v.clone()
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;----&gt;{:?}&quot;, sdf);
}</code></pre></pre>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<p><em>Filter</em> adalah fungsionalitas iterator untuk menerapkan <strong>predicate</strong> terhadap data yang di-iterasi. Sehingga data yang di-ambil hanyalah data yang memenuhi predicate tersebut. Predicate adalah closure yang diterima oleh method filter yang menghasilkan <em>boolean</em>. Seperti namanya, digunakan untuk mengfilter data.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    ...
    fn filter&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt; 
    where
        Self: Sized,
        P: FnMut(&amp;Self::Item) -&gt; bool,
    { ... }
    ...
}</code></pre></pre>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    let filter = vec.into_iter().filter(|x| x % 2 == 0).collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;{:?}&quot;, filter);

    // iterate, filter, and map element
    let vec = vec![1, 2, 3, 4, 5];
    let filter = vec
        .into_iter()
        .filter(|x| x % 2 == 0)
        .map(|x| x * x)
        .collect::&lt;Vec&lt;_&gt;&gt;();

    println!(&quot;{:?}&quot;, filter);

    let vec = vec![&quot;qwe&quot;, &quot;qwer&quot;, &quot;wefwerwer&quot;, &quot;lwkmeflwkef&quot;];
    let filter = vec
        .into_iter()
        .filter(|x| x.len().lt(&amp;5))
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;{:?}&quot;, filter);
}</code></pre></pre>
<h3 id="reduce"><a class="header" href="#reduce">Reduce</a></h3>
<p><em>Reduce</em> merupakan fungsionalitas yang menerapkan fungsi <strong>accumulator</strong> yang merangkum data di dalam iterasi menjadi 1 single data yang masih di dalam 1 kategori. Berbeda dengan fungsionalitasi2 sebelumnya yang menghasilkan collection, fungsi ini menghasilkan 1 single data hasil akumulasi dari setiap iterasi. Api ini mirip dengan Fold, bedanya fold memiliki initial value sebagai akumulator, sedangkan reduce menggunakan value pertama dalam iterasi sebagai initial value dari akumulator.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    ...
    fn reduce&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;
    where
        Self: Sized,
        F: FnMut(Self::Item, Self::Item) -&gt; Self::Item,
    { ... }
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    let reduce = vec
        .into_iter()
        .reduce(|acc, x| {
            dbg!(&amp;acc);
            dbg!(&amp;x);
            acc + x
        })
        .unwrap_or(0);
    println!(&quot;{:?}&quot;, reduce);

    let vec = vec![1, 2, 3, 4, 5];
    let reduce = vec.into_iter().fold(0, |acc, x| {
        dbg!(&amp;acc);
        dbg!(&amp;x);
        acc + x
    });
    println!(&quot;{:?}&quot;, reduce);

    let map = HashMap::from([(1, 2), (2, 3), (3, 4)]);
    let reduced_map: HashMap&lt;i32, i32&gt; = map
        .into_iter()
        .reduce(|acc, n| (acc.0, acc.1 + n.1))
        .and_then(|x| Some(HashMap::from([x])))
        .unwrap_or_default();
    println!(&quot;{:#?}&quot;, reduced_map);
}</code></pre></pre>
<p>Contoh-contoh di atas hanya contoh sederhana, untuk penggunaan yang lebih kompleks yang mungkin ditemui di dunia nyata, masih banyak API-API dari iterator yang bisa dieksplore sendiri dengan berbagai fungsi-fungsi tersendiri. Selain itu, setiap fungsi-fungsi dari iterator bisa di-<em>chain</em> satu sama lain untuk proses yang lebih kompleks.</p>
<h2 id="why-iterator"><a class="header" href="#why-iterator">Why iterator?</a></h2>
<p>Kenapa gak pake <code>for</code> loop biasa aja kaya di Golang?, Hal ini ada kaitannya dengan kecenderungan Rust untuk lebih Functional ketimbang Procedural. <code>for</code> loop merupakan construct procedural, yang bersifat imperative, dilihat dari cara penggunaannya, yang memproses instruksi 1 per 1, dan melakukan increment terhadap index seperti yang umum di bahasa lain seperti <code>for (int i=0; i&lt;10; i++)</code>. Rust secara idiom lebih cenderung ke FP yaitu menerapkan pattern iterator dengan dibarengi konsep monad yang mana fungsi-fungsi dikomposisi sedemikian rupa untuk memproses semua isi data collection. Cara iterator lebih declarative dilihat dari cara ngodingnya, deklarasi behaviournya, dan bagaimana objek dan fungsi-fungsi dikomposisi, selain itu juga terdapat sifat lazy dari setiap fungsi yang dikomposisi.</p>
<p>Iterator juga cara untuk mengurangi <a href="https://en.wikipedia.org/wiki/Basis_path_testing">basis path</a> dari program kita, sehingga bisa mengurangi liabilitas ketika menulis program.</p>
<p>Melihat dari <a href="https://doc.rust-lang.org/stable/book/ch13-04-performance.html#comparing-performance-loops-vs-iterators">benchmark</a>, terlihat bagaimana <strong>Zero-cost Abstraction</strong> pada Rust membuat semua abstraksi iterator memiliki performa yang sama dengan <code>for</code> loop biasa, <em>bahkan lebih cepat!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-cost-abstraction"><a class="header" href="#zero-cost-abstraction">Zero-cost Abstraction</a></h1>
<blockquote>
<p><em>&quot;What you dont use, you dont pay for. And further: What you do use, you couldnt hand code any better.&quot;</em></p>
<p>~ Bjarne Stroustrup, <a href="https://www.stroustrup.com/ETAPS-corrected-draft.pdf">Foundations of C++</a></p>
</blockquote>
<p>Zero-cost merupakan salah satu prinsip utama dalam Rust yang memiliki pengaruh dari C++. Definisi dari ZCA adalah meminimalisir <em>runtime overhead</em> sebanyak mungkin dengan melakukan banyak komputasi pada saat <em>compile-time</em>. ZCA menekankan pada abstraksi kode program yang memiliki performansi yang sama dengan kode program yang ditulis manual secara prosedural(<em>imperatively</em>). </p>
<p>Ketika kita menulis program manually by hands, <em>step-by-step</em>, setiap iterasi, state, dan <em>wrapper</em> yang kita taruh akan kita pertimbangkan dengan sematang-matangnya tanpa mengenai performansi pada saat runtime. Hal ini tentunya sangat melelahkan karena terlalu manual, terlalu <em>menial</em> dan <em>repetitive</em>. Abstraksi dikenalkan pada pemograman supaya lebih memudahkan kita dalam merepresentasikan beberapa details mejadi satu konsep supaya lebih mudah diingat dan ditulis. Dengan abstraksi akan memudahkan dan mempercepat kita dalam menulis kode program karena semua hal-hal detail dan <em>irrelevant</em> sudah kita abstraksikan ke dalam abstraksi yang kita buat, sehingga tidak perlu dirisaukan lagi. Akan tetapi hal ini memiliki <em>trade-off</em> yaitu kita harus membayar kemudahan ini dengan <em>performance penaly</em>, sehingga kode program yang diabstraksi akan memiliki performansi lebih lambat ketimbang ditulis manual.</p>
<p>Berangkat dari sinilah muncul konsep ZCA ini, yaitu untuk mengoptimisasi dan mengefisiensi kode program tanpa mengeluarkan ekstra effort menulis dengan manual, dan tetap mendapat performansi yang sama dengan menulis manual <em>by hands</em>.</p>
<p>Rust memiliki prinsip ini dengan compiler-nya yang banyak memproses dan mengoptimisasi hal pada saat compile-time, sebisa mungkin banyak hal bisa ditangkap pada saat compile-time, sehingga semua kemungkinan bugs bisa ditangkap pada saat compile-time, dan menyisakan sangat sedikit bahkan <em>free</em> untuk runtime. <code>rustc</code> dengan <code>llvm</code> bekerja sama dalam meng-<em>deconstruct</em> dan mengoptimisasi semua abstraksi kode sehingga hasil build akhir sama dengan kode yang ditulis manual <em>by hands</em> dan memiliki performansi yang mirip.</p>
<p>Berdasarkan <a href="https://www.stroustrup.com/ETAPS-corrected-draft.pdf">paper ini</a> ada beberapa hal yang berkaitan dengan ZCA diantaranya resource management, compile-time computation, error handling, concurrency dan performance. Selain itu juga berkaitan dengan bagaimana kaitannya dengan type system dari suatu bahasa. Kita akan membahas ini kaitannya dengan Rust.</p>
<p>Berikut hal-hal yang berkaitan dengan ZCA di Rust:</p>
<h2 id="static-type-analysis"><a class="header" href="#static-type-analysis">Static Type Analysis</a></h2>
<p>Rust merupakan bahasa yang memiliki static dan strongly typed type system. Static Type pada Rust menerapkan <em>affine</em> dan <em>linear</em> types dibarengi dengan RAII serta <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">HindleyMilner type system</a> untuk full type inference. Hal ini mengurangi kewajiban untuk mendeklarasikan tipe di beberapa tempat karena akan langsung di-<em>inferred</em> oleh compiler.</p>
<p>Strong type menghasilkan type safety dengan berbagai cara, di antaranya: no null pointer, always valid reference, immutable by default, no RTTI, no reflection, bound checks, no type casting, no type assertion, dan lainnya. Setiap type memiliki state yang jelas serta memiliki scope/lifetime yang jelas juga. Dibarengi dengan RAII Rust memiliki jaminan terhadap invariants pada program dengan memanfaatkan type systemnya untuk menjaga dari setiap invariant violations.</p>
<p>Hal-hal di atas memungkinkan compiler mengetahui dan mengantisipasi beberapa <em>pitfalls</em> yang mungkin terjadi pada saat runtime.</p>
<h2 id="no-garbage-collector"><a class="header" href="#no-garbage-collector">No Garbage Collector</a></h2>
<p>Memiliki manajemen memori tanpa Garbage Collector. Garbage collector merupakan salah satu runtime-cost yang memiliki cost berupa memory management dan segala overheadnya, seperti CPU usage untuk GC bekerja, memory management dan safety memory measures, <em>compacting</em>, <em>stop-the-world</em>, dan lainnya yang berkaitan dengan memory management. Bahasa-bahasa yang memiliki GC tentunya memiliki alasan agar memory management tidak manual seperti C dan C++. Hal ini tentunya membawa cost berupa runtime overhead. </p>
<p>Rust menerapkan prinsip ZCA dengan cara menghilangkan GC, dan tanpa harus mengatur memory secara manual seperti di C/C++, yaitu dengan menerapkan konsep <strong>Ownership dan Borrow</strong>, dimana Rust men-<em>tracking</em> setiap object yang di-<em>create</em> beserta lifetime-nya. Hal ini menghasilkan dua jenis data yang ada, yaitu: 1. <em>Exclusive data</em>, dan 2. <em>Shared data</em>. </p>
<p><em>Exclusive</em> data merupakan data yang di-<em>owned</em>, biasanya data yang tidak diketahui <em>size</em> nya pada saat compile time(heap allocated), sistem ownership diterapkan pada exclusive data dengan cara melakukan binding hanya pada 1 owner untuk setiap data di satu lifetime/scope. Ketika lifetime habis atau scope berpindah, terjadi dua kemungkinan: data berpindah ownership(<em>move</em>), atau data di-<em>drop</em>. Eksklusivitas dari data ini memberikan handle yang aman terhadap data dari segala memory issue dan juga terhadap concurrency issue. Selain itu juga memberikan kemampuan GC tanpa GC.</p>
<p><em>Shared</em> data merupakan data yang di-<em>borrowed</em>, biasanya data yang berupa reference type(&amp;). <em>Borrow</em> bisa bersifat <em>immutable</em> dan <em>mutable</em>. <em>Immutable borrow</em> dilakukan untuk memberikan data yang bersifat read-only, tanpa melakukan <em>copy</em> terhadap original data. <em>Mutable borrow</em> dilakukan ketika ingin memberi <em>side-effects</em> terhadap suatu data, tentunya juga tanpa <em>copy</em> terhadap original data. <em>Borrow</em> sangat penting ketika data yang diolah cukup besar dalam size, dan tidak efisien ketika di-<em>copy</em>, sehingga cukup dengan mengirim <em>reference</em> terhadap data tersebut. Rust menerapkan <em>borrow checker</em> untuk memastikan semua lifetime reference type valid dan data yang direferensikan valid, pada saat compile-time tentunya.</p>
<h2 id="data-race-check"><a class="header" href="#data-race-check">Data Race Check</a></h2>
<p>Thread safety merupakan fitur yang didapatkan setelah menerapkan type dan memory safety. </p>
<p>Bahasa lain seperti Golang, memiliki feature race detector untuk mendeteksi data race. Akan tetapi feature ini tidak ZCA karena kita harus membayar cost yang sangat besar jika ingin menggunakannya(build dengan flag <code>-race</code>). Menurut situs official <a href="https://go.dev/doc/articles/race_detector#Runtime_Overheads">ini</a>, data race detector pada Golang bisa memberikan runtime overhead sebesar 5-10x memory usage dan 2-20x execution time. </p>
<p>Rust dengan konsep memory safety dan ZCA dapat mendeteksi data race saat compile-time tanpa overhead saat runtime. <em>Check</em> ini dilakukan pada saat compile time dengan memeriksa <em>ownership</em> suatu data, dengan memanfaatkan <em>borrow checking</em> setiap references/pointers yang di-share secara mutable antar threads akan gagal di-compile.</p>
<h2 id="zero-cost-async-with-future"><a class="header" href="#zero-cost-async-with-future">Zero-cost Async with Future</a></h2>
<p>Rust pada awalnya menerapkan <a href="https://cfsamson.github.io/books-futures-explained/0_background_information.html#green-threadsstackful-coroutines">greenthread</a> untuk runtime asynchronousnya, tetapi di-remove sebelum versi 1.0. Beberapa alasan di-remove di antaranya greenthread memiliki cost runtime, stackful, stateful, need to store CPU state inside memory in each context switch, kalau ingin FFI maka butuh switch context dan thread lebih besar lagi, karena beda call semantics antar bahasa. </p>
<p>Akhirnya metode asynchronous yang diterapkan adalah Future-based, yaitu pendekatan functional terhadap asynchronous code. Future bekerja layaknya state machine yang di execute oleh semacam <em>executor</em>(provided by async library e.g. Tokio). Future sebenarnya adalah monad yang mengkombinasikan closure2 yang di-execute lazily. Dari sudut pandang user kode terlihat asynchronous dengan syntax sugar async/await, akan tetapi ketika di-compile, future akan dikonversikan ke semacam state-machine yang saling sinkron dengan state-state yang ada(pakai enum, dengan state2 seperti wake, pending, finished, etc), jadi tidak ada cost context switch pada level runtime, akan tetapi pada level code oleh type system.</p>
<p>Berikut contoh sederhana perbandingan async pada go dan rust:
Program berikut melakukan looping terhadap fungsi yang dijalankan secara asynchronous.</p>
<p>Golang:</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func main() {
	start := time.Now()
	for i := 0; i &lt; 100000; i++ {
		go nothing()
	}
	end := time.Since(start)
	fmt.Printf(&quot;elapsed: %v&quot;, end)
}

func nothing() {}
</code></pre>
<p><strong>Go Result:</strong>: <code>elapsed: 29.846477ms</code></p>
<br/>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">use tokio::time::Instant;

#[tokio::main]
async fn main() {
    let start = Instant::now();
    for i in (0..100000) {
        nothing().await;
    }
    let end = start.elapsed();
    println!(&quot;elapsed: {:#?}&quot;, end);
}

async fn nothing() {}</code></pre></pre>
<p><strong>Rust Result</strong>: <code>elapsed: 56.724s</code></p>
<p>Pada benchmark sederhana di atas Rust lebih cepat sekitar 500x lebih cepat. </p>
<p>Microbenchmark ini mungkin tidak berarti apa-apa untuk real life application. Tapi disini bisa dilihat gimana cost untuk spawn <em>goroutine</em>(greenthread), dibanding pendekatan <em>future</em> yang dilakukan Rust secara zero-cost, tanpa melakukan apapun pada fungsi yang dipanggil.</p>
<p>Go memiliki cost <em>spawning</em> pada saat runtime dengan ukuran stack awal 2KB, yang bisa grow sesuai kebutuhan. Bayangin setiap iterasi melakukan ada stack switching ke stackframe nya goroutine. Pada rust semua futures chain di jadikan fungsi-fungsi yang sinkron layaknya state machine tanpa switch stack karena stackless coroutine.</p>
<h2 id="generics--traits"><a class="header" href="#generics--traits">Generics &amp; Traits</a></h2>
<p>Generic pada Rust bersifat monomorphism, dimana terjadi monomorphization terhadap fungsi yang generic menjadi fungsi-fungsi yang lebih spesific sesuai dengan boundary type parameters. Semua ini merupakan fungsi stand-alone dan bisa dioptimisasi oleh compiler pada saat compile-time. Bahasa lain seperti Java menerapkan <em>type-erasure</em> dimana type dihapus dan diganti dengan object class yang mana semua class inherit dan generics pada java sebenarnya meng-automatisasi casting ke object class ini.</p>
<p>Monomorphization ini sebenarnya hal yang cukup <em>straightforward</em>, contoh:
Tanpa generics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_i32() {
    ...
}

fn do_i64() {
    ...
}

fn do_f32() {
    ...
}

fn do_f64() {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Dengan generics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do&lt;T: Sized + Copy&gt;(param: T) {
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Generics dibarengi dengan traits, dapat memberikan polimorfisme pada fungsi/method tanpa runtime cost seperti pada interface di bahasa lain(Go, Java, etc).
Sized dan Copy merupakan marker traits untuk sifat-sifat suatu tipe data, Sized merupakan traits untuk tipe yang diketahui sized nya pada saat compile time dan fixed, serta Copy merupakan traits untuk tipe data yang dapat dicopy bit-by-bit dengan sangat murah, misal primitive types. Semua primitive types sudah implements Copy secara default. Fungsi di atas akan di-konversi ke beberapa bentuk di atas dan di optimisasi oleh compiler(e.g inlining).</p>
<h2 id="static-dispatch"><a class="header" href="#static-dispatch">Static Dispatch</a></h2>
<p>Rust memiliki handle untuk polymorphism yang bisa melakukan method dispatches statically. Dispatch jenis ini memproses tipe data dengan trait bersangkutan pada saat compile-time dan memastikan semua matched dan tanpa menyimpan states pada saat runtime(e.g. pointers and vtables).</p>
<p>Interface pada Golang merupakan semacam <em>fat pointer</em> dimana menyimpan reference untuk DST(Dynamically Sized Type) seperti concrete data dan methods. Ketika kita melakukan passing data ke dalam atau ke luar interface, data tersebut akan escape ke heap karena interface yang digunakan akan melakukan lookup ke vtable pada saat runtime ketika interface dipanggil/assert. Proses lookup ini membutuhkan runtime overhead dan tidak cacheable oleh CPU karena butuh call ke ranah memori untuk data dan function signatures.</p>
<p>Rust melakukan static dispatch dengan memanfaatkan trait. Kita bisa menggunakan syntax <code>impl Trait</code> atau dengan notasi generic.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust">pub trait Animal {
    fn walk(&amp;self);
    fn sleep(&amp;self);
    fn eat(&amp;self);
}

fn static_dispatch&lt;A: Animal&gt;(a: A) {
    a.walk();
    a.sleep();
    a.eat();
}

fn static_dispatch_impl(a: impl Animal) {
    a.walk();
    a.sleep();
    a.eat();
}

struct Cat;

impl Animal for Cat {
    fn walk(&amp;self) {
        println!(&quot;cat is walking...!&quot;)
    }
    fn sleep(&amp;self) {
        println!(&quot;cat is sleeping...!&quot;)
    }
    fn eat(&amp;self) {
        println!(&quot;cat is eating...!&quot;)
    }
}

fn main() {
    let c = Cat;
    static_dispatch(c);
    static_dispatch_impl(c);
}</code></pre></pre>
<p>Ketika <code>c</code> di-pass ke dalam <code>static_dispatch</code> atau <code>static_dispatch_impl</code>, akan terjadi monomorphization terhadap <code>c</code> sesuai dengan Trait yang diimplementasikan.</p>
<h2 id="iterator-1"><a class="header" href="#iterator-1">Iterator</a></h2>
<p>Pattern iterator bisa diterapkan dengan sedemikian abstraksi dan ketika di-compile stripped-down layaknya <em>optimized hand-written</em> code dengan manual looping, seperti di C. 
Contoh:</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() -&gt; i32 {
    sum() + sum() + sum() + sum() + sum() + sum() + sum() + sum()+ sum() + sum()+ sum() + sum()
}

pub fn sum() -&gt; i32 {
    vec![1, 2, 3].into_iter().reduce(|x, y| x + y).unwrap()
}</code></pre></pre>
<p>Kode di atas jika dilihat di x86-64 menjadi:</p>
<pre><code class="language-asm">example::main:
        mov     eax, 72
        ret

example::sum:
        mov     eax, 6
        ret
</code></pre>
<p>Kita bisa lihat bahwa pada asm di atas hasil dari komputasi fungsi <code>sum()</code> sudah diketahui hasil nya dan penjumlahan dari beberapa fungsinya juga telah diketahui hasil nya. Jika kita bandingkan dengan bahasa lain terdapat proses komputasi pada saat looping, dan juga setiap ekspresi pemanggilan fungsi juga terjadi komputasi satu-per-satu. Abstraksi iterator yang kita buat di atas di-kompilasi sedemikian rupa sehingga memiliki performa yang sama dengan <em>highly optimized hand-written code</em>.
Ini cuma salah satu dari banyak contoh dalam iterator pattern yang bisa dieksplor.</p>
<h2 id="zero-sized-types"><a class="header" href="#zero-sized-types">Zero-sized Types</a></h2>
<p>Kita bisa mendeklarasi tipe data cuma sebagai marker dan tidak memakan resource pada saat compile-time. Ini digunakan sebagai bagian dari analysis program secara statis.
Konsep <em>ownership</em> dan <em>borrowing</em> masih berlaku pada saat program di-kompilasi sehingga secara semantic masih berlaku sama dan semua <em>markers</em> tersebut di-<em>stripped</em> pada saat compile-time.</p>
<h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Macro adalah salah satu feature Rust untuk meng-ekstensi syntax bahasa. Macro juga digunakan untuk mengurangi beberapa hal yang bersifat <em>repetitive</em> ketika koding, dengan meng-automatisasi syntax generations dan juga melakukan type checks, <em>at compile-time</em>.</p>
<p>Macro juga feature yang sangat significant untuk menulis DSL.</p>
<h2 id="auto-vectorization"><a class="header" href="#auto-vectorization">Auto-Vectorization</a></h2>
<p>Rust memiliki optimisasi kompilasi dimana compiler menerapkan SIMD(<em>Single Instruction, Multiple Data</em>). Diantara optimisasi yang diterapkan secara default adalah SIMD SSE dan SSE2 pada CPU Intel x86. Masih banyak optimisasi lain yang terjadi, tapi SIMD lah salah satu optimisasi yang cukup significant yang dapat meningkatkan performa program tanpa effort dari programmer, tanpa harus optimisasi manual <em>hand-coded</em>, tanpa harus menghilangkan abstraksi pada code. </p>
<p>Salah satu contoh SIMD adalah contoh pada iterator di atas, dimana di dalam looping dan iterator tidak terjadi <em>actual looping</em> jika dilihat pada baris kode, akan tetapi semua dijadikan 1 vektor data yang dieksekusi oleh 1 instruksi CPU. Kita bisa bandingkan ini dengan hasil asm dari bahasa lain.</p>
<br/>
<p>Mungkin masih banyak jenis ZCA yang ada di Rust yang belum di-cover di sini. 
Tanpa ZCA, developers biasanya berdebat antara membuat code yang <em>maintainable</em> atau membuat code yang <em>performant</em>. Dua hal ini sering bertentangan satu sama lain karena <em>maintainability</em> menerapkan banyak abstraksi pada kodenya demi readibility, clarity, dan kemudahan untuk developer dalam implementasi fungsionalitas program tanpa <em>hand-coding</em>. Sedangkan sebagian developers juga memiliki <em>concern</em> terhadap <em>performance</em> dari code mereka, sehingga tidak jarang abstraksi dihilangkan dan menghasilkan kode yang kurang maintainable dengan readibility yang hanya bisa dipahami oleh penulis awal program tersebut.</p>
<p>Dengan ZCA, hal ini dapat teratasi karena developer masih bisa menerapkan abstraksi pada kode mereka untuk menjaga maintainability dengan sedemikian abstraksi, ketika program di-kompilasi, compiler akan mengoptimisasi kode dengan salah satunya menerapkan ZCA untuk menghilangkan abstraksi yang tidak relevan pada saat runtime sehingga performansi program tetap terjaga.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<p>Smart Pointer merupakan Abstract Data Type untuk memudahkan manajemen memori tanpa reference/borrowing karena smart pointer memiliki ownership terhadap data yang di-<em>point</em>. Hampir semua smart pointer digunakan untuk manajemen data di heap dan memudahkan passing antar data tanpa harus berurusan dengan reference dan lifetime.</p>
<p>Kita telah menemui beberapa smart pointer sebelumnya seperti <code>String</code>, <code>Vec&lt;T&gt;</code>, <code>HashMap&lt;K,V&gt;</code>, dll. Dari contoh yang pernah kita gunakan, bisa ditarik garis besar bahwa smart pointer adalah salah satu jenis memory management high-level untuk data-data yang di store di heap karena data tersebut dynamically sized dan tidak diketahui pasti size nya saat compile time, dan berubah2. Data-data pada heap tersebut direpresentasikan oleh <em>handle</em> yang stack-allocated dan memiliki move semantics berlaku padanya, sehingga akan move atau drop jika berpindah scope. </p>
<p>Smart pointer mengimplementasikan 2 trait utama di dalam rust yaitu: <code>Deref</code> dan <code>Drop</code>. <code>Deref</code> digunakan untuk me-<em>dereference</em> data yang ada di heap dan <code>Drop</code> untuk menghapus data pada heap jika sudah keluar scope. Move semantics sudah otomatis di-implement karena kebanyakan smart pointers ini dibuat menggunakan custom types seperti <code>struct</code> yang tidak meng-implement <code>Copy</code> trait sehingga move semantics berlaku padanya.</p>
<p>Beberapa contoh penggunaan smart pointer untuk data yang dynamic dan tidak diketahui size nya pada saat compile-time:</p>
<ul>
<li>User inputs.</li>
<li>Recursive data.</li>
<li>OOP style polymorphism (bukan ADT style polymorphism).</li>
<li>Pointer pengganti reference type dan tidak ingin berurusan dengan lifetime annotations.</li>
</ul>
<p>Kali ini kita akan membahas beberapa contoh smart pointer pada Rust:</p>
<h2 id="boxt"><a class="header" href="#boxt"><code>Box&lt;T&gt;</code></a></h2>
<p>Smart pointer paling sederhana untuk mengalokasi data ke heap. Digunakan ketika kita ingin menggunakan data yang tidak diketahui size nya saat compile time(e.g. user input), dan bersifat dynamic in size.</p>
<p>Diantara sifat-sifat Box:</p>
<ul>
<li>Single ownership</li>
<li>Move or drop apply if out of scope</li>
<li>Immutable and mutable borrows checked at compile time</li>
</ul>
<p>Deref Coercions:</p>
<ul>
<li>Dereference: <code>T = Box&lt;U&gt; -&gt; *T = U</code></li>
<li>Reference:   <code>T = Box&lt;U&gt; -&gt; &amp;T = &amp;U</code></li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    do_box();
}

pub fn do_box() {
    // 123 akan di-alokasikan ke heap memory.
    // ownership rule berlaku untuk 123 di heap dan akan di-release jika keluar dari scope.
    let boxed_i32 = Box::new(123);

    // T = Box&lt;U&gt; -&gt; *T = U
    // *T dimana T adalah smart pointer, akan meng-dereferensikan isi dari smart pointer
    dereference(*boxed_i32);

    // T = Box&lt;U&gt; -&gt; &amp;T = &amp;U
    // &amp;T dimana T adalah smart pointer, akan meng-referensikan isi dari smart pointer
    reference(&amp;boxed_i32);

    // calling method on box depends on `self` type, since it's call-by-value(`self`) then will automatically got deferred by compiler.
    println!(&quot;{}&quot;, boxed_i32.pow(2));

    let mut boxed_i32 = Box::new(123);
    println!(&quot;before dereference_mut: {boxed_i32}&quot;);
    // Karena value dari explicit dereference akan di copy ke dalam parameter, mutability hanya berlaku pada scope fungsi.
    dereference_mut(*boxed_i32);
    println!(&quot;after dereference_mut: {boxed_i32}&quot;);

    println!(&quot;---&quot;);

    println!(&quot;before reference_mut: {boxed_i32}&quot;);
    // T = Box&lt;U&gt; -&gt; &amp;mut T = &amp;U
    // &amp;mut T dimana T adalah smart pointer, akan meng-dereferensikan isi dari smart pointer
    reference_mut(&amp;mut boxed_i32);
    println!(&quot;after reference_mut: {boxed_i32}&quot;);
}

fn dereference(n: i32) {
    println!(&quot;from inside dereference: {n}&quot;);
}

fn reference(n: &amp;i32) {
    println!(&quot;from inside reference: {n}&quot;);
}

fn dereference_mut(mut n: i32) {
    n += 1;
}

fn reference_mut(n: &amp;mut i32) {
    *n = *n + 1;
}</code></pre></pre>
<h2 id="rct"><a class="header" href="#rct"><code>Rc&lt;T&gt;</code></a></h2>
<p>Merupakan smart poninter untuk membagikan ownership terhadap suatu data(<em>shared ownership</em>) atau meminjamkan suatu data ke-berbagai borrower(<em>multiple borrower</em>) secara <em>immutable</em>. Digunakan ketika kita ingin membagian reference tanpa harus berurusan dengan lifetime dan data dapat dengan mudah di-bagikan.</p>
<p>Diantara sifat-sifat dari Rc:</p>
<ul>
<li>Multiple ownership.</li>
<li>Immutable shared references(read only).</li>
<li>If out of scope, heap data will be deallocated iff all references already out of scope.</li>
<li>Immutable borrows checked at compile time.</li>
<li>Unsafe for multithreading.</li>
</ul>
<p>Deref Coercions:</p>
<ul>
<li>Reference: <code>T = Rc&lt;U&gt; -&gt; &amp;T = &amp;U</code></li>
<li>Dereference: <code>T = Rc&lt;U&gt; -&gt; *T = U</code> --&gt; When dereferencing value inside Rc, if the type of value doesn't implement Copy trait, then ownership move happen, this will fail because Rc is shared among multiple owner, hence 1 cannot take sole ownership of it. Beside, Rc is immutable reference smart pointer, no reason to take ownership of value out of it. </li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Debug)]
pub struct Data;

pub fn do_rc() {
    let data = Data;
    dbg!(data); // dbg! macro move ownership of non copyable value
                // dbg!(data); // can't call debug data here since already moved into dbg!(data)

    let shared_data = Rc::new(Data);
    let borrow_shared_data = Rc::clone(&amp;shared_data);
    let c = &amp;borrow_shared_data;
    let d: &amp;Rc&lt;_&gt; = &amp;borrow_shared_data;
    let e: &amp;Rc&lt;Data&gt; = &amp;borrow_shared_data;
    let f: &amp;Data = d; // &amp;Rc&lt;T&gt; get coerced into &amp;T
    println!(&quot;c - d - e - f -&gt; {:?} - {:?} - {:?} - {:?}&quot;, c, d, e, f);

    let count = Rc::strong_count(&amp;shared_data);
    println!(&quot;strong count: {count}&quot;);
    // reference counts: 1. shared_data, and 2. borrow_shared_data
    assert_eq!(2, count);
    {
        let inner_scope_borrow = Rc::clone(&amp;borrow_shared_data);
        let inner_count = Rc::strong_count(&amp;shared_data);
        // reference counts: 1. shared_data, 2. borrow_shared_data, and 3. inner_scope_borrow
        assert_eq!(3, inner_count);
        println!(&quot;inner strong count: {inner_count}&quot;);
        println!(&quot;inner_scope_borrow drop here&quot;);
    }

    // T = Rc&lt;U&gt; -&gt; &amp;T = &amp;U
    // &amp;T dimana T adalah Rc&lt;U&gt;
    reference(&amp;borrow_shared_data);
    dbg!(&amp;shared_data);
    dbg!(&amp;borrow_shared_data);

    // cannot move value out of Rc, because Rc is shared reference and might already shared among others, so anyone cannot take sole ownership of it.
    // T = Rc&lt;U&gt; -&gt; *T = U --&gt; FAILED, won't work for Rc smart pointer because it's shared reference sp. Make sure only 1 reference left, and use `try_unwrap()`.
    // &amp;T dimana T adalah Rc&lt;U&gt;
    // dereference(*borrow_shared_data);

    println!(
        &quot;before delete: shared_data --&gt; strong count: {:?}&quot;,
        Rc::strong_count(&amp;shared_data)
    );
    drop(borrow_shared_data);
    println!(
        &quot;after delete: borrow_shared_data --&gt; strong count: {:?}&quot;,
        Rc::strong_count(&amp;shared_data)
    );

    // Rc::try_unwrap(T) only success if there's only 1 reference left in the counting.
    // there were 2 reference before: 1. `shared_data` and 2. `borrow_shared_data`,
    // we delete reference borrow_shared_data leaving only one reference and can be unwrap without runtime panic.
    dbg!(Rc::try_unwrap(shared_data));
    // dereference(Rc::try_unwrap(borrow_shared_data).unwrap());

    let s = String::from(&quot;anu&quot;);
    let borrow_string = Rc::from(&amp;s);
    let borrow_borrow_string = Rc::clone(&amp;borrow_string);
    println!(&quot;borrow_string count: {}&quot;, Rc::strong_count(&amp;borrow_string));
    println!(
        &quot;borrow_borrow_string count: {}&quot;,
        Rc::strong_count(&amp;borrow_borrow_string)
    );
}

fn dereference(data: Data) {
    println!(&quot;inside dereference: {:?}&quot;, data)
}

fn reference(data: &amp;Data) {
    println!(&quot;inside reference: {:?}&quot;, data)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="refcellt"><a class="header" href="#refcellt"><code>RefCell&lt;T&gt;</code></a></h2>
<p>Jika <code>Rc&lt;T&gt;</code> bersifat immutable reference, maka kita bisa menggunakan <code>RefCell&lt;T&gt;</code> untuk interior mutability. Interior mutability memberikan mutability pada inner data di dalam smart pointer. Smart pointer ini memberikan fleksibilitas untuk data yang immutable, tetapi memiliki kemungkinan untuk menjadi mutable. 
Method <code>borrow()</code> return <code>Ref&lt;T&gt;</code> for many immutable references.
Method <code>borrow_mut()</code> return <code>RefMut&lt;T&gt;</code> for 1 mutable reference.</p>
<p>Sifat-sifat <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li>Single ownership.</li>
<li>interior mutability, you can mutate value inside RefCell even if RefCell declared as immutable.</li>
<li>Immutable or mutable borrows checked at runtime.</li>
<li>Can panic at runtime because borrow checking happen both at runtime.</li>
<li>Unsafe for multithreading.</li>
<li>Doesn't implement Deref trait.</li>
</ul>
<p>Panic cases:</p>
<ul>
<li>More than 1 mutable borrow.</li>
<li>immutable and mutable borrow in the same scope.</li>
<li>Use <code>try_borrow()</code> or <code>try_borrow_mut()</code> for non-panics way of handling borrows for immutable and mutable reference(respectively).</li>
</ul>
<p>No Deref coercions since it's not implementing Deref trait. 
Instead, use methods <code>borrow()</code>/<code>try_borrow()</code> and <code>borrow_mut()</code>/<code>try_borrow_mut()</code> to borrow value inside immutably or mutably.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;

pub fn do_refcell() {
    let refcell_data = RefCell::new(123);

    // ! Doing immutable and mutable reference in one scope will panic as value already borrow while mutating in the same scope.
    // let borrow = refcell_data.borrow();
    // let borrow_mut = *refcell_data.borrow_mut() + 123;

    *refcell_data.borrow_mut() = 456;
    dbg!(refcell_data.borrow());
    *refcell_data.borrow_mut() += 123;
    dbg!(refcell_data.borrow());

    let mut borrow_mut = refcell_data.borrow_mut();
    dbg!(&amp;borrow_mut);
    *borrow_mut = 900;
    dbg!(&amp;borrow_mut);
    *borrow_mut += 4;
    dbg!(&amp;borrow_mut);
}

fn main() {
    do_refcell();
}
</code></pre></pre>
<h2 id="memory-leak-of-cyclic-references"><a class="header" href="#memory-leak-of-cyclic-references">Memory Leak of Cyclic References</a></h2>
<p>Ada satu case memory yang tidak bisa dijamin oleh Rust yaitu reference cycle leaks. Ini merupakan suatu kondisi dimana suatu data <em>pointing</em> ke diri sendiri, atau nested data structure <em>pointing</em> ke satu sama lain. </p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            List::Cons(_, item) =&gt; Some(item),
            List::Nil =&gt; None,
        }
    }
}

fn main() {
    // a = 5 - Nil
    let a = Rc::new(List::Cons(5, RefCell::new(Rc::new(List::Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    // b = 10 - a(5 - Nil)
    let b = Rc::new(List::Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    // a = 5 - b
    // b = 10 - a
    // a = 5 - b(10 - a(5 - b(10 - a(5 - b(10 - a(5 - b(10 - a(5 - b(10 - a(5 - ...))))))))))  --&gt; keep referencing each others, causing leaks, stackoverflow!
    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // a.tail() causes leak because above reason.
    // println!(&quot;a next item = {:?}&quot;, a.tail()); 
}</code></pre></pre>
<h2 id="weakt-for-preventing-reference-cycle"><a class="header" href="#weakt-for-preventing-reference-cycle"><code>Weak&lt;T&gt;</code> for Preventing Reference Cycle</a></h2>
<p>Setiap references menggunakan Rc menambahkan count yang bersifat strong, dalam artian selama masih ada Rc maka tidak akan direlease semua dari memory karena cycle reference menyebabkan strong count tidak sampai 0. Untuk mengatasi ini, cycle reference bisa diganti dengan <code>Weak&lt;T&gt;</code> yang menyebabkan semua references menggunakan <code>Weak&lt;T&gt;</code> akan di-release setelah semua strong count mencapai 0.</p>
<p>Perbedaan antara Rc strong dan weak adalah:</p>
<ul>
<li>strong Rc butuh count 0 untuk di-clean.</li>
<li>weak Rc tidak butuh count 0 untuk di-clean, ketika <strong>semua</strong> strong count sudah 0, maka semua weaks akan di-clean juga.</li>
<li>Rc memiliki ownership terhadap data.</li>
<li>Weak tidak memiliki ownership terhadap data.</li>
</ul>
<p>Contoh leaks scenario:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// ! THIS CAUSE MEMORY LEAKS AS THERE'S CYCLIC REFERENCE IN THE CODE.
/// 
/// 
use std::{
    borrow::{Borrow, BorrowMut},
    cell::RefCell,
    rc::{Rc, Weak},
};

#[derive(Debug)]
pub struct Person {
    name: String,
    // cyclic reference happen between parent and childs because parent's child's parent's child's parent's ...
    parent: Option&lt;RefCell&lt;Rc&lt;Person&gt;&gt;&gt;,
    childs: Option&lt;RefCell&lt;Vec&lt;Rc&lt;Person&gt;&gt;&gt;&gt;,
}

pub fn do_rc_leak() {
    let arif = Rc::new(Person {
        name: &quot;arif&quot;.to_string(),
        parent: None,
        childs: Some(RefCell::new(vec![])),
    });

    let anak_arif = Rc::new(Person {
        name: &quot;ahmad&quot;.to_string(),
        parent: Some(RefCell::new(Rc::clone(&amp;arif))),
        childs: Some(RefCell::new(vec![])),
    });

    arif.childs.as_ref().unwrap().borrow_mut().push(Rc::clone(&amp;anak_arif));

    dbg!(&amp;arif); // read arif
    dbg!(&amp;arif.childs.as_ref().unwrap().borrow()); // read arif's child
    dbg!(&amp;arif
        .childs
        .as_ref()
        .unwrap()
        .borrow()
        .get(0)
        .unwrap()
        .parent
        .borrow()); // read arif's child's parent, which is arif himself
}
<span class="boring">}</span></code></pre></pre>
<p>Contoh non leak:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    borrow::{Borrow, BorrowMut},
    cell::RefCell,
    rc::{Rc, Weak},
};

#[derive(Debug)]
pub struct Person {
    name: String,
    // no cyclic reference happen here because bind to parent is weak so child doesn't own its parent, otherwise parent own its child.
    parent: RefCell&lt;Weak&lt;Person&gt;&gt;,
    childs: Option&lt;RefCell&lt;Vec&lt;Rc&lt;Person&gt;&gt;&gt;&gt;,
}

pub fn do_weak() {
    let arif = Rc::new(Person {
        name: &quot;arif&quot;.to_string(),
        parent: RefCell::new(Weak::new()),
        childs: Some(RefCell::new(vec![])),
    });

    let anak_arif = Rc::new(Person {
        name: &quot;ahmad&quot;.to_string(),
        parent: RefCell::new(Rc::downgrade(&amp;arif)),
        childs: Some(RefCell::new(vec![])),
    });

    arif.childs.as_ref().unwrap().borrow_mut().push(Rc::clone(&amp;anak_arif));

    dbg!(&amp;arif); // read arif
    dbg!(&amp;arif.childs.as_ref().unwrap().borrow()); // read arif's child
    dbg!(&amp;arif
        .childs
        .as_ref()
        .unwrap()
        .borrow()
        .get(0)
        .unwrap()
        .parent
        .borrow()
        .upgrade()); // read arif's child's parent, which is arif himself
    dbg!(&amp;arif.parent.borrow().upgrade()); // read arif's parent
}
<span class="boring">}</span></code></pre></pre>
<p>Method <code>downgrade(&amp;T)</code> digunakan untuk membuat weak Rc.
Method <code>upgrade()</code> digunakan untuk mendapat strong Rc, untuk men-dereferensikan weak reference, harus di-upgrade dulu.</p>
<h2 id="cowa-b"><a class="header" href="#cowa-b"><code>Cow&lt;'a, B&gt;</code></a></h2>
<p>Smart pointer ketika kita memiliki dua kemungkinan antara <em>borrow</em> atau <em>own</em> suatu data(<em>optional ownership</em>). Kita biasa nya melakukan immutable reference terhadap data yang bersifat readonly, akan tetapi sepanjang jalan program, ada kemungkinan kita butuh mengubah data tersebut, sehingga butuh ownership untuk melakukan perubahan, bisa saja menggunakan mutable reference, tapi akan dilimit oleh beberapa limitasi mutable reference.</p>
<p>Cow akan memeriksa apakah <code>T</code> yang dimasukkan implement <code>ToOwned</code>.
Jika <code>T</code> merupakan owned type, maka versi reference nya akan dicek apakah implement <code>ToOwned</code> ke bentuk <code>T</code>,
Jika <code>T</code> merupakan borrowed type, maka dicek apakah implements <code>ToOwned</code>.</p>
<p>Cow implements <code>Deref</code> trait.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::Cow;

pub fn do_cow() {
    let literal = &quot;anu&quot;;
    let mut new_cow = Cow::from(literal);
    let reference_new_cow = &amp;new_cow;
    println!(&quot;{:?}&quot;, reference_new_cow);
    let dereference_new_cow = &amp;*new_cow;
    println!(&quot;{:?}&quot;, dereference_new_cow);

    // if values already in owned form, no cloning happen. Otherwise convert it to owned form by cloning the data into heap.
    // cloning happen because slice_cow is in borrowed form &amp;str.
    let mut_string = new_cow.to_mut();
    let owned = new_cow.into_owned();

    let slice: &amp;[i32] = &amp;[1, 2, 3, 4, 5];
    let mut slice_cow = Cow::from(slice);

    println!(&quot;{:?}&quot;, slice_cow);
    let reference_slice_cow: &amp;[i32] = &amp;slice_cow;
    println!(&quot;{:?}&quot;, reference_slice_cow);
    let dereference_slice_cow = &amp;*slice_cow;
    println!(&quot;{:?}&quot;, dereference_slice_cow);

    // if values already in owned form, no cloning happen. Otherwise convert it to owned form by cloning the data into heap.
    // cloning happen because slice_cow is in borrowed form &amp;[i32].
    let mut_string = slice_cow.to_mut();
    let owned = slice_cow.into_owned();

    let v = vec![1, 2, 3, 4, 5];
    let mut cow_v = Cow::from(v);

    match cow_v {
        Cow::Borrowed(x) =&gt; println!(&quot;{:?} is borrowed&quot;, x),
        Cow::Owned(ref x) =&gt; println!(&quot;{:?} is owned&quot;, x),
    }

    // no clone happen because v already in owned form.
    let mut_vec = cow_v.to_mut();
    let owned_vec = cow_v.into_owned();

    let command = &quot;this should be all upperCase&quot;;
    println!(&quot;{:?}&quot;, check_uppercase(command));

    let v = vec![1, -2, 3, -4, -5];
    let input = Cow::from(v);
    // no cloning happen, because v already in owned form.
    println!(&quot;{:?}&quot;, check_vector(input));

    let v = &amp;[1, -2, 3, -4, -5] as &amp;[i32];
    let input = Cow::from(v);
    // cloning happen because v is in borrowed form &amp;[i32].
    println!(&quot;{:?}&quot;, check_vector(input));
}

// this function return either borrowed &amp;str or owned String
fn check_uppercase(s: &amp;str) -&gt; Cow&lt;str&gt; {
    if s.chars().all(|x| x.is_uppercase()) {
        return s.into();
    }

    s.to_uppercase().into()
}

fn check_vector(v: Cow&lt;[i32]&gt;) -&gt; Vec&lt;i32&gt; {
    // if v already in owned form, no cloning happen, otherwise clone it and take ownership
    let it = v.into_owned().into_iter(); // if v is owned form, this line is zero cost, otherwise costing it cloning into heap.
    let ret = it.filter(|x| x.is_positive()).collect::&lt;Vec&lt;i32&gt;&gt;();
    ret
}
<span class="boring">}</span></code></pre></pre>
<h2 id="arct"><a class="header" href="#arct"><code>Arc&lt;T&gt;</code></a></h2>
<p>Sama seperti <code>Rc&lt;T&gt;</code>, bedanya kalau <code>Arc&lt;T&gt;</code> bersifat thread-safe dalam artian bisa digunakan antar threads.
Rc merupakan shared ownership, dalam artian setiap owner bisa melakukan perubahan terhadap data yang ada di dalamnya, hal ini tidak masalah jika komputasi berada dalam ranah sinkronus, akan tetapi menjadi masalah jika dalam ranah asinkronus karena akan menyebabkan data race dan UB.
Untuk memberikan sifat atomic pada data yang di-share antar threads, maka dibutuhkan <code>Arc</code>(Atomic Reference Counting).</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use std::rc::Rc;
use std::sync::Arc;
use std::thread::spawn;

pub fn do_arc() {
    let arc_data = Arc::new(123);

    // deref coercions:
    let ref_arc_data: &amp;i32 = &amp;arc_data;
    let deref_arc_data = *arc_data;

    // cannot send Rc between threads, because Rc doesn't implement Send trait
    // let data = Rc::new(RefCell::new(123));
    // let thread_1 = spawn(move || {
    //     *data.borrow_mut() += 1;
    // });
    // thread_1.join().unwrap();
    // println!(&quot;{:?}&quot;, data);

    // cannot send Rc between threads, because Rc doesn't implement Send trait
    // let data = Rc::new(123);
    // let thread_1 = spawn(move || {
    //     println!(&quot;{:?}&quot;, data);
    // });
    // thread_1.join().unwrap();
    // println!(&quot;{:?}&quot;, data);

    let data = Arc::new(123);
    let thread_1 = spawn(move || {
        println!(&quot;{:?}&quot;, data);
    });
    thread_1.join().unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="mutext"><a class="header" href="#mutext"><code>Mutex&lt;T&gt;</code></a></h2>
<p>Sama seperti kombinasi <code>Rc&lt;T&gt;</code> dan <code>RefCell&lt;T&gt;</code> untuk shared multiple ownership with interior mutability, maka untuk <code>Arc&lt;T&gt;</code> ada <code>Mutex&lt;T&gt;</code> untuk interior mutability yang thread-safe antar threads. Mutex merupakan smart pointer untuk melindungi shared mutable data antar threads dari data race dan UB.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::borrow::{Borrow, BorrowMut};
use std::ops::Add;
use std::sync::Arc;
use std::sync::Mutex;
use std::sync::Weak;
use std::thread;

#[derive(Debug)]
pub struct Person {
    name: String,
    shared_wealth: Arc&lt;Mutex&lt;i32&gt;&gt;,
    // no cyclic reference happen here because bind to parent is weak so child doesn't own its parent, otherwise parent own its child.
    parent: Mutex&lt;Weak&lt;Person&gt;&gt;,
    childs: Option&lt;Mutex&lt;Vec&lt;Arc&lt;Person&gt;&gt;&gt;&gt;,
}

pub fn do_mutex() {
    let shared_wealth = Arc::new(Mutex::new(0));

    let arif = Arc::new(Person {
        name: &quot;arif&quot;.to_string(),
        shared_wealth: Arc::clone(&amp;shared_wealth),
        parent: Mutex::new(Weak::new()),
        childs: Some(Mutex::new(vec![])),
    });

    let anak_arif = Arc::new(Person {
        name: &quot;ahmad&quot;.to_string(),
        shared_wealth: Arc::clone(&amp;shared_wealth),
        parent: Mutex::new(Arc::downgrade(&amp;arif)),
        childs: Some(Mutex::new(vec![])),
    });

    arif.childs
        .as_ref()
        .unwrap()
        .lock()
        .unwrap()
        .push(Arc::clone(&amp;anak_arif));

    dbg!(&amp;arif); // read arif
    dbg!(&amp;arif.childs.as_ref().unwrap().borrow()); // read arif's child
    dbg!(&amp;arif
        .childs
        .as_ref()
        .unwrap()
        .lock()
        .unwrap()
        .get(0)
        .unwrap()
        .parent
        .lock()
        .unwrap()
        .upgrade()); // read arif's child's parent, which is arif himself
    dbg!(&amp;arif.parent); // read arif's parent

    let parent_working = Arc::clone(&amp;arif);
    let parent_work = thread::spawn(move || {
        for _ in (0..10) {
            *parent_working.shared_wealth.lock().unwrap() += 1;
        }
    });

    let child_working = Arc::clone(&amp;anak_arif);
    let child_work = thread::spawn(move || {
        for _ in (0..10) {
            *child_working.shared_wealth.lock().unwrap() += 1;
        }
    });

    parent_work.join().unwrap();
    child_work.join().unwrap();
    dbg!(&amp;arif);
    let total_wealth = *arif.shared_wealth.lock().unwrap();
    assert_eq!(20, total_wealth);
}
<span class="boring">}</span></code></pre></pre>
<p>Kita menggunakan contoh pada kasus Rc dan RefCell di atas, akan tetapi kali ini untuk thread-safety karena kita akan mem-passing data antar threads. <em>Data race free</em> dan <em>no leaking</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-in-rust"><a class="header" href="#object-oriented-programming-in-rust">Object Oriented Programming in Rust</a></h1>
<p>OOP memiliki banyak definisi seiring waktu. Bermula dari Simula yang mengenalkan konsep object, program disusun sedemikian rupa dari sekumpulan object-object yang dibangung dari class, attributes, dan virtual procedures(methods). Selanjutnya oleh Smalltalk menambahkan konsep message passing, dimana object akan menerima suatu <em>message</em> melalui method-method nya, dan menyesuaikan state berdasarkan itu. Java datang dengan konsep yang mirip-mirip dan dijadikan acuan dalam OOP yaitu memiliki:</p>
<ul>
<li>Encapsulation: Information hiding terhadap detail implementasi dengan hanya memberi akses API lewat public API.</li>
<li>Inheritance: Ekstensi object memberikan relasi &quot;is a&quot;.</li>
<li>Polymorphism: Deklarasi common behaviour antar multiple objects. Diimplementasikan dengan menggunakan Vtable, dynamically checked.</li>
</ul>
<h2 id="encapsulation"><a class="header" href="#encapsulation">Encapsulation</a></h2>
<p>Secara gamblang, encapsulation merupakan cara meng-abstraksi API sehingga user tidak perlu melihat daleman API dan hanya berinteraksi melalui exposed interface. Di sebagian bahasa OOP hal ini dilakukan menggunakan access modifier seperti <em>public</em> dan <em>private</em>. Hal ini untuk mencapai <em>loosely coupling</em> pada design API sehingga implementor bisa fokus terhadap implementasi, dan client/user dari API bisa tetap menggunakan API yang sama tanpa peduli detail implementasi.</p>
<p>Definisi lain dari encapsulation adalah komposisi antara data dan behaviours(methods) ke dalam 1 entitas. Hal ini biasanya dideklarasi dalam bentuk <code>class</code> di kebanyakan bahasa OOP, dan di-instansiasi menjadi objek, semua akses API hanya lewat objek ini.</p>
<p>Pada Rust, ada beberapa cara untuk mencapai ini, diantaranya:</p>
<ul>
<li>Menggunakan associated items and methods, dan juga bisa di-ekstensi menggunakan trait.</li>
<li>Access modifier <code>pub</code>, semua komponen bersifat private, dengan <code>pub</code> membuatnya bisa di-akses oleh caller.</li>
<li>Menggunakan crate library <code>lib.rs</code> untuk mengekpose api-api yang bisa digunakan oleh client.</li>
<li>Menggunakan module untuk meng-segmentasi kode sedemikian rupa sehingga pengelompokkan API lebih terorganisir dan koheren.</li>
<li>Menggunakan inherent methods dengan beberapa public methods, dan private methods.</li>
<li>Menggunakan traits dengan shared custom types, methods, dan default types. Traits juga digunakan sebagai bound untuk type parameter API.</li>
<li>Menggunakan procedure macro untuk meng-abstraksi berbagai komputasi. Contoh yang sering kita lihat: <code>print!()</code>, <code>println!()</code>, <code>dbg!()</code>, <code>assert!()</code>, etc.</li>
</ul>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>Rust tidak memiliki inherintance layaknya kebanyakan bahasa OOP lainnya. Akan tetapi Rust menerapkan komposisi yaitu dengan meng-<em>embed</em> tipe data/struct/enum ke dalam fields. Inheritance sendiri memiliki masalah dalam dunia OOP karena cenderung menambah kompleksitas yang tidak diperlukan. Juga mempersulit <em>maintainance</em> dari suatu kode karena sedikit perubahan akan mengacaukan semua childs yang inherit suatu class, cenderung menjadi <em>spaghetti</em>. Selain itu juga bisa menimbulkan masalah yang disebut <em>diamond problem</em>. Inheritance bukan pilihan utama ketika membuat kode yang loosely coupled dan juga enkapsulasi lebih cenderung menggunakan interface(<em>composition</em>) ketimbang class inheritance. Rust memiliki relasi antar type yang disebut dengan <em>Subtyping</em>.</p>
<h2 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h2>
<p>Pada bahasa OOP umumnya polymorphism dilakukan menggunakan <em>interface</em>. Interface merupakan salah satu jenis inheritance yang bersifat <em>has-a</em> untuk mencapai composition.</p>
<p>Rust mengimplementasikan konsep polymorfisme melalui dua cara yaitu: <em>generic</em> dan <em>trait object</em>. Kita telah membahas generic pada pembahasan sebelumnya yaitu bersifat statis dan diperiksa pada saat compile-time. Akan tetapi pendekatan generics ini memiliki kekurangan yaitu hanya memiliki satu instance dalam satu waktu. Selain itu tipe data yang akan digunakan pada generic/type parameter harus diketahui size nya pada saat compile-time. Berangkat dari kekurangan inilah kita membutuhkan polymorfisme yang bersifat lebih dinamis dan semua tipe bisa di-inject pada saat runtime, sehingga tidak perlu di-specify semua pada saat run-time, cara ini disebut <em>trait object</em>.</p>
<p>Perbedaan generics dan trait object:</p>
<ul>
<li>Generic resolve at <em>compile-time</em>, while trait object resolve at <em>run-time</em>.</li>
<li>Hanya ada 1 instance tipe data pada tipe yang memiliki generic parameter, sedangkan trait object bisa memiliki menampung berbagai tipe selama tipe tersebut mengimplementasi deklarasi trait object tersebut.</li>
<li>Generic tidak memiliki runtime cost karena statically dispatched, sedangkan trait object memiliki runtime cost karena dynamically dispatched(seperti penggunaan vtable yang menampung semua pointer ke fungsi/methods yang digunakan).</li>
</ul>
<h1 id="oop-implementations-in-rust"><a class="header" href="#oop-implementations-in-rust">OOP Implementations in Rust</a></h1>
<h2 id="states"><a class="header" href="#states">States</a></h2>
<p>States adalah data yang berubah-ubah sepanjang program berjalan. Data ini biasanya disebut attributes di dalam bahasa OO yang mana states transitions nya dikendalikan oleh method-method dari object tersebut. Rust secara default bersifat <em>immutable</em>, karena kecenderungan functional programming. Akan tetapi kita bisa membuat sifat statefulness dari Rust ini dengan menggunakan keyword <code>&amp;mut self</code> pada deklarasi method. States merupakan efek dari behaviour object terhadap data yang dikandung object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct Object {
    field1: String,
    field2: i32,
    field3: u64,
}

impl Object {
    pub fn new(field1: String, field2: i32, field3: u64) -&gt; Self {
        Object {
            field1,
            field2,
            field3,
        }
    }

    pub fn method1(&amp;mut self) {
        self.field1.push_str(&quot;new str&quot;);
    }

    pub fn method2(&amp;mut self) {
        self.field2 += 1;
    }

    pub fn method3(&amp;mut self) {
        self.field3 += 340;
    }

    pub fn print(&amp;self) {
        println!(&quot;{:?}&quot;, self);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="encapsulation-1"><a class="header" href="#encapsulation-1">Encapsulation</a></h2>
<p>Encapsulation bisa memanfaatkan access modifier <code>pub</code> untuk public access, dan memanfaatkan komponen-komponen yang accessible lewat path <code>::</code> dan method.
Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// encapsulation
#[derive(Debug)]
struct A {
    field1: String,
    field2: i32,
}

impl A {
    fn new() -&gt; Self {
        A {
            field1: String::from(&quot;this A&quot;),
            field2: 123,
        }
    }
    fn method_a(&amp;self, n: u64) {
        println!(&quot;A: {n}&quot;)
    }
}

// kita meng-enkapsulasi A ke dalam B, sehingga A tidak perlu di-ekpose ke user.
#[derive(Debug)]
pub struct B {
    a: A,
    field3: u64,
}

impl B {
    pub fn new() -&gt; Self {
        B {
            a: A::new(),
            field3: 234,
        }
    }
    pub fn method_b(&amp;self) {
        println!(&quot;printing B&quot;);
        self.a.method_a(self.field3);
    }

    // data A di-enkapsulasi ke dalam B, sehingga bisa di akses tanpa akses ke A.
    pub fn method_b_2(&amp;self) -&gt; (&amp;str, i32) {
        (self.a.field1.as_str(), self.a.field2)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="polymorphism-menggunakan-trait-objectdyn-trait"><a class="header" href="#polymorphism-menggunakan-trait-objectdyn-trait">Polymorphism menggunakan trait object(<code>dyn Trait</code>)</a></h2>
<p>Polymorphism pada bahasa OOP umumnya merupakan dynamic polymorphism yang menggunakan <code>interface</code> untuk memasukkan object yang share common behaviours.
Rust menggunakan keyword <code>dyn</code> pada trait, untuk menandakan bahwa trait tersebut bisa menampung banyak tipe.</p>
<p>Apa yang membedakan generics dan trait object?</p>
<ul>
<li>generics di-resolve pada saat compile time, trait object di-resolve pada saat run-time.</li>
<li>generics hanya bisa memiliki 1 jenis tipe data pada satu waktu(saat definisi tipe), sedangkan trait object bisa memiliki banyak jenis tipe data pada satu waktu(saat definisi tipe).</li>
<li>generics bersifat zero cost, sedangkan trait object memiliki cost run-time vtable checking.</li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

// hanya bisa deklarasi i32 pada saat definisi tipe Vec&lt;T&gt; -&gt; Vec&lt;i32&gt;
let v = vec![1,2,3,4]; 

// hanya bisa deklarasi String pada saat definisi tipe Vec&lt;T&gt; -&gt; Vec&lt;String&gt;
let v: Vec&lt;String&gt; = vec![&quot;test&quot;.to_string(), &quot;test2&quot;.to_string()]; 


/// contoh penggunaan trait object untuk menampung berbagai tipe data pada saat definisi tipe.
pub trait Field: Debug {}
#[derive(Debug)]
pub struct Custom;

impl Field for i32 {}
impl Field for String {}
impl Field for &amp;str {}
impl Field for Custom {}

let mut v: Vec&lt;Box&lt;dyn Field&gt;&gt; = Vec::new();
v.push(Box::new(123));
v.push(Box::new(&quot;anu&quot;));
v.push(Box::new(String::from(&quot;nmnm&quot;)));
v.push(Box::new(Custom));

println!(&quot;{v:?}&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Kita bisa meng-elaborasi polymorphism di atas menjadi komposisi yang terdiri dari berbagai tipe object, object disini merupakan trait object.</p>
<p>Contoh: </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

/// composition
///
///

// IDep merepresentasikan &quot;interface&quot; ke depedensi yang akan di-inject
pub trait IDep: Debug {}
pub trait Field: Debug {}
#[derive(Debug)]
pub struct Custom;

impl Field for i32 {}
impl Field for String {}
impl Field for &amp;str {}
impl Field for Custom {}

#[derive(Debug)]
pub struct Struct {
    field1: Box&lt;dyn IDep&gt;,
    field2: Vec&lt;Box&lt;dyn Field&gt;&gt;,
}

// Dep adalah object dependensi itu sendiri
#[derive(Debug)]
pub struct Dep;
impl IDep for Dep {}

impl Struct {
    pub fn new() -&gt; Self {
        let mut v: Vec&lt;Box&lt;dyn Field&gt;&gt; = Vec::new();
        v.push(Box::new(123));
        v.push(Box::new(&quot;anu&quot;));
        v.push(Box::new(String::from(&quot;nmnm&quot;)));
        v.push(Box::new(Custom));
        Self {
            field1: Box::new(Dep),
            field2: v,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Rust memiliki pendekatan OOP yang berbeda dengan kebanyakan bahasa OOP, dimana tidak ada inheritance, dan kebanyakan variable adalah value, bukan object seperti di bahasa OOP. Beberapa pattern juga akan sangat berbeda jika diterapkan OOP dengan Rust. Trait object juga bisa di-inject ke dalam smart pointer jenis lain, sesuai kebutuhan. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h1>
<p>Subtyping adalah cara Rust untuk memberikan relasi terhadap tipe data. Subtyping dilakukan untuk memberikan fleksibilitas terhadap penggunaan tipe data. Contoh subtyping sudah kita bahas sebelumnya salah satunya dalam OOP yaitu inheritance, dimana relasi yang terjadi ada parent-child. Definisi lain menyatakan inheritance bukan subtyping, akan tetapi interface lah yang merupakan subtyping, karena memberikan sifat <em>substitutability</em> pada tipe data/objek.</p>
<p>Pada Rust, ada beberapa subtyping diantaranya:</p>
<ul>
<li>Trait</li>
<li>Closures and Function pointer</li>
<li>Lifetime</li>
</ul>
<h2 id="trait-2"><a class="header" href="#trait-2">Trait</a></h2>
<p>Trait bisa di-ekstensi menggunakan notasi <code>:</code>, menjadi subtrait. Semua type yang implements suatu subtrait, juga harus implement supertrait nya, tapi tidak sebaliknya.</p>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// subtyping in rust, replacing inheritance.

// trait subtyping
pub trait Base {
    fn walk(&amp;self);
}

pub trait Child: Base {
    fn run(&amp;self);
    fn fly(&amp;self);
}

#[derive(Debug, Clone)]
pub struct A {
    name: String,
}

impl A {
    pub fn new(name: &amp;str) -&gt; Self {
        Self {
            name: name.to_string(),
        }
    }
}

impl Base for A {
    fn walk(&amp;self) {}
}

impl Child for A {
    fn run(&amp;self) {}
    fn fly(&amp;self) {}
}

#[derive(Debug, Clone)]
pub struct B {
    name: String,
}
impl B {
    pub fn new(name: &amp;str) -&gt; Self {
        B {
            name: String::from(name),
        }
    }
}
impl Base for B {
    fn walk(&amp;self) {}
}

fn process&lt;T: Base&gt;(b: T) {
    println!(&quot;process called&quot;);
    b.walk();
}

fn process_return_base() -&gt; impl Base {
    B::new(&quot;anu&quot;)
}

fn process_sub&lt;C: Child&gt;(c: C) {
    println!(&quot;process_sub called&quot;);
    c.run();
    c.fly();
}

pub fn do_trait() {
    let a = A {
        name: &quot;this A&quot;.to_string(),
    };
    process(a.clone());
    process_sub(a);

    let b = B {
        name: &quot;this B&quot;.to_string(),
    };
    process(b.clone());
    // process_sub(b); // failed, because process_sub require Child trait, subtype of Base trait, but B only implement Base trait.
    let base = process_return_base();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="closures-and-function-pointer"><a class="header" href="#closures-and-function-pointer">Closures and Function Pointer</a></h2>
<p>Closures merupakan supertype dari function pointer, sehingga bisa saling substituable/covariant.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct A {
    f: fn(i32) -&gt; i32,
    g: for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32,
}

fn accept_closure&lt;F: Fn(i32) -&gt; i32&gt;(f: F, x: i32) {
    println!(&quot;{}&quot;, f(x))
}

fn return_closure() -&gt; impl Fn(i32) -&gt; i32 {
    f
}

fn f(x: i32) -&gt; i32 {
    x
}

fn f_lt(x: &amp;i32) -&gt; &amp;i32 {
    x
}

pub fn f_a() {
    let c = |x: i32| -&gt; i32 { x };
    let a = A { f: c, g: f_lt };
    println!(&quot;{}&quot;, (a.f)(123));
    println!(&quot;{}&quot;, (a.g)(&amp;234));

    accept_closure(f, 5);
    return_closure()(5);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lifetime-1"><a class="header" href="#lifetime-1">Lifetime</a></h2>
<p>Lifetime bisa memiliki subtyping, disebut outliving. Ketika 'a: 'b, berarti lifetime a outlives lifetime b.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lifetime subtyping
pub fn lifetime_subtyping() {
    // 'b
    let b = String::from(&quot;lifetime b&quot;); // lifetime of b is 'b
    let c;
    let d;
    {
        // 'a
        let a = String::from(&quot;lifetime a&quot;); // lifetime of a is 'a
        c = lifetime_b(&amp;a, &amp;b);
        /// error, because c takes lifetime of a which is the current lifetime, while c has type &amp;'b str, and 'a is not subtype of 'b, instead 'b is subtype of 'a
        /// because b live longer than a, b outlives a.
        // c = lifetime_a(&amp;a, &amp;b);
        println!(&quot;{c}&quot;);

        // d get value of lifetime 'a, which is the current lifetime.
        // while lifetime of d declared above is 'b.
        // this works because lifetime is covariant each other.
        // means that lifetime can be substituted with its variances.
        // d is declared inside lifetime 'b, and 'b is subtype of 'a, hence 'a and 'b have relations eachother that 'b extends 'a lifetime.
        // based on this, d will have shorter lifetime than it was declared above, hence cannot live beyond this scope.
        d = lifetime_a(&amp;a, &amp;b);
        println!(&quot;{d}&quot;);
    }
    /// can still access c, because c lifetime is 'b, and value of c returned from lifetime_b() takes lifetime of b, and b is beyond a.
    println!(&quot;{c}&quot;);

    // ! will error because d lifetime has been shortened to 'a inside above scope.
    // println!(&quot;{d}&quot;);
}

// 'b: 'a means b lifetime outlives a, means b live longer than a, means b should live at least as a, means a must die first then b.
fn lifetime_b&lt;'a, 'b: 'a&gt;(a: &amp;'a str, b: &amp;'b str) -&gt; &amp;'b str {
    b
}

fn lifetime_a&lt;'a, 'b: 'a&gt;(a: &amp;'a str, b: &amp;'b str) -&gt; &amp;'a str {
    a
}
<span class="boring">}</span></code></pre></pre>
<h1 id="variances"><a class="header" href="#variances">Variances</a></h1>
<p>Subtyping lebih lanjut membahas tentang type compatibility atau <em>variances</em>. Terdapat 3 jenis variances dalam subtyping:</p>
<ul>
<li>Covariant     = Ketika <strong>subtype</strong> bisa di-pass ke dalam <strong>supertype</strong>, T &lt;: S then T -&gt; S, S(supertype) substituable oleh T(subtype). <em><strong>More Specific</strong></em>.</li>
<li>Contravariant = Ketika <strong>supertype</strong> bisa di-pass ke dalam <strong>subtype</strong>, T &lt;: S then S -&gt; T, T(subtype) substituable oleh S(supertype). <em><strong>More Generic</strong></em>.</li>
<li>Invariant     = Ketika tidak ada hubungan subtyping antara dua tipe. Dalam artian tipe yang di-pass haruslah yang sama persis.</li>
</ul>
<p>Berikut beberapa contoh variances:</p>
<ul>
<li><code>&amp;T</code> &amp; <code>const T</code>: covariant over T. T is subtituable.</li>
<li><code>&amp;mut T</code> &amp; <code>*mut T</code>: invariant over T. T is not substituable, must exact same thing.</li>
<li><code>&amp;'a T</code>: covariant terhadap lifetime 'a dan T. 
<ul>
<li>Substituability applied to lifetime 'a.</li>
<li>Kita bisa mem-passing mutable T ke immutable T.</li>
</ul>
</li>
<li><code>&amp;'a mut T</code>: covariant terhadap lifetime 'a, dan invariant terhadap T.
<ul>
<li>Substituability applied to lifetime 'a.</li>
<li>Kita hanya bisa mem-passing exact mutable T ke mutable T, Sekalipun T punya relasi subtype/supertype.</li>
</ul>
</li>
<li>Smart pointer with <strong>no</strong> interior mutability(Box, Rc, Arc, etc), covariant over its contained types.
<ul>
<li><code>Box&lt;T&gt;</code> is covariant over T. <code>T</code> &lt;: <code>S</code> -&gt; <code>Box&lt;T&gt;</code> &lt;: <code>Box&lt;S&gt;</code>.</li>
</ul>
</li>
<li>Smart pointer with interior mutability(<code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>, <code>UnsafeCell&lt;T&gt;</code>, etc), invariant over its contained types.
<ul>
<li><code>RefCell&lt;T&gt;</code> is invariant over T, artinya T tidak bisa di-substitute oleh hal lain, alias harus sama persis.</li>
</ul>
</li>
<li><code>fn(T) -&gt; U</code>: contravariant over T, covariant over U.</li>
</ul>
<p>Contoh:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// source: https://stackoverflow.com/questions/55344893/what-is-an-example-of-contravariant-use-in-rust

// contravariances
struct MyContraType&lt;Mixed&gt; {
    k1: fn(Mixed), // contravariant over Mixed
}

// Rust is contravariant over function parameters
fn contra_example&lt;'short&gt;(
    mut a: MyContraType&lt;&amp;'short u8&gt;,
    mut b: MyContraType&lt;&amp;'static u8&gt;,
    x: fn(&amp;'short u8),
    y: fn(&amp;'static u8),
) {
    // a = MyContraType&lt;short&gt;.fn(short)
    // b = MyContraType&lt;static&gt;.fn(static)
    // x = fn(short)
    // y = fn(static)
    // static: short
    // short is supertype
    // static is subtype
    // static &lt;: short

    // x(short)  passed into a.k1(short)  = bivariant,     passed
    a.k1 = x;

    // y(static) passed into a.k1(short)  = covariant,     failed
    // because function parameter is contravariant, so we cannot pass subtype(static) into supertype(short)
    // a.k1 = y; // Fails

    // x(short)  passed into b.k1(static) = contravariant, passed
    // static &lt;: short ==&gt; x(short) &lt;: b.k1(static)
    // subtype(static) substituable by supertype(short)
    b.k1 = x;

    // y(static) passed into b.k1(static) = bivariant,     passed
    b.k1 = y;
}

// covariances
struct MyCoType&lt;Mixed&gt; {
    k1: fn() -&gt; Mixed, // covariant over Mixed
}

fn co_example&lt;'short&gt;(
    mut a: MyCoType&lt;&amp;'short u8&gt;,
    mut b: MyCoType&lt;&amp;'static u8&gt;,
    x: fn() -&gt; &amp;'short u8,
    y: fn() -&gt; &amp;'static u8,
) {
    // a = MyCoType&lt;short&gt;.fn() -&gt; short
    // b = MyCoType&lt;static&gt;.fn() -&gt; static
    // x = fn() -&gt; short
    // y = fn() -&gt; static
    // static: short
    // short is supertype
    // static is subtype
    // static &lt;: short

    // x() -&gt; short passed into a.k1() -&gt; short = bivariant, passed
    a.k1 = x;

    // y() -&gt; static passed into a.k1() -&gt; short = covariant, passed
    // static &lt;: short ==&gt; y() -&gt; static &lt;: a.k1() -&gt; short
    // supertype(short) substituable by subtype(static)
    a.k1 = y;

    // x() -&gt; short passed into b.k1() -&gt; static = contravariant, failed
    // because function return is covariant, so we cannot pass supertype(short) into subtype(static)
    // b.k1 = x; // Fails

    // y() -&gt; static passed into b.k1 -&gt; static = bivariant, success
    b.k1 = y;
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-traits"><a class="header" href="#standard-traits">Standard Traits</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
